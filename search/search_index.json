{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\u269c\ufe0f Clientele","text":"\ud83c\udf89 1.0.0 released! \ud83c\udf89 <p>Clientele generates fully-typed, idiomatic python HTTP API clients from OpenAPI 3.0+ schemas.</p> <p>It is designed and tested to work perfectly with the most popular Python API frameworks:</p> <ul> <li>FastAPI</li> <li>Django REST Framework via drf-spectacular</li> <li>Django Ninja</li> </ul>"},{"location":"#what-clientele-does","title":"What Clientele Does","text":"<p>Clientele transforms your OpenAPI schema into a clean, maintainable Python HTTP client with:</p> <ul> <li>Developer first approach designed for a loveable developer experience.</li> <li>Pydantic models for request and response validation.</li> <li>Fully-typed function signatures for IDE autocomplete and type checking.</li> <li>Async support if you want a concurrent client.</li> <li>Multiple formats - class-based or functional, you can choose.</li> <li>Tiny output - the generated code is readable, debuggable Python with only two dependencies.</li> <li>Regeneration-friendly - update your API, regenerate, review the git diff, then ship it!</li> <li>API REPL - a dedicated REPL for exploring and testing the client.</li> <li>Deterministic: No expensive LLMs, no hallucinations - same input always produces same output.</li> </ul>"},{"location":"#when-to-use-clientele","title":"When to Use Clientele","text":""},{"location":"#consumer","title":"Consumer","text":"<ul> <li>You want to use an HTTP API that has an OpenAPI schema</li> <li>And you want to consume that API from a Python application</li> <li>And you want type safety and validation without manual schema maintenance</li> <li>And you want code that is readable, maintainable, and extendable to suit your project</li> </ul>"},{"location":"#publisher","title":"Publisher","text":"<ul> <li>You have an HTTP API that has an OpenAPI schema</li> <li>And you want to offer a client library in Python</li> <li>And you want developers to love using the client</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Clientele can be installed in several ways:</p>"},{"location":"#using-uv-recommended","title":"Using UV (Recommended)","text":"<pre><code>uv tool install clientele\n</code></pre>"},{"location":"#using-homebrew-macoslinux","title":"Using Homebrew (macOS/Linux)","text":"<pre><code>brew install phalt/clientele/clientele\n</code></pre>"},{"location":"#using-pip","title":"Using pip","text":"<pre><code>pip install clientele\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Generate a client from the PokeAPI OpenAPI schema\nclientele generate -u https://raw.githubusercontent.com/PokeAPI/pokeapi/master/openapi.yml -o pokeapi_client/\n# Load the REPL to start testing with the generated code immediately\nclientele explore -c pokeapi_client/\n</code></pre>"},{"location":"#the-generated-code","title":"The generated code","text":"<p>We offer many different flavours of client to suit your needs:</p>"},{"location":"#function-based-client","title":"Function-based client","text":"<pre><code>from my_api import client, schemas\n\n# Pydantic models for inputs and outputs\ndata = schemas.CreateBookRequest(title=\"My awesome book\")\n\n# Easy to read client functions\nresponse = client.create_book(data=data)\n\n# Handle responses elegantly\nmatch response:\n    case schemas.CreateBookResponse():\n        # Handle valid response\n        ...\n    case schemas.ValidationError():\n        # Handle validation error\n        ...\n</code></pre>"},{"location":"#class-based-client","title":"Class-based client","text":"<pre><code>from my_api.client import Client\nfrom my_api import schemas\n\n# Instantiate the client\nclient = Client()\n\n# Pydantic models for inputs and outputs\ndata = schemas.CreateBookRequest(title=\"My awesome book\")\n\n# Call API methods on the client instance\nresponse = client.create_book(data=data)\n\n# Handle responses elegantly\nmatch response:\n    case schemas.CreateBookResponse():\n        # Handle valid response\n        ...\n    case schemas.ValidationError():\n        # Handle validation error\n        ...\n</code></pre>"},{"location":"#async-support","title":"Async support","text":"<p>For both class-based and functional clients we can produce async versions:</p> <pre><code>from my_async_api import client\n\n# Async client functions\nresponse = await client.list_books()\n</code></pre>"},{"location":"#api-explorer","title":"API Explorer","text":"<p>Clientele includes an interactive REPL that lets you explore and test APIs without writing any code:</p> <pre><code># Explore an existing client\nclientele explore -c pokeapi_client/\n\n# Or generate a temporary client from any OpenAPI service on the web and start using it immediately\nclientele explore -u https://raw.githubusercontent.com/PokeAPI/pokeapi/master/openapi.yml\n\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n  Clientele Interactive API Explorer v1.1.0\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\nType /help or ? for commands, /exit or Ctrl+D to quit\nType /list to see available operations\n\nPress TAB for autocomplete\n\n&gt;&gt;&gt;\n</code></pre>"},{"location":"#explorer-features","title":"Explorer Features","text":"<ul> <li>Autocomplete: Press TAB to discover operations and parameters with type hints.</li> <li>Execute instantly: Execute API operations with Python-like syntax.</li> <li>Beautiful output: Syntax-highlighted JSON responses.</li> <li>Command history: Navigate previous commands with UP/DOWN arrows.</li> <li>Local config: Modify configuration locally as you're testing.</li> <li>Debug mode: Run debug mode to see diagnostics and errors.</li> </ul>"},{"location":"#openapi-compatibility","title":"OpenAPI Compatibility","text":"<p>Clientele works by traversing OpenAPI 3.0+ schemas.</p> <p>Any framework or tool that generates standards-compliant OpenAPI schemas should work with Clientele.</p>"},{"location":"#verified-compatibility","title":"Verified Compatibility","text":"<p>We test Clientele against 2000+ real-world OpenAPI schemas from the APIs.guru OpenAPI Directory through a CI cron job.</p> <p>As of our latest run, we successfully generate clients for 95.39% of schemas in the directory.</p> <p></p> <p>Additionally we have specifically built and tested Clientele to support:</p> <ul> <li>FastAPI - 100% compatibility with FastAPI's built-in OpenAPI schema generation.</li> <li>Django REST Framework with drf-spectacular - Full support for DRF's OpenAPI schemas.</li> <li>Django Ninja - Works with Django Ninja's OpenAPI output.</li> </ul>"},{"location":"#server-examples","title":"Server Examples","text":"<p>Working example server applications are available in the <code>server_examples/</code> directory. Read more about each in our documentation:</p> <ul> <li>FastAPI - See <code>server_examples/fastapi/</code></li> <li>Django REST Framework - See <code>server_examples/django-rest-framework/</code></li> <li>Django Ninja - See <code>server_examples/django-ninja/</code></li> </ul> <p>These examples match the code shown in our framework-specific documentation and provide real, working servers you can run locally to test Clientele's client generation.</p>"},{"location":"#additional-features","title":"Additional Features","text":"<ul> <li>Authentication: HTTP Basic and HTTP Bearer authentication built-in.</li> <li>Configuration: A <code>config.py</code> entry point that's never overwritten on regeneration.</li> <li>Testing: Designed for easy testing thanks to respx.</li> <li>Formatting: Automatically formats generated code with Ruff.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>\ud83d\udc49 See our framework-specific guides for FastAPI, Django REST Framework, and Django Ninja</p> <p>\ud83d\udc49 Read the full documentation for advanced usage</p>"},{"location":"CHANGELOG/","title":"Change log","text":""},{"location":"CHANGELOG/#110","title":"1.1.0","text":"<ul> <li>Schema inspection in explore REPL has been improved. Typing a schema name without parentheses now displays the schema's docstring and fields instead of the verbose inherited Pydantic BaseModel documentation.</li> <li>Config objects now handle correctly in explore REPL. Supports old style config functions and the new style classes</li> </ul>"},{"location":"CHANGELOG/#101","title":"1.0.1","text":"<ul> <li>Correct package installation dependencies.</li> </ul>"},{"location":"CHANGELOG/#100","title":"1.0.0","text":""},{"location":"CHANGELOG/#2025-12-27","title":"2025-12-27","text":"<p>Version 1.0.0 represents 12 months of work, planning, testing and using clientele with real APIs. It has major new features and some breaking changes. I recommend completely deleting your previous clients and rebuilding to ensure a smooth rollout.</p> <p>For most of this year I've been constrained by a lack of time to build the features I have planned. With the assistance of supervised agents I have been able to build out most of what I needed, and then spent time correcting and improving the agent's code to be functionally correct.</p> <p>The productivity boost has been immense and has helped me to realise the goals and ambitions I have for this project.</p>"},{"location":"CHANGELOG/#major-new-features","title":"Major new features","text":"<ul> <li>\ud83c\udd95 Explorer CLI: Use <code>clientele explore</code> to use a REPL and discover APIs interactively, even without writing any code.</li> <li>\u2699\ufe0f Rebuilt configuration: <code>config.py</code> has been re-engineered to use pydantic settings.</li> <li>\ud83d\udcdc Rebuilt parser - parsing OpenAPI schema into python objects is now handled entirely by Cicerone, our own OpenAPI parser that was built to meet our unique needs.</li> <li>Clientele now specifically offers 100% support for all major Python API frameworks: FastAPI, Django REST Framework, and Django-Ninja.</li> <li>Clientele is now tested and proven to generate clients for 2000+ openapi schemas as part of our CI. It runs weekly and we use it to ensure broad capability with all OpenAPI services.</li> </ul>"},{"location":"CHANGELOG/#clientele-code-generation-improvements","title":"Clientele code generation improvements","text":"<ul> <li>Fixed function parameter ordering (required parameters before optional ones).</li> <li>Nullable fields properly handled (OpenAPI 3.0 <code>nullable: true</code> and OpenAPI 3.1 array type notation)</li> <li>Fixed: Array responses without a <code>title</code> field now correctly generate type aliases instead of wrapper classes with a <code>test</code> property.</li> <li>Fixed: Responses with no content (e.g., 204 No Content) are now properly included in the status code map with <code>None</code> as the response type.</li> <li>Correctly handle reserved python keywords for schema model properties (i.e. <code>type</code>, <code>next</code> etc).</li> <li>New: Extended httpx configuration options in generated clients - timeout, follow_redirects, verify_ssl, http2, and max_redirects are now configurable.</li> <li>Removed the <code>validate</code> command from the CLI.</li> <li>Replaced <code>openapi-core</code> dependency with <code>cicerone==0.3.0</code> for OpenAPI schema parsing and introspection. This change provides faster, more minimal, and fully typed OpenAPI schema handling.</li> <li>New: Support for OpenAPI <code>deprecated</code> field - operations marked as deprecated will include deprecation warnings in generated docstrings.</li> <li>New: Support for OpenAPI <code>description</code> field - operation descriptions are now included in generated function docstrings for better documentation.</li> <li>Clientele is 100% typed, including the generated code, and verified using ty instead of mypy.</li> <li>Updated all dependencies to their latest stable versions.</li> </ul>"},{"location":"CHANGELOG/#0100","title":"0.10.0","text":"<ul> <li>New: Class-based client generator! Use <code>clientele generate-class</code> to generate a client with a <code>Client</code> class and methods instead of standalone functions.</li> <li>Class-based clients support both sync and async modes with <code>--asyncio t</code> flag.</li> <li>Class-based clients are perfect for object-oriented codebases and when you need to mock the client for testing.</li> <li>New: Dynamic configuration for class-based clients! Class-based clients now accept a <code>Config</code> object in their constructor, allowing you to create multiple clients with different configurations on the fly.</li> <li>The <code>config.py</code> file in class-based clients now generates a <code>Config</code> class instead of standalone functions, enabling runtime configuration changes.</li> <li>You can now instantiate clients with custom configuration: <code>client = Client(config=Config(api_base_url=\"https://api.example.com\", bearer_token=\"my-token\"))</code>.</li> <li>This addresses issues #42 and #49, enabling dynamic auth tokens and multiple clients with different configurations.</li> <li>Updated documentation with comprehensive examples of class-based client usage.</li> <li>Added <code>generate-class</code> command to CLI with full feature parity to the standard <code>generate</code> command.</li> <li>Add ABC (Abstract Base Class) pattern to generators with a <code>Generator</code> base class that all generators inherit from.</li> <li>Refactored all imports to import modules.</li> <li>Changed: Generated code is now auto-formatted with Ruff instead of Black.</li> <li>Breaking change for class-based clients: The <code>config.py</code> file structure has changed from functions to a class. Existing generated clients will need to be regenerated with <code>--regen t</code>.</li> <li>Fixed: OpenAPI <code>number</code> type now correctly maps to Python <code>float</code> instead of <code>int</code>. The <code>integer</code> type continues to map to <code>int</code>, and <code>number</code> with <code>format: \"decimal\"</code> continues to map to <code>decimal.Decimal</code>. This addresses issue #40.</li> <li>New: Python 3.13 and Python 3.14 support! Clientele and all generated clients now officially support Python 3.10, 3.11, 3.12, 3.13, and 3.14.</li> <li>Python 3.9 support has been dropped. If you need Python 3.9 support, please use version 0.9.0 or earlier.</li> </ul>"},{"location":"CHANGELOG/#090","title":"0.9.0","text":"<ul> <li>Support <code>patch</code> methods</li> <li>Fix <code>config.py</code> file being overwritten when generating new clients</li> </ul>"},{"location":"CHANGELOG/#083","title":"0.8.3","text":"<ul> <li>Fix bug with headers assignment</li> </ul>"},{"location":"CHANGELOG/#082","title":"0.8.2","text":"<ul> <li>Improved json support</li> </ul>"},{"location":"CHANGELOG/#081","title":"0.8.1","text":"<ul> <li>Function parameters no longer format to snake_case to maintain consistency with the OpenAPI schema.</li> </ul>"},{"location":"CHANGELOG/#080","title":"0.8.0","text":"<ul> <li>Improved support for Async clients which prevents a weird bug when running more than one event loop. Based on the suggestions from this httpx issue.</li> <li>We now use <code>ruff format</code> for coding formatting (not the client output).</li> <li><code>Decimal</code> support now extends to Decimal input values.</li> <li>Input and Output schemas will now have properties that directly match those provided by the OpenAPI schema. This fixes a bug where previously, the snake-case formatting did not match up with what the API expected to send or receive.</li> </ul>"},{"location":"CHANGELOG/#071","title":"0.7.1","text":"<ul> <li>Support for <code>Decimal</code> types.</li> </ul>"},{"location":"CHANGELOG/#070","title":"0.7.0","text":"<ul> <li>Updated all files to use the templates engine.</li> <li>Generator files have been reorganised in clientele to support future templates.</li> <li><code>constants.py</code> has been renamed to <code>config.py</code> to better reflect how it is used. It is not generated from a template like the other files.</li> <li>If you are using Python 3.10 or later, the <code>typing.Unions</code> types will generate as the short hand <code>|</code> instead.</li> <li>To regenerate a client (and to prevent accidental overrides) you must now pass <code>--regen t</code> or <code>-r t</code> to the <code>generate</code> command. This is automatically added to the line in <code>MANIFEST.md</code> to  help.</li> <li>Clientele will now automatically run black code formatter once a client is generated or regenerated.</li> <li>Clientele will now generate absolute paths to refer to adjacent files in the generated client, instead of relative paths. This assumes you are running the <code>clientele</code> command in the root directory of your project.</li> <li>A lot of documentation and docs strings updates so that code in the generated client is easier to understand.</li> <li>Improved the utility for snake-casing enum keys. Tests added for the functions.</li> <li>Python 3.12 support.</li> <li>Add a \"basic\" client using the command <code>generate-basic</code>. This can be used to keep a consistent file structure for an API that does not use OpenAPI.</li> </ul>"},{"location":"CHANGELOG/#063","title":"0.6.3","text":"<ul> <li>Packaged application installs in the correct location. Resolving #6</li> <li>Updated pyproject.toml to include a better selection of links.</li> </ul>"},{"location":"CHANGELOG/#062","title":"0.6.2","text":"<ul> <li>Ignore optional URL query parameters if they are <code>None</code>.</li> </ul>"},{"location":"CHANGELOG/#061","title":"0.6.1","text":"<ul> <li>Added <code>from __future__ import annotations</code> in files to help with typing evaluation.</li> <li>Update to use pydantic 2.4.</li> <li>A bunch of documentation and readme updates.</li> <li>Small wording and grammar fixes.</li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":"<ul> <li>Significantly improved handling for response schemas. Responses from API endpoints now look at the HTTP status code to pick the correct response schema to generate from the HTTP json data. When regenerating, you will notice a bit more logic generated in the <code>http.py</code> file to handle this.</li> <li>Significantly improved coverage of exceptions raised when trying to generate response schemas.</li> <li>Response types for a class are now sorted.</li> <li>Fixed a bug where <code>put</code> methods did not generate input data correctly.</li> </ul>"},{"location":"CHANGELOG/#052","title":"0.5.2","text":"<ul> <li>Fix pathing for <code>constants.py</code> - thanks to @matthewknight for the contribution!</li> <li>Added <code>CONTRIBUTORS.md</code></li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<ul> <li>Support for HTTP PUT methods</li> <li>Headers objects use <code>exclude_unset</code> to avoid passing <code>None</code> values as headers, which httpx does not support.</li> </ul> <p>Additionally, an async test client is now included in the test suite. It has identical tests to the standard one but uses the async client instead.</p>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/#please-delete-the-constantspy-file-when-updating-to-this-version-to-have-new-features-take-affect","title":"Please delete the constants.py file when updating to this version to have new features take affect","text":"<ul> <li>Paths are resolved correctly when generating clients in nested directories.</li> <li><code>additional_headers()</code> is now applied to every client, allowing you to set up headers for all requests made by your client.</li> <li>When the client cannot match an HTTP response to a return type for the function it will now raise an <code>http.APIException</code>. This object will have the <code>response</code> attached to it for inspection by the developer.</li> <li><code>MANIFEST</code> is now renamed to <code>MANIFEST.md</code> and will include install information for Clientele, as well as information on the command used to generate the client.</li> </ul>"},{"location":"CHANGELOG/#044","title":"0.4.4","text":"<p>Examples and documentation now includes a very complex example schema built using FastAPI that offers the following variations:</p> <ul> <li>Simple request / response (no input just an output)</li> <li>A request with a URL/Path parameter.</li> <li>Models with <code>int</code>, <code>str</code>, <code>list</code>, <code>dict</code>, references to other models, enums, and <code>list</code>s of other models and enums.</li> <li>A request with query parameters.</li> <li>A response model that has optional parameters.</li> <li>An HTTP POST request that takes an input model.</li> <li>An HTTP POST request that takes path parameters and also an input model.</li> <li>An HTTP GET request that requires an HTTP header, and returns it.</li> <li>An HTTP GET endpoint that returns the HTTP bearer authorization token (also makes clientele generate the http authentication for this schema).</li> </ul> <p>A huge test suite has been added to the CI pipeline for this project using a copy of the generated client from the schema above.</p>"},{"location":"CHANGELOG/#043","title":"0.4.3","text":"<ul> <li><code>Enums</code> now inherit from <code>str</code> as well so that they serialize to JSON properly. See this little nugget.</li> </ul>"},{"location":"CHANGELOG/#042","title":"0.4.2","text":"<ul> <li>Correctly use <code>model_rebuild</code> for complex schemas where there are nested schemas, his may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema.</li> <li>Do not raise for status, instead attempt to return the response if it cannot match a response type.</li> </ul>"},{"location":"CHANGELOG/#041","title":"0.4.1","text":"<ul> <li>Correctly generate lists of nested schema classes</li> <li>Correctly build response schemas that are emphemeral (such as when they just return an array of other schemas, or when they have no $ref).</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>Change install suggestion to use pipx as it works best as a global CLI tool.</li> <li>Improved support for OpenAPI 3.0.3 schemas (a test version is available in the example_openapi_specs directory).</li> <li><code>validate</code> command for validating an OpenAPI schema will work with clientele.</li> <li><code>version</code> command for showing the current version of clientele.</li> <li>Supports HTTP DELETE methods.</li> <li>Big refactor of how methods are generated to reduce duplicate code.</li> <li>Support optional header parameters in all request functions (where they are required).</li> <li>Very simple Oauth2 support - if it is discovered will set up HTTP Bearer auth for you.</li> <li>Uses <code>dict</code> and <code>list</code> instead of <code>typing.Dict</code> and <code>typing.List</code> respectively.</li> <li>Improved schema generation when schemas have $ref to other models.</li> </ul>"},{"location":"CHANGELOG/#032","title":"0.3.2","text":"<ul> <li>Minor changes to function name generation to make it more consistent.</li> <li>Optional parameters in schemas are working properly.</li> </ul>"},{"location":"CHANGELOG/#031","title":"0.3.1","text":"<ul> <li>Fixes a bug when generating HTTP Authentication schema.</li> <li>Fixes a bug when generating input classes for post functions, when the input schema doesn't exist yet.</li> <li>Generates pythonic function names in clients now, always (like <code>lower_case_snake_case</code>).</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>Now generates a <code>MANIFEST</code> file with information about the build versions</li> <li>Added a <code>constants.py</code> file to the output if one does not exist yet, which can be used to store values that you do not want to change between subsequent re-generations of the clientele client, such as the API base url.</li> <li>Authentication patterns now use <code>constants.py</code> for constants values.</li> <li>Removed <code>ipython</code> from package dependencies and moved to dev dependencies.</li> <li>Documentation! https://phalt.github.io/clientele/</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>Improved CLI output</li> <li>Code organisation is now sensible and not just one giant file</li> <li>Now supports an openapi spec generated from a dotnet project (<code>Microsoft.OpenApi.Models</code>)</li> <li>async client support  fully working</li> <li>HTTP Bearer support</li> <li>HTTP Basic support</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<ul> <li>Initial version</li> <li>Mostly works with a simple FastAPI generated spec (3.0.2)</li> <li>Works with Twilio's spec (see example_openapi_specs/ directory) (3.0.1)</li> <li>Almost works with stripes</li> </ul>"},{"location":"compatibility/","title":"\ud83d\udcb1 Compatibility","text":""},{"location":"compatibility/#testing-against-real-world-schemas","title":"Testing Against Real-World Schemas","text":"<p>We rigorously test Clientele to ensure it works with real-world OpenAPI schemas.</p> <p>We test against the entire APIs.guru OpenAPI Directory - a collection of 4000+ real-world OpenAPI schemas from hundreds of different APIs.</p> <p>This testing happens automatically:</p> <ul> <li>Weekly CI runs: Every Monday, GitHub Actions runs the test suite against all schemas</li> <li>Manual testing: Developers can run compatibility tests locally</li> <li>Continuous monitoring: Test results are tracked to catch regressions</li> </ul>"},{"location":"compatibility/#current-results","title":"Current results","text":"<p>As of our latest run, we successfully generate clients for 95.39% of schemas in the OpenAPI directory:</p> <pre><code>================================================================================\nSUMMARY\n================================================================================\nTotal schemas found: 4138\nSuccessful: 1884\nSkipped (version incompatible): 2163\nFailed: 91\nSuccess rate: 95.39% (1884/1975 testable schemas)\n\n91 schemas failed to generate clients:\n  - APIs/akeneo.com/1.0.0/swagger.yaml\n  - APIs/apicurio.local/registry/1.3.2.Final/openapi.yaml\n  - APIs/apidapp.com/2019-02-14T164701Z/openapi.yaml\n  - APIs/apideck.com/file-storage/10.0.0/openapi.yaml\n  - APIs/atlassian.com/jira/1001.0.0-SNAPSHOT/openapi.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Authoring/2.0/swagger.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Authoring/3.0-preview/swagger.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Programmatic/v2.0/swagger.yaml\n  - APIs/billingo.hu/3.0.7/openapi.yaml\n  - APIs/bunq.com/1.0/openapi.yaml\n  ... and 81 more\n  ```\n\n### Running Compatibility Tests\n\nYou can run the compatibility tests yourself:\n\n```bash\n# Test against all schemas (takes several minutes)\nmake test-openapi-directory\n\n# Test a limited subset for quick feedback\npython3 test_openapi_directory.py --limit 100\n\n# Stop on first failure for debugging\npython3 test_openapi_directory.py -x\n\n# Keep the cloned repository for inspection\npython3 test_openapi_directory.py --keep-repo\n</code></pre>"},{"location":"compatibility/#openapi-version-support","title":"OpenAPI Version Support","text":"<p>Clientele is designed for OpenAPI 3.0.x schemas and supports most standard-compliant implementations.</p>"},{"location":"compatibility/#fully-supported","title":"Fully Supported","text":"<ul> <li>OpenAPI 3.0.0, 3.0.1, 3.0.2, 3.0.3 - Full support for all standard features</li> </ul>"},{"location":"compatibility/#partial-support","title":"Partial Support","text":"<ul> <li>OpenAPI 3.1.x - Many OpenAPI 3.1 schemas work, but some advanced 3.1-specific features may not be fully supported yet.</li> </ul>"},{"location":"compatibility/#not-supported","title":"Not Supported","text":"<ul> <li>OpenAPI 2.0 (Swagger) - The 2.0 format is deprecated and significantly different from 3.0+. Clientele does not support it. If you have a Swagger 2.0 schema, consider upgrading it to OpenAPI 3.0+ first.</li> </ul>"},{"location":"compatibility/#framework-compatibility","title":"Framework Compatibility","text":"<p>Clientele works with any tool that generates standard OpenAPI 3.0+ schemas. We actively test and verify compatibility with these Python frameworks:</p>"},{"location":"compatibility/#python-web-frameworks","title":"Python Web Frameworks","text":""},{"location":"compatibility/#fastapi","title":"\u2705 FastAPI","text":"<p>Status: 100% compatibility guaranteed</p> <p>FastAPI is Clientele's primary target framework. FastAPI's automatic OpenAPI schema generation works perfectly with Clientele.</p> <ul> <li>Schema location: Usually <code>/openapi.json</code></li> <li>operationId: Auto-generated or customizable via <code>operation_id</code> parameter</li> <li>Async support: Full support for both sync and async clients</li> <li>Authentication: Bearer tokens, Basic auth, OAuth2 flows</li> </ul> <p>Learn more: Using Clientele with FastAPI</p>"},{"location":"compatibility/#django-rest-framework-drf-spectacular","title":"\u2705 Django REST Framework + drf-spectacular","text":"<p>Status: Full compatibility</p> <p>Django REST Framework with drf-spectacular generates high-quality OpenAPI 3.0 schemas.</p> <ul> <li>Schema location: Configurable, typically <code>/api/schema/</code></li> <li>operationId: Customizable via <code>@extend_schema(operation_id=...)</code></li> <li>Serializers: Convert seamlessly to Pydantic models</li> <li>ViewSets: All CRUD operations supported</li> </ul> <p>We've tested Clientele with numerous DRF APIs - see this GitHub issue for specific schemas we've validated.</p> <p>Learn more: Using Clientele with Django REST Framework</p>"},{"location":"compatibility/#django-ninja","title":"\u2705 Django Ninja","text":"<p>Status: Native support</p> <p>Django Ninja uses Pydantic for schemas, which aligns perfectly with Clientele's output.</p> <ul> <li>Schema location: Usually <code>/api/openapi.json</code></li> <li>operationId: Customizable via <code>operation_id</code> parameter</li> <li>Schemas: Already uses Pydantic, no conversion needed</li> <li>Async support: Supports both sync and async views</li> </ul> <p>Learn more: Using Clientele with Django Ninja</p>"},{"location":"compatibility/#other-tested-apis","title":"Other Tested APIs","text":"<p>We've successfully generated clients from:</p> <ul> <li>Microsoft Azure APIs - Battle-tested and works well</li> <li>Twilio's API - Tested with real-world complexity</li> <li>Various public APIs with standard OpenAPI 3.0.x schemas</li> </ul>"},{"location":"compatibility/#schema-feature-support","title":"Schema Feature Support","text":""},{"location":"compatibility/#fully-supported-features","title":"Fully Supported Features","text":"<p>\u2705 Request/Response schemas - All HTTP methods (GET, POST, PUT, PATCH, DELETE) \u2705 Path parameters - URL path variables \u2705 Query parameters - URL query strings, optional and required \u2705 Request bodies - JSON request payloads \u2705 Multiple response types - Different responses per status code \u2705 Pydantic-compatible types - Strings, integers, floats, booleans, dates, enums \u2705 Arrays and lists - Including nested arrays \u2705 Nested objects - Complex object hierarchies \u2705 References (<code>$ref</code>) - Schema reuse throughout the spec \u2705 <code>oneOf</code> - Discriminated unions with type aliases \u2705 <code>anyOf</code> - Flexible union types \u2705 <code>allOf</code> - Schema composition and inheritance \u2705 <code>nullable</code> - Optional/nullable fields \u2705 Enums - Enumerated string values \u2705 HTTP Bearer authentication - Token-based auth \u2705 HTTP Basic authentication - Username/password auth</p>"},{"location":"compatibility/#partially-supported-or-limited","title":"Partially Supported or Limited","text":"<p>\u26a0\ufe0f File uploads - May require manual customization \u26a0\ufe0f OpenAPI 3.1 specific features - Some edge cases may not work \u26a0\ufe0f OAuth2 flows - Schema is parsed, but token acquisition must be handled manually in <code>config.py</code> \u26a0\ufe0f Complex polymorphism - Some exotic <code>oneOf</code>/<code>anyOf</code> combinations may need adjustment \u26a0\ufe0f Webhooks and Callbacks - Schema elements may be ignored</p>"},{"location":"compatibility/#not-supported_1","title":"Not Supported","text":"<p>\u274c File downloads - Response file handling not generated \u274c Server-Sent Events (SSE) - Streaming responses not supported \u274c WebSockets - Not applicable to HTTP clients \u274c Cookie authentication - Must be handled manually  </p>"},{"location":"compatibility/#known-schema-issues","title":"Known Schema Issues","text":""},{"location":"compatibility/#poor-openapi-implementations","title":"Poor OpenAPI Implementations","text":"<p>Despite a well-defined specification, we've discovered many tools generate non-standard OpenAPI schemas.</p> <p>What this means for you:</p> <ul> <li>Some schema generators sometimes have bugs or take liberties with the spec</li> <li>We can't guarantee 100% compatibility with every OpenAPI schema outside the core frameworks we test</li> </ul> <p>Recommendation:</p> <ul> <li>Report issues with specific schemas to help us improve</li> <li>For FastAPI, DRF, and Django Ninja, compatibility is guarenteed</li> </ul>"},{"location":"compatibility/#openapi-31-caveats","title":"OpenAPI 3.1 Caveats","text":"<p>OpenAPI 3.1 aligned with JSON Schema 2020-12, introducing changes:</p> <ul> <li><code>nullable</code> was replaced with <code>type: [...]</code> arrays</li> <li>Some keywords changed semantics</li> <li>Schema validation is stricter</li> </ul> <p>Current state:</p> <ul> <li>Nearly all OpenAPI 3.1 schemas work fine</li> <li>Some 3.1-specific features may not be fully supported</li> <li>We primarily target OpenAPI 3.0.x for guaranteed compatibility</li> </ul>"},{"location":"compatibility/#when-things-dont-work","title":"When Things Don't Work","text":"<p>If you encounter a schema that doesn't work with Clientele:</p> <ol> <li>Check the version: Ensure it's OpenAPI 3.0.x (not 2.0 or unusual 3.1 features)</li> <li>Try generation anyway: Sometimes validation is overly strict</li> <li>Report issues: Open a GitHub issue with your schema (or a minimal example)</li> </ol>"},{"location":"compatibility/#best-practices-for-compatibility","title":"Best Practices for Compatibility","text":""},{"location":"compatibility/#for-api-developers","title":"For API Developers","text":"<p>If you're developing an API that others will consume with Clientele:</p> <ol> <li>Use FastAPI, DRF + drf-spectacular, or Django Ninja for best results</li> <li>Provide custom <code>operationId</code> values for readable function names</li> <li>Document your schemas with descriptions and examples</li> <li>Test your OpenAPI schema with <code>clientele validate</code></li> <li>Avoid exotic schema features unless necessary</li> <li>Stick to OpenAPI 3.0.x for maximum compatibility</li> </ol>"},{"location":"compatibility/#for-client-developers","title":"For Client Developers","text":"<p>If you're consuming an API with Clientele:</p> <ol> <li>Validate first: Run <code>clientele validate</code> before generating</li> <li>Start with framework guides: If using FastAPI/DRF/Ninja, follow the specific guide</li> <li>Review generated code: Ensure it matches your expectations</li> <li>Test thoroughly: The generated client should be tested like any dependency</li> <li>Report issues: Help us improve by reporting problematic schemas</li> </ol>"},{"location":"compatibility/#summary","title":"Summary","text":"Feature Support Level Notes OpenAPI 3.0.x \u2705 Full Primary target, fully supported OpenAPI 3.1.x \u26a0\ufe0f Partial Most features work, some edge cases may not OpenAPI 2.0 \u274c None Not supported, use 3.0+ instead FastAPI \u2705 Full 100% compatibility DRF + drf-spectacular \u2705 Full Extensively tested Django Ninja \u2705 Full Native Pydantic alignment Complex schemas \u2705 Most <code>oneOf</code>, <code>anyOf</code>, <code>allOf</code>, <code>nullable</code> supported File operations \u26a0\ufe0f Limited May need manual customization Authentication \u2705 Basic/Bearer OAuth2 flows need manual token handling"},{"location":"complex_schemas/","title":"\ud83d\udd00 Complex Schemas","text":"<p>Clientele fully supports OpenAPI's complex schema combinations including <code>oneOf</code>, <code>anyOf</code>, and <code>nullable</code> fields. This ensures proper type discrimination and null handling in your generated clients.</p>"},{"location":"complex_schemas/#oneof-discriminated-unions","title":"oneOf - Discriminated Unions","text":"<p>The <code>oneOf</code> keyword indicates that a value must match exactly one of several schemas. This is useful for modeling polymorphic types where you know the exact type at runtime.</p>"},{"location":"complex_schemas/#schema-example","title":"Schema Example","text":"<pre><code>{\n  \"components\": {\n    \"schemas\": {\n      \"Cat\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": { \"type\": \"string\", \"enum\": [\"cat\"] },\n          \"meow_volume\": { \"type\": \"integer\" }\n        }\n      },\n      \"Dog\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"type\": { \"type\": \"string\", \"enum\": [\"dog\"] },\n          \"bark_volume\": { \"type\": \"integer\" }\n        }\n      },\n      \"PetRequest\": {\n        \"oneOf\": [\n          { \"$ref\": \"#/components/schemas/Cat\" },\n          { \"$ref\": \"#/components/schemas/Dog\" }\n        ],\n        \"discriminator\": {\n          \"propertyName\": \"type\"\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"complex_schemas/#generated-code","title":"Generated Code","text":"<p>Clientele generates a type alias for <code>oneOf</code> schemas using <code>typing.Union</code>:</p> <pre><code>class Cat(pydantic.BaseModel):\n    type_: str\n    meow_volume: int\n\nclass Dog(pydantic.BaseModel):\n    type_: str\n    bark_volume: int\n\n# Type alias for the union (using typing.Union for forward references)\nPetRequest = typing.Union[Cat, Dog]\n</code></pre>"},{"location":"complex_schemas/#usage","title":"Usage","text":"<p>You can use the generated type alias with proper type checking:</p> <pre><code>from my_client import client, schemas\n\n# Create a cat\ncat = schemas.Cat(type_=\"cat\", meow_volume=10)\nresponse = client.create_pet(data=cat)\n\n# Create a dog\ndog = schemas.Dog(type_=\"dog\", bark_volume=15)\nresponse = client.create_pet(data=dog)\n\n# Pattern matching for handling the response\nmatch response:\n    case schemas.Cat():\n        print(f\"Cat meows at volume {response.meow_volume}\")\n    case schemas.Dog():\n        print(f\"Dog barks at volume {response.bark_volume}\")\n</code></pre>"},{"location":"complex_schemas/#anyof-flexible-unions","title":"anyOf - Flexible Unions","text":"<p>The <code>anyOf</code> keyword indicates that a value can match one or more of the specified schemas. This is useful when you need flexibility in the types accepted.</p>"},{"location":"complex_schemas/#schema-example_1","title":"Schema Example","text":"<pre><code>{\n  \"components\": {\n    \"schemas\": {\n      \"FlexibleIdResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"anyOf\": [\n              { \"type\": \"string\" },\n              { \"type\": \"integer\" }\n            ]\n          },\n          \"data\": { \"type\": \"string\" }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"complex_schemas/#generated-code_1","title":"Generated Code","text":"<p>Clientele generates union types for <code>anyOf</code> schemas:</p> <pre><code>class FlexibleIdResponse(pydantic.BaseModel):\n    id: str | int\n    data: str\n</code></pre>"},{"location":"complex_schemas/#usage_1","title":"Usage","text":"<p>The generated types work seamlessly with Pydantic's validation:</p> <pre><code>from my_client import client, schemas\n\n# Both string and integer IDs are valid\nresponse1 = schemas.FlexibleIdResponse(id=\"abc123\", data=\"test\")\nresponse2 = schemas.FlexibleIdResponse(id=12345, data=\"test\")\n\n# Pydantic handles validation automatically\nresponse = client.get_flexible_data()\nif isinstance(response.id, str):\n    print(f\"String ID: {response.id}\")\nelif isinstance(response.id, int):\n    print(f\"Integer ID: {response.id}\")\n</code></pre>"},{"location":"complex_schemas/#nullable-optional-values","title":"nullable - Optional Values","text":"<p>The <code>nullable</code> keyword indicates that a field can be <code>null</code> in addition to its defined type. Clientele converts nullable fields to proper Python <code>Optional</code> types.</p>"},{"location":"complex_schemas/#schema-example_2","title":"Schema Example","text":"<pre><code>{\n  \"components\": {\n    \"schemas\": {\n      \"NullableFieldsResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"required_field\": { \"type\": \"string\" },\n          \"optional_nullable_field\": {\n            \"type\": \"string\",\n            \"nullable\": true\n          },\n          \"nullable_number\": {\n            \"type\": \"integer\",\n            \"nullable\": true\n          }\n        },\n        \"required\": [\"required_field\"]\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"complex_schemas/#generated-code_2","title":"Generated Code","text":"<p>Clientele generates <code>Optional</code> types for nullable fields:</p> <pre><code>class NullableFieldsResponse(pydantic.BaseModel):\n    required_field: str\n    optional_nullable_field: typing.Optional[str]\n    nullable_number: typing.Optional[int]\n</code></pre>"},{"location":"complex_schemas/#usage_2","title":"Usage","text":"<p>Nullable fields work naturally with Python's type system:</p> <pre><code>from my_client import client, schemas\n\n# All of these are valid\nresponse1 = schemas.NullableFieldsResponse(\n    required_field=\"test\",\n    optional_nullable_field=\"value\",\n    nullable_number=42\n)\n\nresponse2 = schemas.NullableFieldsResponse(\n    required_field=\"test\",\n    optional_nullable_field=None,  # Explicitly null\n    nullable_number=None\n)\n\nresponse3 = schemas.NullableFieldsResponse(\n    required_field=\"test\"  # Optional fields can be omitted\n)\n\n# Check for null values\nresponse = client.get_data()\nif response.optional_nullable_field is not None:\n    print(f\"Value: {response.optional_nullable_field}\")\nelse:\n    print(\"Field is null\")\n</code></pre>"},{"location":"complex_schemas/#complex-combinations","title":"Complex Combinations","text":"<p>You can combine <code>oneOf</code>, <code>anyOf</code>, and <code>nullable</code> for even more expressive schemas:</p>"},{"location":"complex_schemas/#schema-example_3","title":"Schema Example","text":"<pre><code>{\n  \"properties\": {\n    \"payment_method\": {\n      \"oneOf\": [\n        { \"$ref\": \"#/components/schemas/CreditCard\" },\n        { \"$ref\": \"#/components/schemas/BankTransfer\" },\n        { \"$ref\": \"#/components/schemas/PayPal\" }\n      ],\n      \"nullable\": true\n    }\n  }\n}\n</code></pre>"},{"location":"complex_schemas/#generated-code_3","title":"Generated Code","text":"<pre><code># Type alias with optional wrapper (using typing.Union for forward refs)\nPaymentMethod = typing.Optional[typing.Union[CreditCard, BankTransfer, PayPal]]\n</code></pre>"},{"location":"complex_schemas/#python-version-compatibility","title":"Python Version Compatibility","text":"<p>Clientele generates code compatible with your Python version:</p> <ul> <li>Python 3.10+: Uses modern union syntax (<code>str | int</code>) for inline types</li> <li>Forward references: Always uses <code>typing.Union</code> (e.g., <code>typing.Union[\"Cat\", \"Dog\"]</code>) because the <code>|</code> operator doesn't work with string literals</li> </ul> <p>The generated code automatically adapts to your target Python version for maximum compatibility.</p>"},{"location":"complex_schemas/#testing-with-complex-schemas","title":"Testing with Complex Schemas","text":"<p>Complex schemas work beautifully with pattern matching and type checking:</p> <pre><code>from my_client import client, schemas\n\ndef handle_pet(pet: schemas.Cat | schemas.Dog) -&gt; str:\n    match pet:\n        case schemas.Cat(meow_volume=vol):\n            return f\"Cat meows at volume {vol}\"\n        case schemas.Dog(bark_volume=vol):\n            return f\"Dog barks at volume {vol}\"\n\n# Your IDE will provide full autocomplete and type checking\nresponse = client.get_pet()\nmessage = handle_pet(response)\n</code></pre>"},{"location":"complex_schemas/#why-this-matters","title":"Why This Matters","text":"<p>Proper support for <code>oneOf</code>, <code>anyOf</code>, and <code>nullable</code> ensures:</p> <ol> <li>Type Safety: Your IDE and type checkers understand exactly what types are valid</li> <li>Better Developer Experience: Autocomplete works correctly for union types</li> <li>Runtime Validation: Pydantic validates that values match the schema</li> <li>Clear Code: Type aliases make complex schemas easy to understand</li> <li>Pattern Matching: Python 3.10+ pattern matching works seamlessly</li> </ol> <p>This puts Clientele on par with (or ahead of) commercial alternatives like Speakeasy, while maintaining our commitment to clean, readable, Pythonic code.</p>"},{"location":"configuration/","title":"\u2699\ufe0f Client Configuration","text":"<p>Both function-based and class-based clients support extensive configuration options to customize HTTP client behavior using pydantic-settings.</p>"},{"location":"configuration/#configuration-options","title":"Configuration Options","text":"<p>All generated clients support the following configuration options:</p>"},{"location":"configuration/#authentication","title":"Authentication","text":"<ul> <li><code>api_base_url</code>: Base URL for the API (default: <code>\"http://localhost\"</code>)</li> <li><code>user_key</code>: Username for HTTP Basic authentication (default: <code>\"user\"</code>)</li> <li><code>pass_key</code>: Password for HTTP Basic authentication (default: <code>\"password\"</code>)</li> <li><code>bearer_token</code>: Token for HTTP Bearer authentication (default: <code>\"token\"</code>)</li> <li><code>additional_headers</code>: Additional headers to include in all requests (default: <code>{}</code>)</li> </ul> <p>Optional Authentication</p> <p>For clients with HTTP Basic authentication, if both <code>user_key</code> and <code>pass_key</code> are empty or <code>None</code>, authentication will be disabled. This allows you to optionally disable authentication when needed.</p>"},{"location":"configuration/#http-behavior","title":"HTTP Behavior","text":"<ul> <li><code>timeout</code>: Request timeout in seconds (default: <code>5.0</code>)</li> <li><code>follow_redirects</code>: Whether to automatically follow HTTP redirects (default: <code>False</code>)</li> <li><code>max_redirects</code>: Maximum number of redirects to follow (default: <code>20</code>)</li> </ul>"},{"location":"configuration/#security","title":"Security","text":"<ul> <li><code>verify_ssl</code>: Whether to verify SSL certificates (default: <code>True</code>)</li> </ul>"},{"location":"configuration/#performance","title":"Performance","text":"<ul> <li><code>http2</code>: Whether to enable HTTP/2 support (default: <code>False</code>)</li> <li><code>limits</code>: Connection pool limits via <code>httpx.Limits</code> (default: <code>None</code>)</li> <li><code>transport</code>: Custom transport via <code>httpx.HTTPTransport</code> or <code>httpx.AsyncHTTPTransport</code> (default: <code>None</code>)</li> </ul>"},{"location":"configuration/#function-based-client-configuration","title":"Function-Based Client Configuration","text":"<p>Function-based clients use a <code>Config</code> object powered by pydantic-settings that automatically loads values from environment variables:</p> <pre><code># In your generated client's config.py file\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass Config(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"ignore\",\n    )\n\n    api_base_url: str = \"http://localhost\"\n    bearer_token: str = \"token\"\n    timeout: float = 5.0\n    follow_redirects: bool = False\n    verify_ssl: bool = True\n    http2: bool = False\n    # ... other configuration options\n\n# Create a singleton instance\nconfig = Config()\n</code></pre>"},{"location":"configuration/#setting-values","title":"Setting Values","text":"<p>There are three ways to configure function-based clients:</p>"},{"location":"configuration/#1-environment-variables-recommended-for-production","title":"1. Environment Variables (Recommended for Production)","text":"<pre><code>export API_BASE_URL=\"https://api.production.com\"\nexport BEARER_TOKEN=\"your-secret-token\"\nexport TIMEOUT=30.0\nexport HTTP2=true\nexport FOLLOW_REDIRECTS=true\n</code></pre>"},{"location":"configuration/#2-direct-instantiation-for-testingdevelopment","title":"2. Direct Instantiation (For Testing/Development)","text":"<pre><code># Modify the default values in config.py\nfrom my_client import config\n\nconfig.config = config.Config(\n    api_base_url=\"https://api.example.com\",\n    bearer_token=\"my-token\",\n    timeout=30.0,\n    http2=True\n)\n</code></pre>"},{"location":"configuration/#3-env-file-requires-python-dotenv","title":"3. .env File (Requires python-dotenv)","text":"<pre><code># .env file in your project root\nAPI_BASE_URL=https://api.example.com\nBEARER_TOKEN=my-token\nTIMEOUT=30.0\nVERIFY_SSL=false\n</code></pre>"},{"location":"configuration/#4-custom-environment-variable-names","title":"4. Custom Environment Variable Names","text":"<p>If the default environment variable names are too generic for your use case, you can customize them using pydantic's <code>Field</code> with the <code>validation_alias</code> parameter:</p> <pre><code># In your generated client's config.py file\nfrom pydantic import Field\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass Config(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"ignore\",\n    )\n\n    api_base_url: str = Field(\n        default=\"http://localhost\",\n        validation_alias=\"MY_APP_API_BASE_URL\"\n    )\n    bearer_token: str = Field(\n        default=\"token\",\n        validation_alias=\"MY_APP_BEARER_TOKEN\"\n    )\n    timeout: float = Field(\n        default=5.0,\n        validation_alias=\"MY_APP_TIMEOUT\"\n    )\n    # ... other configuration options\n\nconfig = Config()\n</code></pre> <p>Now you can use custom environment variable names:</p> <pre><code>export MY_APP_API_BASE_URL=\"https://api.production.com\"\nexport MY_APP_BEARER_TOKEN=\"your-secret-token\"\nexport MY_APP_TIMEOUT=30.0\n</code></pre> <p>This is particularly useful when:</p> <ul> <li>You have multiple API clients in the same application</li> <li>You want to avoid naming conflicts with other environment variables</li> <li>Your organization has specific naming conventions for environment variables</li> </ul>"},{"location":"configuration/#class-based-client-configuration","title":"Class-Based Client Configuration","text":"<p>Class-based clients use the same <code>Config</code> class with the same pydantic-settings support. Pass configuration options when creating the client:</p> <pre><code>from my_client.client import Client\nfrom my_client import config\n\n# From environment variables\ncfg = config.Config()  # Automatically loads from env vars\nclient = Client(config=cfg)\n\n# Or with explicit values\ncustom_config = config.Config(\n    api_base_url=\"https://api.production.com\",\n    bearer_token=\"your-api-token\",\n    timeout=30.0,\n    follow_redirects=True,\n    verify_ssl=True,\n    http2=True,\n    max_redirects=10,\n)\n\nclient = Client(config=custom_config)\n</code></pre>"},{"location":"configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"configuration/#increase-timeout-for-slow-apis","title":"Increase Timeout for Slow APIs","text":"<pre><code># Function-based client (via environment variable)\nexport TIMEOUT=60.0\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(timeout=60.0)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(timeout=60.0)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"configuration/#enable-http2-for-better-performance","title":"Enable HTTP/2 for Better Performance","text":"<pre><code># Function-based client (via environment variable)\nexport HTTP2=true\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(http2=True)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(http2=True)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"configuration/#development-environment-disable-ssl-verification","title":"Development Environment (Disable SSL Verification)","text":"<p>Warning</p> <p>Only disable SSL verification in development environments. Never disable it in production!</p> <pre><code># Function-based client (via environment variable)\nexport VERIFY_SSL=false\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(verify_ssl=False)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(verify_ssl=False)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"configuration/#follow-redirects","title":"Follow Redirects","text":"<pre><code># Function-based client (via environment variables)\nexport FOLLOW_REDIRECTS=true\nexport MAX_REDIRECTS=5\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(follow_redirects=True, max_redirects=5)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(follow_redirects=True, max_redirects=5)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"configuration/#configure-connection-pool-limits","title":"Configure Connection Pool Limits","text":"<p>Control connection pooling behavior with <code>httpx.Limits</code>:</p> <pre><code>import httpx\n\n# Function-based client\n# Note: Complex objects like httpx.Limits must be set in code, not env vars\nfrom my_client import config\nconfig.config = config.Config(\n    limits=httpx.Limits(\n        max_keepalive_connections=10,\n        max_connections=20,\n        keepalive_expiry=5.0\n    )\n)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(\n    limits=httpx.Limits(\n        max_keepalive_connections=10,\n        max_connections=20\n    )\n)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"configuration/#configure-custom-transport","title":"Configure Custom Transport","text":"<p>Customize low-level HTTP behavior with a custom transport:</p> <pre><code>import httpx\n\n# Function-based client (sync)\n# Note: Complex objects like httpx.HTTPTransport must be set in code\nfrom my_client import config\nconfig.config = config.Config(\n    transport=httpx.HTTPTransport(\n        retries=3,\n        local_address=\"0.0.0.0\"\n    )\n)\n\n# Function-based client (async)\nfrom my_async_client import config\nconfig.config = config.Config(\n    transport=httpx.AsyncHTTPTransport(retries=3)\n)\n\n# Class-based client (sync)\nfrom my_client import config\ncfg = config.Config(\n    transport=httpx.HTTPTransport(retries=3)\n)\nclient = Client(config=cfg)\n\n# Class-based client (async)\nfrom my_client import config\ncfg = config.Config(\n    transport=httpx.AsyncHTTPTransport(retries=3)\n)\nclient = AsyncClient(config=cfg)\n</code></pre>"},{"location":"configuration/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"configuration/#mixing-environment-variables-and-code","title":"Mixing Environment Variables and Code","text":"<p>You can load base configuration from environment variables and override specific values in code:</p> <pre><code>import httpx\nfrom my_client import config\n\n# Loads API_BASE_URL, BEARER_TOKEN, etc. from environment\n# But overrides timeout and adds custom limits\ncfg = config.Config(\n    timeout=60.0,  # Override env var if present\n    limits=httpx.Limits(max_connections=50)  # Can't be set via env\n)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"configuration/#multiple-clients-with-different-configurations","title":"Multiple Clients with Different Configurations","text":"<p>Class-based clients make it easy to create multiple clients with different configurations:</p> <pre><code>from my_client.client import Client\nfrom my_client import config\n\n# Production client\nprod_config = config.Config(\n    api_base_url=\"https://api.production.com\",\n    bearer_token=\"prod-token\",\n    verify_ssl=True\n)\nprod_client = Client(config=prod_config)\n\n# Staging client\nstaging_config = config.Config(\n    api_base_url=\"https://api.staging.com\",\n    bearer_token=\"staging-token\",\n    verify_ssl=False\n)\nstaging_client = Client(config=staging_config)\n\n# Use both clients in the same application\nprod_response = prod_client.get_user(user_id=123)\nstaging_response = staging_client.get_user(user_id=123)\n</code></pre>"},{"location":"design/","title":"\ud83c\udfa8 Design","text":""},{"location":"design/#a-brief-history-of-http-apis","title":"A brief history of HTTP APIs","text":"<p>Hello, I am Paul Hallett - a lead software engineer who has spent over 10 years fascinated by and building HTTP APIs for both massive and small tech companies.</p> <p>When I started building my first hobby project - PokeAPI - I had one issue I wanted to solve: show how important good API design is by building a \"pure\" example. PokeAPI was a huge success, and still is, with over 1 billion API requests a month, it is one of the most popular free HTTP APIs on the web.</p> <p>Around this time Swagger was being introduced. Slowly over time adoption built up. This was also around the same time the SaaS and \"API product\" boom happened - companies like Twilio, Stripe, and Sendgrid were the coolest startups in tech and their product was pure HTTP APIs. A lot of them offered Swagger schemas for their APIs.</p> <p>In 2015 Swagger was renamed to OpenAPI. Two years later the 3.0 version of finalised, with version 3.1 coming along in 2021.</p>"},{"location":"design/#openapi-client-generators","title":"OpenAPI client generators","text":"<p>Every few years I check the HTTP API landscape to see what has changed, and what new tooling is available.</p> <p>A big part of this research is seeing how far OpenAPI client generators have come.  </p> <p>Despite the heavy adoption of OpenAPI schema generators, the \"last mile\" (i.e. - generating, and using, a client library) still has a experience nowhere near the maturity as the schema generator landscape. The great thing about schema generators these days is they are seemlessly blended in - most API frameworks, especially in the Python landscape, generate schemas as standard.</p> <p>But my experience with most client generators always falls into one of these buckets:</p> <ul> <li> <p>The generated code is difficult to read, meaning I don't fully trust it, and often leads to problems when trying to debug the code. Nearly all of the time the code is not idiomatic to Python.</p> </li> <li> <p>The generated code is often repetitive and very large, meaning it is tedious to support.</p> </li> <li> <p>You have to install a lot of extra tooling just to get started.</p> </li> </ul> <p>This experience isn't ideal, and is often such an impedance that it just isn't worth it. I would always prefer instead to take a template of my own choosing, refined from years of working with HTTP APIs, and adapt it to whatever new API I was consuming. And this isn't just my own personal opinion - in every place I have worked I have seen this - developers never using a client generator and instead opting to just roll with a custom built client.</p> <p>Just as the Python community made a great experience for schema generators, surely we could make one for client generators?</p>"},{"location":"design/#2023-and-the-start-of-clientele","title":"2023 and the start of Clientele","text":"<p>In the early part of 2023, I had to build an integration with a new HTTP API.</p> <p>So, like I did in the past, I used it as an opportunity to asses the landscape of OpenAPI client generators.</p> <p>And this was our summary at the time of writing:</p> <ul> <li> <p>API tools and providers had adopted OpenAPI very well. For example - tools like FastAPI and drf-spectacular now make it easy for the most popular python web frameworks to publish OpenAPI schemas.</p> </li> <li> <p>There are a lot of options for generating clients. They all meet the need of \"generating a python client using the schema\". But, almost universally, they have a poor developer experience.</p> </li> </ul> <p>After evaluating many python client generators, I opted to use none of them and instead hand craft the API client myself. I used the OpenAPI schema as a source to develop the input and output objects. Then I wrote a small functional abstraction over the paths.</p> <p>Looking back over my organised, pythonic, minimal client integration, I had an idea:</p> <p>If this is the type of client I would like a client generator to produce; how hard could it be to work backwards and generate this layout?</p> <p>The schema became my input. The client I had just made became my output. I had all the parts I needed to start a project.</p> <p>This was the start of Clientele.</p>"},{"location":"design/#clientele","title":"Clientele","text":"<p>As a python developer I know what makes good, readable, idiomatic python.</p> <p>I also feel like I have a pretty good grasp on the best tools to be using in our python projects as I'm involved in the community and constantly trying out new stuff.</p> <p>By starting with a client library that I like to use, and working backwards, I was able to build a client generator that produced something that I felt that python developers actually wanted.</p> <p>But why is this the OpenAPI Python client that I think everyone should use?</p>"},{"location":"design/#strongly-typed-inputs-and-outputs","title":"Strongly-typed inputs and outputs","text":"<p>OpenAPI prides itself on being able to describe the input and output objects in its schema.</p> <p>This means you can build strongly-typed interfaces to the API. This helps to solve some common niggles when using an API - such as casting a value to a string when it should be an integer.</p> <p>With Clientele, I opted to use Pydantic to build the models from the OpenAPI schema.</p> <p>Pydantic doesn't only describe the shape of an object, it also validates the attributes. If an API sends back the wrong attributes at runtime, Pydantic will error and provide a detailed description of what went wrong. It's also super fast.</p>"},{"location":"design/#idiomatic-python","title":"Idiomatic Python","text":"<p>A lot of the client generators I tested produced a lot of obtuse and hard to read code.</p> <p>It was clear in a few cases that the client generator was built without understanding or knowledge of good Python conventions. Usually these client generators offered output in hundreds of programming languages, so they didn't dedicate any time to making the developer experience great in any of them.</p> <p>I also discovered more than one client generator that would work by reading a file at runtime. This is cool engineering, but it is impractical to use. When you develop with these clients, the available functions and objects don't exist until the code is running, and you can't use an IDE's autocomplete feature.</p> <p>Clientele sets out to be as pythonic as possible. </p> <p>It uses modern tools, idiomatic conventions, and provide some helpful bonuses like Ruff auto-formatting.</p>"},{"location":"design/#easy-to-understand","title":"Easy to understand","text":"<p>Eventually a developer will need to do some debugging, and sometimes they'll need to do it in the generated client code.</p> <p>A lot of the other client generators make obscure or obtuse code that is hard to pick apart and debug.</p> <p>Now, there's a suggestion that developers shouldn't have to look at this, and that's fair. </p> <p>But the reality doesn't match that expectation. Personally, I like to know what generated code is doing. I want to trust that it will work, and that I can adapt around it if needed. An interesting quirk of any code generator is you can't always inspect the source when evaluating whether to use it. Any other tool - you'd just go to GitHub and have a read around, but you can't with code generators.</p> <p>So the code that is generated needs to be easy to understand.</p> <p>Clientele doesn't do any tricks, or magic, or anything complex. The generated code has documentation and is designed to be readable. It is only a small layer on top of already well established tools, such as HTTPX.</p> <p>In fact, I have some generated clients in our project repository so you can see what it looks like. We even have example tests for you to learn how to integrate with it.</p> <p>It is that way because I know you will need to inspect it in the future. I want you to know that this is a sane and sensible tool.</p>"},{"location":"design/#supporting-python-api-frameworks","title":"Supporting Python API Frameworks","text":"<p>The python ecosystem for API frameworks is very rich and mature. I love the options we have to build APIs with. I wanted to focus on supporting this ecosystem specifically because of how much I love the tooling, but also because it means I can focus on doing one thing great: client generation that specifically supports Python API frameworks.</p> <p>You'll see in the project documentation that we explain how to use common API frameworks like FastAPI, Django REST Framework and Django-ninja, and the project even has client and server examples to help demonstrate and prove it's usefulness.</p>"},{"location":"examples/","title":"\ud83e\ude84 Client example","text":"<p>Let's build an API Client using clientele.</p> <p>Our GitHub has a bunch of schemas that are proven to work with clientele, so let's use one of those!</p>"},{"location":"examples/#generate-the-client","title":"Generate the client","text":"<p>In your project's root directory:</p> <pre><code>clientele generate -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre> <p>Note</p> <p>The example above uses one of our test schemas, and will work if you copy/paste it!</p> <p>The <code>-u</code> parameter expects a URL, you can provide a path to a file with <code>-f</code> instead if you download the file.</p> <p>The <code>-o</code> parameter is the output directory of the generated client.</p> <p>Run it now and you will see this output:</p> <pre><code>my_client/\n    __init__.py\n    client.py\n    config.py\n    http.py\n    MANIFEST\n    schemas.py\n</code></pre> <p>Let's go over each file and talk about what it does.</p>"},{"location":"examples/#client","title":"Client","text":""},{"location":"examples/#get-functions","title":"GET functions","text":"<p>The <code>client.py</code> file provides all the API functions from the OpenAPI schema. Functions are a combination of the path and the HTTP method for those paths. So, a path with two HTTP methods will be turned into two python functions.</p> my_client/client.py<pre><code>from my_client import http, schemas\n\n\ndef simple_request_simple_request_get() -&gt; schemas.SimpleResponse:\n    \"\"\"Simple Request\"\"\"\n\n    response = http.get(url=\"/simple-request\")\n    return http.handle_response(simple_request_simple_request_get, response)\n\n...\n</code></pre> <p>We can see one of the functions here, <code>simple_request_simple_request_get</code>, is for a straight-forward HTTP GET request without any input arguments, and it returns a schema object.</p> <p>Here is how you might use it:</p> <pre><code>from my_client import client\n\nclient.simple_request_simple_request_get()\n&gt;&gt;&gt; SimpleResponse(name='Hello, clientele')\n</code></pre>"},{"location":"examples/#post-and-put-functions","title":"POST and PUT functions","text":"<p>Here's a more complex example for an HTTP POST method. It requires an input property called <code>data</code> that is an instance of a schema, and returns one of many potential responses. If the endpoint has URL or query parameters, they'll appear as input arguments to the function alongside the <code>data</code> argument.</p> <pre><code>def request_data_request_data_post(\n    data: schemas.RequestDataRequest\n) -&gt; schemas.RequestDataResponse | schemas.HTTPValidationError:\n    \"\"\"Request Data\"\"\"\n\n    response = http.post(url=\"/request-data\", data=data.model_dump())\n    return http.handle_response(request_data_request_data_post, response)\n</code></pre> <p>Here is how you might use it:</p> <pre><code>from my_client import client, schemas\n\ndata = schemas.RequestDataRequest(my_input=\"Hello, world\")\nresponse = client.request_data_request_data_post(data=data)\n&gt;&gt;&gt; RequestDataResponse(your_input='Hello, world')\n</code></pre> <p>Clientele also supports the major HTTP methods PUT and DELETE in the same way.</p>"},{"location":"examples/#url-and-query-parameters","title":"URL and Query parameters","text":"<p>If your endpoint takes path parameters (aka URL parameters) then clientele will turn them into parameters in the function:</p> <pre><code>from my_client import client\n\nclient.parameter_request_simple_request(your_input=\"gibberish\")\n&gt;&gt;&gt; ParameterResponse(your_input='gibberish')\n</code></pre> <p>Query parameters will also be generated the same way. See this example for a function that takes a required query parameter.</p> <p>Note that, optional parameters that are not passed will be omitted when the URL is generated by Clientele.</p>"},{"location":"examples/#handling-responses","title":"Handling responses","text":"<p>Because we're using Pydantic to manage the input data, we get a strongly-typed response object. This works beautifully with the new structural pattern matching feature in Python 3.10 and up:</p> <pre><code>response = client.request_data_request_data_post(data=data)\n\n# Handle responses elegantly\nmatch response:\n    case schemas.RequestDataResponse():\n        # Handle valid response\n        ...\n    case schemas.ValidationError():\n        # Handle validation error\n        ...\n</code></pre>"},{"location":"examples/#api-exceptions","title":"API Exceptions","text":"<p>Clientele keeps a mapping of the paths and their potential response codes. When it gets a response code that fits into the map, it generates the Pydantic object associated with it.</p> <p>If the HTTP response code is unexpected, it won't match a return type. In this case, the function will raise an <code>http.APIException</code>.</p> <pre><code>from my_client import client, http\ntry:\n    good_response = my_client.get_my_thing()\nexcept http.APIException as e:\n    # The API got a response code we didn't expect\n    print(e.response.status_code)\n</code></pre> <p>The <code>response</code> object is attached to this exception class for debugging.</p>"},{"location":"examples/#schemas","title":"Schemas","text":"<p>The <code>schemas.py</code> file has all the possible schemas - request, response, and even Enums - for the API. These are taken from OpenAPI's schema objects and turned into Python classes. They all subclass from Pydantic's <code>BaseModel</code>.</p> <p>Here are a few examples:</p> my_client/schemas.py<pre><code>import pydantic\nfrom enum import Enum\n\n\nclass ParameterResponse(pydantic.BaseModel):\n    your_input: str\n\nclass RequestDataRequest(pydantic.BaseModel):\n    my_input: str\n\nclass RequestDataResponse(pydantic.BaseModel):\n    my_input: str\n\n# Enums subclass str so they serialize to JSON nicely\nclass ExampleEnum(str, Enum):\n    ONE = \"ONE\"\n    TWO = \"TWO\"\n</code></pre>"},{"location":"examples/#configuration","title":"Configuration","text":"<p>See configuration.</p>"},{"location":"explore/","title":"Explorer Mode","text":"<p>The <code>explore</code> command launches an interactive REPL that lets you explore and test API operations without writing any code. It's perfect for API discovery, testing, and debugging.</p> <p></p>"},{"location":"explore/#usage-modes","title":"Usage Modes","text":""},{"location":"explore/#explore-an-existing-client","title":"Explore an Existing Client","text":"<p>If you've already generated a client, you can explore it directly:</p> <pre><code>clientele explore -c pokeapi_client/\n</code></pre>"},{"location":"explore/#explore-from-a-schema-file","title":"Explore from a Schema File","text":"<p>Generate a temporary client and explore it in one command:</p> <pre><code>clientele explore -f pokeapi_openapi.yml\n</code></pre> <p>Clientele will:</p> <ol> <li>Generate a client in a temporary directory from the schema</li> <li>Load it into the REPL</li> <li>Clean up the temporary files when you exit</li> </ol>"},{"location":"explore/#explore-from-a-schema-url","title":"Explore from a Schema URL","text":"<p>You can also explore directly from a URL:</p> <pre><code>clientele explore -u https://raw.githubusercontent.com/PokeAPI/pokeapi/master/openapi.yml\n</code></pre>"},{"location":"explore/#interactive-features","title":"Interactive Features","text":"<p>Once inside the REPL, you have access to several powerful features:</p>"},{"location":"explore/#tab-autocomplete","title":"Tab Autocomplete","text":"<p>Press TAB to autocomplete:</p> <pre><code>&gt;&gt;&gt; api_v2_pokemon_  &lt;TAB&gt;\napi_v2_pokemon_list                 pokemon_read\napi_v2_pokemon_encounter_list       pokemon_form_list\n</code></pre>"},{"location":"explore/#execute-operations","title":"Execute Operations","text":"<p>Make API calls using the available operations</p> <pre><code># Simple operation with no parameters\n&gt;&gt;&gt; api_v2_ability_list()\n\n# Operation with parameters\n&gt;&gt;&gt; api_v2_pokemon_list(limit=5, offset=0)\n\n# Operation with a specific ID\n&gt;&gt;&gt; api_v2_pokemon_retrieve(id=25)\n</code></pre> <p>The REPL will:</p> <ul> <li>Validate your arguments against the operation signature</li> <li>Execute the API call</li> <li>Display timing information</li> <li>Format the response with syntax highlighting</li> </ul>"},{"location":"explore/#inspect-schemas","title":"Inspect Schemas","text":"<p>You can inspect Pydantic schemas by simply typing their name (without parentheses):</p> <pre><code>&gt;&gt;&gt; UserResponse\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 UserResponse \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 User response model containing user information.                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nFields:\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Field   \u2503 Type   \u2503 Required \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 id      \u2502 int    \u2502 \u2713        \u2502\n\u2502 name    \u2502 str    \u2502 \u2713        \u2502\n\u2502 email   \u2502 str    \u2502 \u2713        \u2502\n\u2502 active  \u2502 bool   \u2502 \u2717        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTotal: 4 fields\n</code></pre> <p>This displays: - The schema's docstring (if it has one) - All fields with their types - Whether each field is required or optional</p> <p>You can also use the <code>/schemas</code> command to list all available schemas or view specific schema details:</p> <pre><code># List all schemas\n&gt;&gt;&gt; /schemas\n\n# View a specific schema\n&gt;&gt;&gt; /schemas UserResponse\n</code></pre>"},{"location":"explore/#special-commands","title":"Special Commands","text":"<p>Commands starting with <code>/</code> provide additional functionality:</p> <p><code>/list</code> or <code>/operations</code> - List all available operations in a table:</p> <pre><code>&gt;&gt;&gt; /list\nAvailable Operations\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Operation                    \u2502 Method \u2502 Description                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ability_list                 \u2502 GET    \u2502 List abilities              \u2502\n\u2502 ability_read                 \u2502 GET    \u2502 Get ability by ID or name   \u2502\n\u2502 pokemon_list                 \u2502 GET    \u2502 List pokemon                \u2502\n\u2502 pokemon_read                 \u2502 GET    \u2502 Get pokemon by ID or name   \u2502\n\u2502 berry_list                   \u2502 GET    \u2502 List berries                \u2502\n\u2502 move_list                    \u2502 GET    \u2502 List moves                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTotal: 6 operations\n</code></pre> <p><code>/help</code> - Show help message with usage information:</p> <pre><code>&gt;&gt;&gt; /help\n\nClientele Interactive API Explorer\n\nUsage:\n  \u2022 Type operation names and press TAB to autocomplete\n  \u2022 Execute operations with Python-like syntax: operation_name(param=value)\n  \u2022 Use UP/DOWN arrows to navigate command history\n\nSpecial Commands:\n  /list, /operations  - List all available operations\n  /help                  - Show this help message\n  /exit, /quit         - Exit the REPL\n\nExamples:\n  get_users()                           - Execute operation without parameters\n  get_user(user_id=\"123\")               - Execute with parameters\n  create_user(data={\"name\": \"John\"})   - Pass complex data\n</code></pre> <p><code>/exit</code> or <code>/quit</code> - Exit the REPL (you can also use Ctrl+D):</p> <pre><code>&gt;&gt;&gt; /exit\nGoodbye! \ud83d\udc4b\n</code></pre>"},{"location":"explore/#command-history","title":"Command History","text":"<p>Navigate your command history with UP and DOWN arrow keys. Your history is saved to <code>~/.clientele_history</code> and persists between sessions.</p>"},{"location":"explore/#config","title":"Config","text":"<p>You can inspect and modify the config during a CLI session:</p> <pre><code># Show configuration values\n&gt;&gt;&gt; /config\nCurrent Configuration              \n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Setting      \u2503 Value              \u2503 Source    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 base_url     \u2502 https://pokeapi.co \u2502 config.py \u2502\n\u2502 bearer_token \u2502 token              \u2502 config.py \u2502\n\u2502 user_key     \u2502 user               \u2502 config.py \u2502\n\u2502 pass_key     \u2502 password           \u2502 config.py \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDebug Mode: OFF\n\n# Update a config value\n&gt;&gt;&gt; /config set base_url mynewurl.com\n\u2713 Set base_url = mynewurl.com\nThis override applies only to the current REPL session\n</code></pre> <p>Config changes only persist during the CLI session.</p>"},{"location":"explore/#debug","title":"Debug","text":"<p>You can enable debug mode to print useful information when using explore:</p> <pre><code># Show debug state\n&gt;&gt;&gt; /debug\nDebug Mode: OFF\n\nUse '/debug on' or '/debug off' to toggle debug mode\n# Update debug state\n&gt;&gt;&gt; /debug on\n\u2713 Debug mode enabled\nHTTP requests and responses will be logged\n</code></pre>"},{"location":"explore/#response-formatting","title":"Response Formatting","text":"<p>The explore command automatically formats responses for readability:</p> <p>JSON Responses - Syntax-highlighted with proper indentation:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre> <p>Timing Information - Every request shows execution time:</p> <pre><code>\u2713 Success in 0.45s\n</code></pre> <p>Error Handling - Errors are displayed in a clear, formatted panel:</p> <pre><code>\u2717 Error in 0.12s\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 ValueError: Missing required parameter: user_id     \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"explore/#compatibility","title":"Compatibility","text":"<p>The explore command works with:</p> <ul> <li>\u2705 Standard function-based clients (<code>generate</code>)</li> <li>\u2705 Class-based clients (<code>generate-class</code>)</li> <li>\u2705 Both sync and async clients</li> <li>\u2705 Clients with authentication configured</li> <li>\u2705 All OpenAPI 3.0+ schemas</li> </ul>"},{"location":"explore/#limitations","title":"Limitations","text":"<ul> <li>The explore command is interactive only - not suitable for CI/CD or automated testing</li> <li>Operations are executed against the actual API - be careful with destructive operations</li> <li>For automated testing, use the generated client directly in your test suite</li> </ul>"},{"location":"framework-django-ninja/","title":"Using Clientele with Django Ninja","text":"<p>This guide shows you how to generate a Python client for a Django Ninja API using Clientele.</p> <p>\ud83d\udca1 Working Example: See a real Django Ninja application with code examples from this guide in <code>server_examples/django-ninja/</code></p>"},{"location":"framework-django-ninja/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Django application with Django Ninja installed</li> <li>Django Ninja automatically generates OpenAPI schemas (enabled by default)</li> </ul>"},{"location":"framework-django-ninja/#step-1-get-your-openapi-schema","title":"Step 1: Get Your OpenAPI Schema","text":"<p>Django Ninja automatically generates an OpenAPI schema for your API. By default, it's available at:</p> <pre><code>http://your-api-domain/api/openapi.json\n</code></pre> <p>For local development:</p> <pre><code>http://localhost:8000/api/openapi.json\n</code></pre> <p>The exact path depends on how you've mounted your Django Ninja API in your URLs.</p>"},{"location":"framework-django-ninja/#example-django-ninja-setup","title":"Example Django Ninja Setup","text":"<pre><code># urls.py\nfrom django.urls import path\nfrom ninja import NinjaAPI\n\napi = NinjaAPI()\n\n# Your endpoints here...\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>With this setup, the OpenAPI schema is at: <code>http://localhost:8000/api/openapi.json</code></p>"},{"location":"framework-django-ninja/#downloading-the-schema","title":"Downloading the Schema","text":"<p>Option A: Use the URL directly:</p> <pre><code>clientele generate -u http://localhost:8000/api/openapi.json -o my_client/\n</code></pre> <p>Option B: Download the schema file:</p> <pre><code>curl http://localhost:8000/api/openapi.json &gt; openapi.json\nclientele generate -f openapi.json -o my_client/\n</code></pre>"},{"location":"framework-django-ninja/#step-2-generate-the-client","title":"Step 2: Generate the Client","text":""},{"location":"framework-django-ninja/#basic-generation","title":"Basic Generation","text":"<p>Generate a function-based client:</p> <pre><code>clientele generate -u http://localhost:8000/api/openapi.json -o my_client/\n</code></pre>"},{"location":"framework-django-ninja/#class-based-client","title":"Class-Based Client","text":"<p>For an object-oriented approach:</p> <pre><code>clientele generate-class -u http://localhost:8000/api/openapi.json -o my_client/\n</code></pre>"},{"location":"framework-django-ninja/#async-client","title":"Async Client","text":"<p>Django Ninja supports both sync and async views. Generate an async client if needed:</p> <pre><code>clientele generate -u http://localhost:8000/api/openapi.json -o my_client/ --asyncio t\n</code></pre>"},{"location":"framework-django-ninja/#step-3-use-the-generated-client","title":"Step 3: Use the Generated Client","text":""},{"location":"framework-django-ninja/#function-based-client-example","title":"Function-Based Client Example","text":"<pre><code>from my_client import client, schemas\n\n# Call a GET endpoint\nresponse = client.list_users_api_users_get()\n\n# Call a POST endpoint with data\nuser_data = schemas.UserIn(\n    username=\"alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_api_users_post(data=user_data)\n\n# Handle responses\nmatch response:\n    case schemas.UserOut():\n        print(f\"User created: {response.username}\")\n    case schemas.Error():\n        print(f\"Error: {response.message}\")\n</code></pre>"},{"location":"framework-django-ninja/#async-client-example","title":"Async Client Example","text":"<p>If your Django Ninja views are async:</p> <pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.UserIn(\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_api_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"framework-django-ninja/#working-with-operation_id","title":"Working with operation_id","text":"<p>You can customize operation IDs in Django Ninja for cleaner function names.</p>"},{"location":"framework-django-ninja/#default-operation-id","title":"Default Operation ID","text":"<p>By default, Django Ninja generates operation IDs from the function name and path:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n\n@api.get(\"/users\")\ndef list_users(request):\n    return []\n</code></pre> <p>This might generate: <code>list_users_api_users_get</code></p>"},{"location":"framework-django-ninja/#custom-operation_id","title":"Custom operation_id","text":"<p>Use the <code>operation_id</code> parameter for cleaner names:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n\n@api.get(\"/users\", operation_id=\"list_users\")\ndef get_users(request):\n    return []\n\n@api.post(\"/users\", operation_id=\"create_user\")\ndef create_user(request, user: UserIn):\n    return user\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> - clean and simple!</li> <li><code>client.create_user()</code> - exactly what you'd expect</li> </ul>"},{"location":"framework-django-ninja/#schemas-and-pydantic","title":"Schemas and Pydantic","text":"<p>Django Ninja uses Pydantic for schemas, which aligns perfectly with Clientele!</p>"},{"location":"framework-django-ninja/#django-ninja-schema","title":"Django Ninja Schema","text":"<pre><code>from ninja import Schema\n\nclass UserIn(Schema):\n    username: str\n    email: str\n    age: int\n\nclass UserOut(Schema):\n    id: int\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n</code></pre>"},{"location":"framework-django-ninja/#generated-client-schemas","title":"Generated Client Schemas","text":"<p>Clientele converts these to Pydantic models in the client:</p> <pre><code># In my_client/schemas.py\nimport pydantic\nfrom datetime import datetime\n\nclass UserIn(pydantic.BaseModel):\n    username: str\n    email: str\n    age: int\n\nclass UserOut(pydantic.BaseModel):\n    id: int\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n</code></pre>"},{"location":"framework-django-ninja/#usage","title":"Usage","text":"<pre><code># Create request data\nuser_data = schemas.UserIn(\n    username=\"alice\",\n    email=\"alice@example.com\",\n    age=30\n)\n\n# Get typed response\nresponse = client.create_user(data=user_data)\n# response is typed as schemas.UserOut\nprint(response.id)  # Full IDE autocomplete!\n</code></pre>"},{"location":"framework-django-ninja/#authentication","title":"Authentication","text":""},{"location":"framework-django-ninja/#http-bearer-authentication","title":"HTTP Bearer Authentication","text":"<p>Django Ninja supports various authentication methods. For token/bearer authentication:</p> <pre><code># Django Ninja API\nfrom ninja.security import HttpBearer\n\nclass AuthBearer(HttpBearer):\n    def authenticate(self, request, token):\n        # Validate token\n        return token\n\napi = NinjaAPI()\n\n@api.get(\"/protected\", auth=AuthBearer())\ndef protected_endpoint(request):\n    return {\"message\": \"authenticated\"}\n</code></pre> <p>Configure the client's <code>config.py</code>:</p> <pre><code>def get_bearer_token() -&gt; str:\n    \"\"\"\n    Provide your authentication token.\n    Does not require the \"Bearer\" prefix.\n    \"\"\"\n    from os import environ\n    return environ.get(\"API_TOKEN\", \"your-token-here\")\n</code></pre>"},{"location":"framework-django-ninja/#api-key-authentication","title":"API Key Authentication","text":"<p>For API key authentication:</p> <pre><code># Django Ninja API\nfrom ninja.security import APIKeyHeader\n\nclass ApiKey(APIKeyHeader):\n    param_name = \"X-API-Key\"\n\n    def authenticate(self, request, key):\n        # Validate key\n        return key\n\n@api.get(\"/protected\", auth=ApiKey())\ndef protected_endpoint(request):\n    return {\"message\": \"authenticated\"}\n</code></pre> <p>Configure additional headers in <code>config.py</code>:</p> <pre><code>def additional_headers() -&gt; dict:\n    \"\"\"\n    Add custom headers to all requests.\n    \"\"\"\n    from os import environ\n    return {\n        \"X-API-Key\": environ.get(\"API_KEY\", \"your-api-key\")\n    }\n</code></pre>"},{"location":"framework-django-ninja/#regenerating-the-client","title":"Regenerating the Client","text":"<p>When you update your Django Ninja endpoints, regenerate the client:</p> <pre><code>clientele generate -u http://localhost:8000/api/openapi.json -o my_client/ --regen t\n</code></pre>"},{"location":"framework-django-ninja/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Update your Django Ninja endpoints/schemas</li> <li>Restart your Django development server</li> <li>Regenerate the client with <code>--regen t</code></li> <li>Review changes with <code>git diff</code></li> <li>Run tests</li> <li>Commit the updated client</li> </ol>"},{"location":"framework-django-ninja/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>Django Ninja's path and query parameters work seamlessly:</p>"},{"location":"framework-django-ninja/#django-ninja-endpoint","title":"Django Ninja Endpoint","text":"<pre><code>from ninja import Query\n\n@api.get(\"/users/{user_id}\")\ndef get_user(request, user_id: int, include_posts: bool = Query(False)):\n    return {\n        \"user_id\": user_id,\n        \"include_posts\": include_posts\n    }\n</code></pre>"},{"location":"framework-django-ninja/#generated-client-usage","title":"Generated Client Usage","text":"<pre><code># Required path parameter, optional query parameter\nresponse = client.get_user_api_users_user_id_get(\n    user_id=123,\n    include_posts=True\n)\n</code></pre>"},{"location":"framework-django-ninja/#response-models","title":"Response Models","text":"<p>Django Ninja's response models become typed schemas in the client:</p>"},{"location":"framework-django-ninja/#django-ninja-endpoint_1","title":"Django Ninja Endpoint","text":"<pre><code>class UserOut(Schema):\n    id: int\n    username: str\n    email: str\n\n@api.get(\"/users/{user_id}\", response=UserOut)\ndef get_user(request, user_id: int):\n    return UserOut(\n        id=user_id,\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n</code></pre>"},{"location":"framework-django-ninja/#generated-client-usage_1","title":"Generated Client Usage","text":"<pre><code>response = client.get_user_api_users_user_id_get(user_id=123)\n# response is typed as schemas.UserOut\nassert isinstance(response, schemas.UserOut)\nprint(response.username)  # IDE knows the type!\n</code></pre>"},{"location":"framework-django-ninja/#multiple-response-types","title":"Multiple Response Types","text":"<p>Django Ninja supports multiple response types, which Clientele handles:</p>"},{"location":"framework-django-ninja/#django-ninja-endpoint_2","title":"Django Ninja Endpoint","text":"<pre><code>@api.post(\"/users\", response={201: UserOut, 400: Error})\ndef create_user(request, user: UserIn):\n    # ...\n    return 201, user_data\n</code></pre>"},{"location":"framework-django-ninja/#generated-client-usage_2","title":"Generated Client Usage","text":"<pre><code>response = client.create_user_api_users_post(data=user_data)\n\n# Use pattern matching for different responses\nmatch response:\n    case schemas.UserOut():\n        print(f\"Success: {response.username}\")\n    case schemas.Error():\n        print(f\"Error: {response.message}\")\n</code></pre>"},{"location":"framework-django-ninja/#pagination","title":"Pagination","text":"<p>If you implement pagination in Django Ninja:</p>"},{"location":"framework-django-ninja/#django-ninja-with-pagination","title":"Django Ninja with Pagination","text":"<pre><code>from typing import List\n\nclass PaginatedResponse(Schema):\n    count: int\n    next: str | None\n    previous: str | None\n    results: List[UserOut]\n\n@api.get(\"/users\", response=PaginatedResponse)\ndef list_users(request, page: int = 1, page_size: int = 20):\n    # Pagination logic...\n    return {\n        \"count\": total_count,\n        \"next\": next_url,\n        \"previous\": prev_url,\n        \"results\": users\n    }\n</code></pre>"},{"location":"framework-django-ninja/#client-usage","title":"Client Usage","text":"<pre><code>response = client.list_users_api_users_get(page=2, page_size=50)\nprint(f\"Total users: {response.count}\")\nfor user in response.results:\n    print(user.username)\n</code></pre>"},{"location":"framework-django-ninja/#async-endpoints","title":"Async Endpoints","text":"<p>Django Ninja supports async views. If using async:</p>"},{"location":"framework-django-ninja/#django-ninja-async-endpoint","title":"Django Ninja Async Endpoint","text":"<pre><code>@api.get(\"/users/{user_id}\")\nasync def get_user(request, user_id: int):\n    # Async database query...\n    user = await User.objects.aget(id=user_id)\n    return user\n</code></pre>"},{"location":"framework-django-ninja/#generate-async-client","title":"Generate Async Client","text":"<pre><code>clientele generate -u http://localhost:8000/api/openapi.json -o my_client/ --asyncio t\n</code></pre>"},{"location":"framework-django-ninja/#client-usage_1","title":"Client Usage","text":"<pre><code>response = await client.get_user_api_users_user_id_get(user_id=123)\n</code></pre>"},{"location":"framework-django-ninja/#known-limitations","title":"Known Limitations","text":""},{"location":"framework-django-ninja/#openapi-version","title":"OpenAPI Version","text":"<ul> <li>Supported: Django Ninja generates OpenAPI 3.0.x schemas that work perfectly with Clientele</li> <li>Works Well: Most Django Ninja features are well-supported</li> <li>Not Supported: OpenAPI 2.0 schemas (Django Ninja uses 3.0+ by default)</li> </ul>"},{"location":"framework-django-ninja/#file-uploads","title":"File Uploads","text":"<p>File upload endpoints may require manual customization in the generated client.</p>"},{"location":"framework-django-ninja/#complex-schema-features","title":"Complex Schema Features","text":"<ul> <li>Most Pydantic features work seamlessly since Django Ninja uses Pydantic</li> <li>Nested schemas are fully supported</li> <li><code>oneOf</code>, <code>anyOf</code>, and nullable fields work correctly</li> </ul>"},{"location":"framework-django-ninja/#best-practices","title":"Best Practices","text":"<ol> <li>Use custom <code>operation_id</code> for readable function names</li> <li>Keep schemas separate from view logic for clarity</li> <li>Regenerate regularly when the API changes</li> <li>Use meaningful schema names (UserIn, UserOut, etc.)</li> <li>Version your client in git to track changes</li> <li>Document your endpoints - Django Ninja includes docstrings in the schema</li> </ol>"},{"location":"framework-django-ninja/#django-ninja-features-in-generated-clients","title":"Django Ninja Features in Generated Clients","text":""},{"location":"framework-django-ninja/#router-support","title":"Router Support","text":"<p>Django Ninja routers work perfectly:</p> <pre><code>from ninja import Router\n\nusers_router = Router()\n\n@users_router.get(\"/\", operation_id=\"list_users\")\ndef list_users(request):\n    return []\n\n@users_router.post(\"/\", operation_id=\"create_user\")\ndef create_user(request, user: UserIn):\n    return user\n\napi.add_router(\"/users\", users_router)\n</code></pre> <p>All endpoints are included in the generated client.</p>"},{"location":"framework-django-ninja/#versioning","title":"Versioning","text":"<p>Django Ninja's versioning is reflected in the schema:</p> <pre><code>api_v1 = NinjaAPI(version=\"1.0.0\")\napi_v2 = NinjaAPI(version=\"2.0.0\")\n</code></pre> <p>Generate separate clients for each version if needed.</p>"},{"location":"framework-django-ninja/#next-steps","title":"Next Steps","text":"<ul> <li>Django Ninja documentation</li> <li>Learn about regeneration workflow</li> <li>Set up testing with respx</li> <li>Understand client structure</li> </ul>"},{"location":"framework-drf/","title":"Using Clientele with Django REST Framework","text":"<p>This guide shows you how to generate a Python client for a Django REST Framework (DRF) API using Clientele and drf-spectacular.</p> <p>\ud83d\udca1 Working Example: See a real Django REST Framework application with code examples from this guide in <code>server_examples/django-rest-framework/</code></p>"},{"location":"framework-drf/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Django REST Framework application</li> <li>drf-spectacular installed and configured</li> </ul>"},{"location":"framework-drf/#why-drf-spectacular","title":"Why drf-spectacular?","text":"<p>Django REST Framework doesn't include built-in OpenAPI schema generation. drf-spectacular is the recommended solution for generating OpenAPI 3.0 schemas from DRF applications. It's actively maintained and provides excellent OpenAPI support.</p>"},{"location":"framework-drf/#step-1-install-and-configure-drf-spectacular","title":"Step 1: Install and Configure drf-spectacular","text":"<p>If you haven't already set up drf-spectacular, follow these steps:</p>"},{"location":"framework-drf/#install-drf-spectacular","title":"Install drf-spectacular","text":"<pre><code>pip install drf-spectacular\n</code></pre>"},{"location":"framework-drf/#configure-django-settings","title":"Configure Django Settings","text":"<p>Add to your <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    'rest_framework',\n    'drf_spectacular',\n    # ...\n]\n\nREST_FRAMEWORK = {\n    # ...\n    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',\n}\n\nSPECTACULAR_SETTINGS = {\n    'TITLE': 'Your API',\n    'DESCRIPTION': 'Your API description',\n    'VERSION': '1.0.0',\n    'SERVE_INCLUDE_SCHEMA': False,\n}\n</code></pre>"},{"location":"framework-drf/#add-url-patterns","title":"Add URL Patterns","text":"<p>In your <code>urls.py</code>:</p> <pre><code>from drf_spectacular.views import SpectacularAPIView\nfrom django.urls import path\n\nurlpatterns = [\n    # ...\n    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),\n]\n</code></pre>"},{"location":"framework-drf/#step-2-get-your-openapi-schema","title":"Step 2: Get Your OpenAPI Schema","text":"<p>After configuring drf-spectacular, your OpenAPI schema is available at:</p> <pre><code>http://your-api-domain/api/schema/\n</code></pre> <p>For local development:</p> <pre><code>http://localhost:8000/api/schema/\n</code></pre>"},{"location":"framework-drf/#download-the-schema","title":"Download the Schema","text":"<p>Option A: Use the URL directly:</p> <pre><code>clientele generate -u http://localhost:8000/api/schema/ -o my_client/\n</code></pre> <p>Option B: Download the schema file:</p> <pre><code>curl http://localhost:8000/api/schema/ &gt; openapi.json\nclientele generate -f openapi.json -o my_client/\n</code></pre> <p>Option C: Generate schema file with Django management command:</p> <pre><code>python manage.py spectacular --file openapi.json\nclientele generate -f openapi.json -o my_client/\n</code></pre>"},{"location":"framework-drf/#step-3-generate-the-client","title":"Step 3: Generate the Client","text":""},{"location":"framework-drf/#basic-generation","title":"Basic Generation","text":"<p>Generate a function-based client:</p> <pre><code>clientele generate -u http://localhost:8000/api/schema/ -o my_client/\n</code></pre>"},{"location":"framework-drf/#class-based-client","title":"Class-Based Client","text":"<p>For an object-oriented approach:</p> <pre><code>clientele generate-class -u http://localhost:8000/api/schema/ -o my_client/\n</code></pre>"},{"location":"framework-drf/#async-client","title":"Async Client","text":"<p>Generate an async client (note: DRF itself is synchronous, but the client can be async):</p> <pre><code>clientele generate -u http://localhost:8000/api/schema/ -o my_client/ --asyncio t\n</code></pre>"},{"location":"framework-drf/#step-4-use-the-generated-client","title":"Step 4: Use the Generated Client","text":""},{"location":"framework-drf/#function-based-client-example","title":"Function-Based Client Example","text":"<pre><code>from my_client import client, schemas\n\n# List resources\nresponse = client.list_users_api_users_get()\n\n# Create a resource\nuser_data = schemas.UserRequest(\n    username=\"alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_api_users_post(data=user_data)\n\n# Handle responses\nmatch response:\n    case schemas.User():\n        print(f\"User created: {response.username}\")\n    case schemas.ValidationError():\n        print(f\"Validation failed: {response.detail}\")\n</code></pre>"},{"location":"framework-drf/#improving-operationid-in-drf","title":"Improving operationId in DRF","text":"<p>By default, drf-spectacular generates operation IDs from view names and paths. You can customize them for cleaner function names.</p>"},{"location":"framework-drf/#using-extend_schema-decorator","title":"Using extend_schema Decorator","text":"<pre><code>from drf_spectacular.utils import extend_schema\nfrom rest_framework import viewsets\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n    @extend_schema(operation_id=\"list_users\")\n    def list(self, request):\n        return super().list(request)\n\n    @extend_schema(operation_id=\"create_user\")\n    def create(self, request):\n        return super().create(request)\n\n    @extend_schema(operation_id=\"get_user\")\n    def retrieve(self, request, pk=None):\n        return super().retrieve(request, pk)\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of a generic operation ID</li> <li><code>client.create_user()</code> instead of verbose auto-generated names</li> <li><code>client.get_user()</code> for clean, readable function names</li> </ul>"},{"location":"framework-drf/#for-function-based-views","title":"For Function-Based Views","text":"<pre><code>from drf_spectacular.utils import extend_schema\nfrom rest_framework.decorators import api_view\n\n@extend_schema(\n    operation_id=\"get_user_stats\",\n    responses={200: UserStatsSerializer}\n)\n@api_view(['GET'])\ndef user_stats(request, user_id):\n    # ...\n    return Response(data)\n</code></pre>"},{"location":"framework-drf/#authentication","title":"Authentication","text":""},{"location":"framework-drf/#token-authentication","title":"Token Authentication","text":"<p>If your DRF API uses token authentication:</p> <pre><code># Django settings.py\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'rest_framework.authtoken.models.TokenAuthentication',\n    ],\n}\n</code></pre> <p>Configure in the client's <code>config.py</code>:</p> <pre><code>def get_bearer_token() -&gt; str:\n    \"\"\"\n    Provide your DRF auth token.\n    \"\"\"\n    from os import environ\n    return environ.get(\"DRF_AUTH_TOKEN\", \"your-token-here\")\n</code></pre>"},{"location":"framework-drf/#session-authentication","title":"Session Authentication","text":"<p>For session-based auth, you may need to handle cookie management manually in the client's <code>config.py</code> using additional headers.</p>"},{"location":"framework-drf/#jwt-authentication","title":"JWT Authentication","text":"<p>If using JWT (e.g., with djangorestframework-simplejwt):</p> <pre><code>def get_bearer_token() -&gt; str:\n    \"\"\"\n    Provide your JWT access token.\n    \"\"\"\n    from os import environ\n    return environ.get(\"JWT_ACCESS_TOKEN\", \"your-jwt-token\")\n</code></pre>"},{"location":"framework-drf/#regenerating-the-client","title":"Regenerating the Client","text":"<p>When your DRF API changes, regenerate the client:</p> <pre><code>clientele generate -u http://localhost:8000/api/schema/ -o my_client/ --regen t\n</code></pre>"},{"location":"framework-drf/#recommended-workflow","title":"Recommended Workflow","text":"<ol> <li>Update your DRF serializers/views</li> <li>Run migrations if needed</li> <li>Regenerate the schema: <code>python manage.py spectacular --file openapi.json</code></li> <li>Regenerate the client: <code>clientele generate -f openapi.json -o my_client/ --regen t</code></li> <li>Review changes: <code>git diff</code></li> <li>Test the updated client</li> <li>Commit changes</li> </ol>"},{"location":"framework-drf/#serializers-and-schemas","title":"Serializers and Schemas","text":"<p>DRF serializers become Pydantic models in the generated client:</p>"},{"location":"framework-drf/#drf-serializer","title":"DRF Serializer","text":"<pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'is_active']\n</code></pre>"},{"location":"framework-drf/#generated-pydantic-schema","title":"Generated Pydantic Schema","text":"<pre><code># In my_client/schemas.py\nclass User(pydantic.BaseModel):\n    id: int\n    username: str\n    email: str\n    is_active: bool\n</code></pre>"},{"location":"framework-drf/#usage","title":"Usage","text":"<pre><code># The client returns properly typed responses\nresponse = client.get_user_api_users_id_get(id=123)\n# response is typed as schemas.User\nassert isinstance(response, schemas.User)\nprint(response.username)  # Full IDE support\n</code></pre>"},{"location":"framework-drf/#viewsets-and-routers","title":"ViewSets and Routers","text":"<p>DRF ViewSets with routers automatically generate appropriate endpoints:</p>"},{"location":"framework-drf/#drf-viewset","title":"DRF ViewSet","text":"<pre><code>from rest_framework import viewsets\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n</code></pre>"},{"location":"framework-drf/#router-configuration","title":"Router Configuration","text":"<pre><code>from rest_framework.routers import DefaultRouter\n\nrouter = DefaultRouter()\nrouter.register(r'users', UserViewSet)\n</code></pre> <p>This generates endpoints like:</p> <ul> <li><code>GET /users/</code> \u2192 <code>client.list_users()</code></li> <li><code>POST /users/</code> \u2192 <code>client.create_user(data=...)</code></li> <li><code>GET /users/{id}/</code> \u2192 <code>client.get_user(id=...)</code></li> <li><code>PUT /users/{id}/</code> \u2192 <code>client.update_user(id=..., data=...)</code></li> <li><code>DELETE /users/{id}/</code> \u2192 <code>client.delete_user(id=...)</code></li> </ul>"},{"location":"framework-drf/#pagination","title":"Pagination","text":"<p>DRF pagination is reflected in the schema and client:</p>"},{"location":"framework-drf/#drf-pagination-setup","title":"DRF Pagination Setup","text":"<pre><code>REST_FRAMEWORK = {\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',\n    'PAGE_SIZE': 100\n}\n</code></pre>"},{"location":"framework-drf/#generated-schema","title":"Generated Schema","text":"<p>The response will include pagination fields:</p> <pre><code>response = client.list_users_api_users_get(page=2)\n# Response has structure like:\n# {\n#   \"count\": 250,\n#   \"next\": \"http://...\",\n#   \"previous\": \"http://...\",\n#   \"results\": [...]\n# }\n</code></pre>"},{"location":"framework-drf/#filtering-and-query-parameters","title":"Filtering and Query Parameters","text":"<p>Query parameters are automatically converted to function arguments:</p>"},{"location":"framework-drf/#drf-view-with-filtering","title":"DRF View with Filtering","text":"<pre><code>class UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filterset_fields = ['is_active', 'username']\n</code></pre>"},{"location":"framework-drf/#client-usage","title":"Client Usage","text":"<pre><code># Query parameters become function arguments\nresponse = client.list_users_api_users_get(\n    is_active=True,\n    username=\"alice\"\n)\n</code></pre>"},{"location":"framework-drf/#known-limitations","title":"Known Limitations","text":""},{"location":"framework-drf/#openapi-version","title":"OpenAPI Version","text":"<ul> <li>Supported: drf-spectacular generates OpenAPI 3.0 schemas that work perfectly with Clientele</li> <li>Partial Support: Some complex DRF features may need schema customization</li> <li>Not Supported: DRF's older CoreAPI schema format is not supported - use drf-spectacular</li> </ul>"},{"location":"framework-drf/#complex-serializers","title":"Complex Serializers","text":"<ul> <li>Most DRF serializer features work out of the box</li> <li>Nested serializers are fully supported</li> <li>SerializerMethodField may require manual schema hints with <code>@extend_schema_field</code></li> </ul>"},{"location":"framework-drf/#file-uploads","title":"File Uploads","text":"<p>File upload endpoints may require manual customization in the generated client.</p>"},{"location":"framework-drf/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>@extend_schema</code> to provide clear operation IDs and response types</li> <li>Document your serializers - drf-spectacular uses docstrings in schema generation</li> <li>Regenerate regularly to keep client in sync with API changes</li> <li>Use <code>extend_schema_field</code> for SerializerMethodFields to ensure proper typing</li> <li>Version your generated client in git</li> </ol>"},{"location":"framework-drf/#helpful-drf-spectacular-features","title":"Helpful drf-spectacular Features","text":""},{"location":"framework-drf/#documenting-responses","title":"Documenting Responses","text":"<pre><code>from drf_spectacular.utils import extend_schema, OpenApiResponse\n\n@extend_schema(\n    responses={\n        200: UserSerializer,\n        400: OpenApiResponse(description='Invalid request'),\n        404: OpenApiResponse(description='User not found'),\n    }\n)\n@api_view(['GET'])\ndef get_user(request, user_id):\n    # ...\n</code></pre>"},{"location":"framework-drf/#documenting-request-bodies","title":"Documenting Request Bodies","text":"<pre><code>@extend_schema(\n    request=UserSerializer,\n    responses={201: UserSerializer}\n)\n@api_view(['POST'])\ndef create_user(request):\n    # ...\n</code></pre>"},{"location":"framework-drf/#next-steps","title":"Next Steps","text":"<ul> <li>drf-spectacular documentation</li> <li>Learn about regeneration workflow</li> <li>Set up testing with respx</li> <li>Understand client structure</li> </ul>"},{"location":"framework-fastapi/","title":"Using Clientele with FastAPI","text":"<p>This guide shows you how to generate a Python client for a FastAPI application using Clientele.</p> <p>\ud83d\udca1 Working Example: See a real FastAPI application with code examples from this guide in <code>server_examples/fastapi/</code></p>"},{"location":"framework-fastapi/#prerequisites","title":"Prerequisites","text":"<ul> <li>A FastAPI application with API endpoints</li> <li>FastAPI's automatic OpenAPI schema generation enabled (enabled by default)</li> </ul>"},{"location":"framework-fastapi/#step-1-get-your-openapi-schema","title":"Step 1: Get Your OpenAPI Schema","text":"<p>FastAPI automatically generates an OpenAPI schema for your API. You can access it at:</p> <pre><code>http://your-api-domain/openapi.json\n</code></pre> <p>For example, if your FastAPI app is running locally on port 8000:</p> <pre><code>http://localhost:8000/openapi.json\n</code></pre>"},{"location":"framework-fastapi/#downloading-the-schema","title":"Downloading the Schema","text":"<p>You can either:</p> <p>Option A: Use the URL directly (if the API is accessible):</p> <pre><code>clientele generate -u http://localhost:8000/openapi.json -o my_client/\n</code></pre> <p>Option B: Download the schema file first:</p> <pre><code>curl http://localhost:8000/openapi.json &gt; openapi.json\nclientele generate -f openapi.json -o my_client/\n</code></pre>"},{"location":"framework-fastapi/#step-2-generate-the-client","title":"Step 2: Generate the Client","text":""},{"location":"framework-fastapi/#basic-generation","title":"Basic Generation","text":"<p>Generate a function-based client (recommended for most use cases):</p> <pre><code>clientele generate -u http://localhost:8000/openapi.json -o my_client/\n</code></pre>"},{"location":"framework-fastapi/#class-based-client","title":"Class-Based Client","text":"<p>If you prefer an object-oriented approach:</p> <pre><code>clientele generate-class -u http://localhost:8000/openapi.json -o my_client/\n</code></pre>"},{"location":"framework-fastapi/#async-client","title":"Async Client","text":"<p>If your FastAPI app uses async endpoints and you want an async client:</p> <pre><code>clientele generate -u http://localhost:8000/openapi.json -o my_client/ --asyncio t\n</code></pre>"},{"location":"framework-fastapi/#step-3-use-the-generated-client","title":"Step 3: Use the Generated Client","text":""},{"location":"framework-fastapi/#function-based-client-example","title":"Function-Based Client Example","text":"<pre><code>from my_client import client, schemas\n\n# Call a simple GET endpoint\nresponse = client.get_users_users_get()\n\n# Call a POST endpoint with data\nuser_data = schemas.CreateUserRequest(\n    name=\"Alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_users_post(data=user_data)\n\n# Handle different response types\nmatch response:\n    case schemas.UserResponse():\n        print(f\"User created: {response.name}\")\n    case schemas.HTTPValidationError():\n        print(f\"Validation error: {response.detail}\")\n</code></pre>"},{"location":"framework-fastapi/#async-client-example","title":"Async Client Example","text":"<pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.CreateUserRequest(\n        name=\"Alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"framework-fastapi/#working-with-operationid","title":"Working with operationId","text":"<p>FastAPI generates <code>operationId</code> values for each endpoint, which Clientele uses to create function names.</p>"},{"location":"framework-fastapi/#default-operationid-generation","title":"Default operationId Generation","text":"<p>By default, FastAPI creates operation IDs like: <code>{function_name}_{path}_{method}</code></p> <p>For example:</p> <ul> <li>Function <code>get_users()</code> at path <code>/users</code> with GET \u2192 <code>get_users_users_get</code></li> <li>Function <code>create_user()</code> at path <code>/users</code> with POST \u2192 <code>create_user_users_post</code></li> </ul>"},{"location":"framework-fastapi/#custom-operationid","title":"Custom operationId","text":"<p>You can customize the operation ID in FastAPI to get cleaner function names:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/users\", operation_id=\"list_users\")\ndef get_users():\n    return []\n\n@app.post(\"/users\", operation_id=\"create_user\")\ndef create_user(user: UserCreate):\n    return user\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of <code>client.get_users_users_get()</code></li> <li><code>client.create_user()</code> instead of <code>client.create_user_users_post()</code></li> </ul>"},{"location":"framework-fastapi/#authentication","title":"Authentication","text":""},{"location":"framework-fastapi/#http-bearer-authentication","title":"HTTP Bearer Authentication","text":"<p>If your FastAPI app uses HTTP Bearer authentication:</p> <pre><code># FastAPI app\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\n\n@app.get(\"/protected\")\ndef protected_route(token: str = Depends(security)):\n    return {\"message\": \"authenticated\"}\n</code></pre> <p>Configure the client's <code>config.py</code>:</p> <pre><code>def get_bearer_token() -&gt; str:\n    \"\"\"\n    Provide your authentication token here.\n    Does not require the \"Bearer\" prefix.\n    \"\"\"\n    from os import environ\n    return environ.get(\"API_TOKEN\", \"your-token-here\")\n</code></pre>"},{"location":"framework-fastapi/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<p>For HTTP Basic auth in FastAPI:</p> <pre><code># FastAPI app\nfrom fastapi import Depends\nfrom fastapi.security import HTTPBasic, HTTPBasicCredentials\n\nsecurity = HTTPBasic()\n\n@app.get(\"/protected\")\ndef protected_route(credentials: HTTPBasicCredentials = Depends(security)):\n    return {\"username\": credentials.username}\n</code></pre> <p>Configure the client's <code>config.py</code>:</p> <pre><code>def get_user_key() -&gt; str:\n    return \"your-username\"\n\ndef get_pass_key() -&gt; str:\n    return \"your-password\"\n</code></pre>"},{"location":"framework-fastapi/#regenerating-the-client","title":"Regenerating the Client","text":"<p>When you update your FastAPI endpoints, regenerate the client:</p> <pre><code>clientele generate -u http://localhost:8000/openapi.json -o my_client/ --regen t\n</code></pre> <p>The <code>--regen t</code> flag tells Clientele to regenerate the client. Your <code>config.py</code> will not be overwritten.</p>"},{"location":"framework-fastapi/#workflow-integration","title":"Workflow Integration","text":"<ol> <li>Update your FastAPI endpoints</li> <li>Run <code>clientele generate</code> with <code>--regen t</code></li> <li>Review the changes with <code>git diff</code></li> <li>Run your tests to ensure everything still works</li> <li>Commit the updated client</li> </ol>"},{"location":"framework-fastapi/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>FastAPI's path and query parameters are automatically converted to function arguments:</p>"},{"location":"framework-fastapi/#fastapi-endpoint","title":"FastAPI Endpoint","text":"<pre><code>@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int, include_posts: bool = False):\n    return {\"user_id\": user_id, \"include_posts\": include_posts}\n</code></pre>"},{"location":"framework-fastapi/#generated-client-usage","title":"Generated Client Usage","text":"<pre><code># Required path parameter, optional query parameter\nresponse = client.get_user_users_user_id_get(\n    user_id=123,\n    include_posts=True\n)\n</code></pre>"},{"location":"framework-fastapi/#response-models","title":"Response Models","text":"<p>FastAPI's response models become Pydantic schemas in the client:</p>"},{"location":"framework-fastapi/#fastapi-endpoint_1","title":"FastAPI Endpoint","text":"<pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.get(\"/users/{user_id}\", response_model=User)\ndef get_user(user_id: int):\n    return User(id=user_id, name=\"Alice\", email=\"alice@example.com\")\n</code></pre>"},{"location":"framework-fastapi/#generated-client-usage_1","title":"Generated Client Usage","text":"<pre><code>response = client.get_user_users_user_id_get(user_id=123)\n# response is typed as schemas.User\nprint(response.name)\n</code></pre>"},{"location":"framework-fastapi/#known-limitations","title":"Known Limitations","text":""},{"location":"framework-fastapi/#openapi-version","title":"OpenAPI Version","text":"<ul> <li>Supported: FastAPI's default OpenAPI 3.0.x schemas work perfectly</li> <li>Partial Support: Some OpenAPI 3.1 features may not be fully supported yet</li> <li>Not Supported: OpenAPI 2.0 (Swagger) is not supported</li> </ul>"},{"location":"framework-fastapi/#complex-schema-features","title":"Complex Schema Features","text":"<ul> <li>Most FastAPI/Pydantic features work out of the box</li> <li><code>oneOf</code>, <code>anyOf</code>, and <code>nullable</code> are fully supported</li> <li>Some exotic schema combinations may require manual adjustment</li> </ul>"},{"location":"framework-fastapi/#file-uploads","title":"File Uploads","text":"<p>File upload endpoints may require manual customization of the generated client code.</p>"},{"location":"framework-fastapi/#callbacks-and-webhooks","title":"Callbacks and Webhooks","text":"<p>Clientele specifically focuses on calling an API and doesn't handle callbacks or webhooks - these are features usually seen in a web server.</p>"},{"location":"framework-fastapi/#best-practices","title":"Best Practices","text":"<ol> <li>Use custom operationId values for cleaner function names</li> <li>Keep schemas in sync by regenerating after API changes</li> <li>Version your generated client in git to track changes</li> <li>Test thoroughly after regenerating</li> <li>Use the same Python version for both API and client when possible</li> </ol>"},{"location":"framework-fastapi/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about regeneration workflow</li> <li>Configure authentication</li> <li>Set up testing with respx</li> <li>Understand client structure</li> </ul>"},{"location":"install/","title":"\ud83c\udfd7\ufe0f Install","text":"<p>We recommend installing with pipx or uv as a global CLI command:</p>"},{"location":"install/#with-uv-recommended","title":"With uv (Recommended)","text":"<pre><code>uv tool install clientele\n</code></pre>"},{"location":"install/#with-pipx-python","title":"With pipx (Python)","text":"<pre><code>pipx install clientele\n</code></pre>"},{"location":"install/#with-homebrew-macoslinux","title":"With Homebrew (macOS/Linux)","text":"<pre><code>brew install phalt/clientele/clientele\n</code></pre>"},{"location":"install/#with-pip","title":"With pip","text":"<pre><code>pip install clientele\n</code></pre> <p>Once installed, you can run <code>clientele version</code> to make sure you have the latest version:</p> <pre><code>&gt; clientele version\nclientele 1.1.0\n</code></pre>"},{"location":"references/","title":"\ud83d\udd17 References in OpenAPI","text":"<p>Clientele fully supports OpenAPI's <code>$ref</code> mechanism for reusing schema definitions across your API specification. This page explains how references work and what Clientele does when generating clients with them.</p>"},{"location":"references/#what-are-refs","title":"What are <code>$ref</code>s?","text":"<p>In OpenAPI, <code>$ref</code> (short for \"reference\") lets you define a schema, parameter, or response once and reuse it throughout your specification.</p> <p>Here's a simple example:</p> <pre><code>{\n  \"components\": {\n    \"schemas\": {\n      \"User\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": { \"type\": \"integer\" },\n          \"name\": { \"type\": \"string\" }\n        }\n      },\n      \"UserList\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"users\": {\n            \"type\": \"array\",\n            \"items\": { \"$ref\": \"#/components/schemas/User\" }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Instead of duplicating the <code>User</code> schema definition everywhere you need it, you use <code>$ref</code> to reference it.</p>"},{"location":"references/#how-clientele-handles-references","title":"How Clientele handles references","text":"<p>Clientele resolves all <code>$ref</code> declarations in your OpenAPI schema and generates properly-typed Python code using Pydantic models.</p>"},{"location":"references/#types-of-references-supported","title":"Types of references supported","text":"<p>Clientele handles <code>$ref</code> in all the places the OpenAPI specification allows:</p>"},{"location":"references/#1-schema-properties","title":"1. Schema properties","text":"<p>When a property references another schema:</p> <pre><code>{\n  \"Response\": {\n    \"properties\": {\n      \"user\": { \"$ref\": \"#/components/schemas/User\" }\n    }\n  }\n}\n</code></pre> <p>Generates:</p> <pre><code>class User(pydantic.BaseModel):\n    id: int\n    name: str\n\nclass Response(pydantic.BaseModel):\n    user: \"User\" \n</code></pre>"},{"location":"references/#2-array-items","title":"2. Array items","text":"<p>When array items reference a schema:</p> <pre><code>{\n  \"UserList\": {\n    \"properties\": {\n      \"users\": {\n        \"type\": \"array\",\n        \"items\": { \"$ref\": \"#/components/schemas/User\" }\n      }\n    }\n  }\n}\n</code></pre> <p>Generates:</p> <pre><code>class UserList(pydantic.BaseModel):\n    users: list[User]\n</code></pre>"},{"location":"references/#3-enum-references","title":"3. Enum references","text":"<p>References to enum schemas work just as you'd expect:</p> <pre><code>{\n  \"Status\": {\n    \"type\": \"string\",\n    \"enum\": [\"active\", \"inactive\"]\n  },\n  \"Response\": {\n    \"properties\": {\n      \"status\": { \"$ref\": \"#/components/schemas/Status\" }\n    }\n  }\n}\n</code></pre> <p>Generates:</p> <pre><code>class Status(str, enum.Enum):\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\"\n\nclass Response(pydantic.BaseModel):\n    status: \"Status\"\n</code></pre>"},{"location":"references/#4-response-references","title":"4. Response references","text":"<p>OpenAPI lets you define reusable responses in <code>components/responses</code>:</p> <pre><code>components:\n  responses:\n    ErrorResponse:\n      description: Standard error response\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n  schemas:\n    Error:\n      type: object\n      properties:\n        message:\n          type: string\n\npaths:\n  /users:\n    get:\n      responses:\n        '400':\n          $ref: '#/components/responses/ErrorResponse'\n</code></pre> <p>Clientele resolves the response reference and generates the corresponding schema just once:</p> <pre><code>class Error(pydantic.BaseModel):\n    message: str\n</code></pre>"},{"location":"references/#5-parameter-references","title":"5. Parameter references","text":"<p>You can define reusable parameters:</p> <pre><code>components:\n  parameters:\n    PageNumber:\n      name: page\n      in: query\n      schema:\n        type: integer\n\npaths:\n  /users:\n    get:\n      parameters:\n        - $ref: '#/components/parameters/PageNumber'\n</code></pre> <p>Clientele includes these in the generated function signatures or header classes.</p>"},{"location":"references/#6-composed-schemas-allof","title":"6. Composed schemas (allOf)","text":"<p>OpenAPI's <code>allOf</code> lets you compose schemas from multiple references:</p> <pre><code>components:\n  schemas:\n    BaseUser:\n      type: object\n      properties:\n        id:\n          type: integer\n    UserDetails:\n      type: object\n      properties:\n        email:\n          type: string\n    FullUser:\n      allOf:\n        - $ref: '#/components/schemas/BaseUser'\n        - $ref: '#/components/schemas/UserDetails'\n</code></pre> <p>Generates a single merged schema:</p> <pre><code>class FullUser(pydantic.BaseModel):\n    id: int       # From BaseUser\n    email: str    # From UserDetails\n</code></pre>"},{"location":"references/#nested-references","title":"Nested references","text":"<p>Clientele handles deeply nested references without any issues:</p> <pre><code>{\n  \"Comment\": {\n    \"properties\": {\n      \"author\": { \"$ref\": \"#/components/schemas/User\" }\n    }\n  },\n  \"Post\": {\n    \"properties\": {\n      \"comments\": {\n        \"type\": \"array\",\n        \"items\": { \"$ref\": \"#/components/schemas/Comment\" }\n      }\n    }\n  }\n}\n</code></pre> <p>Generates properly typed nested structures:</p> <pre><code>class User(pydantic.BaseModel):\n    id: int\n    name: str\n\nclass Comment(pydantic.BaseModel):\n    author: User\n\nclass Post(pydantic.BaseModel):\n    comments: list[Comment]\n</code></pre>"},{"location":"references/#working-with-generated-code","title":"Working with generated code","text":"<p>The generated code using references works seamlessly at runtime:</p> <pre><code>from my_api import schemas\n\n# Create a user\nuser = schemas.User(id=1, name=\"Alice\")\n\n# Use in a response\nresponse = schemas.Response(user=user)\n\n# Type checking works!\nreveal_type(response.user)  # Revealed type is \"User\"\n\n# IDE auto-completion works too\nresponse.user.name  # \u2190 Your IDE suggests 'id' and 'name'\n</code></pre>"},{"location":"references/#real-world-example","title":"Real-world example","text":"<p>Here's a complete example showing multiple reference types working together:</p>"},{"location":"references/#openapi-schema","title":"OpenAPI Schema","text":"<pre><code>{\n  \"components\": {\n    \"schemas\": {\n      \"UserRole\": {\n        \"type\": \"string\",\n        \"enum\": [\"admin\", \"user\", \"guest\"]\n      },\n      \"User\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": { \"type\": \"integer\" },\n          \"name\": { \"type\": \"string\" },\n          \"role\": { \"$ref\": \"#/components/schemas/UserRole\" }\n        }\n      },\n      \"TeamResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { \"type\": \"string\" },\n          \"members\": {\n            \"type\": \"array\",\n            \"items\": { \"$ref\": \"#/components/schemas/User\" }\n          },\n          \"owner\": { \"$ref\": \"#/components/schemas/User\" }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"references/#generated-code","title":"Generated Code","text":"<pre><code>import enum\nimport pydantic\n\nclass UserRole(str, enum.Enum):\n    ADMIN = \"admin\"\n    USER = \"user\"\n    GUEST = \"guest\"\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n    role: UserRule\n\nclass TeamResponse(pydantic.BaseModel):\n    name: str\n    members: list[User]\n    owner: User\n</code></pre>"},{"location":"references/#usage","title":"Usage","text":"<pre><code>from my_api import schemas\n\n# Create users with enum roles\nadmin = schemas.User(\n    id=1, \n    name=\"Alice\", \n    role=schemas.UserRole.ADMIN\n)\nmember = schemas.User(\n    id=2, \n    name=\"Bob\", \n    role=schemas.UserRole.USER\n)\n\n# Create a team response\nteam = schemas.TeamResponse(\n    name=\"Engineering\",\n    members=[admin, member],\n    owner=admin\n)\n\n# Everything is properly typed\nassert isinstance(team.owner, schemas.User)\nassert team.owner.role == schemas.UserRole.ADMIN\n</code></pre>"},{"location":"references/#summary","title":"Summary","text":"<p>Clientele handles all forms of <code>$ref</code> in OpenAPI schemas:</p> Reference Type Location Supported Example Schema in property <code>properties.user.$ref</code> \u2705 <code>user: \"User\"</code> Schema in array <code>items.$ref</code> \u2705 <code>list[\"User\"]</code> Enum reference <code>properties.status.$ref</code> \u2705 <code>status: \"Status\"</code> Response reference <code>responses.400.$ref</code> \u2705 Schema generated Parameter reference <code>parameters.$ref</code> \u2705 Included in functions allOf composition <code>allOf[n].$ref</code> \u2705 Merged into one schema"},{"location":"testing/","title":"Testing","text":"<p>Clientele is designed for easy testing. </p> <p>Our own test suite shows how you can write mock tests for your API client.</p> <pre><code>import pytest\nfrom httpx import Response\nfrom respx import MockRouter\n\nfrom .test_client import client, constants, schemas\n\nBASE_URL = constants.api_base_url()\n\n\n@pytest.mark.respx(base_url=BASE_URL)\ndef test_simple_request_simple_request_get(respx_mock: MockRouter):\n    # Given\n    mocked_response = {\"status\": \"hello world\"}\n    mock_path = \"/simple-request\"\n    respx_mock.get(mock_path).mock(\n        return_value=Response(json=mocked_response, status_code=200)\n    )\n    # When\n    response = client.simple_request_simple_request_get()\n    # Then\n    assert isinstance(response, schemas.SimpleResponse)\n    assert len(respx_mock.calls) == 1\n    call = respx_mock.calls[0]\n    assert call.request.url == BASE_URL + mock_path\n</code></pre> <p>We recommend installing respx for writing your tests.</p>"},{"location":"usage/","title":"\ud83d\udcdd Use Clientele","text":"<p>Note</p> <p>You can type <code>clientele COMMAND --help</code> at anytime to see information about the available arguments.</p>"},{"location":"usage/#client-types","title":"Client Types","text":"<p>Clientele offers five types of generators:</p> <ol> <li><code>generate</code> - a function-based client either as async or sync.</li> <li><code>generate-class</code> - a class-based client either as async or sync.</li> <li><code>generate-basic</code> - Basic file structure with no generated code.</li> </ol>"},{"location":"usage/#generate","title":"<code>generate</code>","text":"<p>Generate a function-based Python HTTP Client from an OpenAPI Schema.</p>"},{"location":"usage/#from-a-url","title":"From a URL","text":"<p>Use the <code>-u</code> or <code>--url</code> argument.</p> <p><code>-o</code> or <code>--output</code> is the target directory for the generated client.</p> <pre><code>clientele generate -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre>"},{"location":"usage/#from-a-file","title":"From a file","text":"<p>Alternatively you can provide a local file using the <code>-f</code> or <code>--file</code> argument.</p> <pre><code>clientele generate -f path/to/file.json -o my_client/\n</code></pre>"},{"location":"usage/#asyncio","title":"Async.io","text":"<p>If you prefer an asyncio client, just pass <code>--asyncio t</code> to your command.</p> <pre><code>clientele generate -f path/to/file.json -o my_client/ --asyncio t\n</code></pre>"},{"location":"usage/#generate-class","title":"<code>generate-class</code>","text":"<p>Generate a class-based Python HTTP Client from an OpenAPI Schema. This generator creates a <code>Client</code> class object with methods for each API endpoint instead of functions in a module.</p>"},{"location":"usage/#usage","title":"Usage","text":"<p>The <code>generate-class</code> command accepts the same arguments as <code>generate</code>:</p> <pre><code>clientele generate-class -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre>"},{"location":"usage/#generate-basic","title":"generate-basic","text":"<p>The <code>generate-basic</code> command can be used to generate a basic file structure for an HTTP client.</p> <p>It does not require an OpenAPI schema. It does not generate any code.</p> <p>This command is there for when have an HTTP API without an OpenAPI schema, but you want to keep a consistent file structure with other Clientele clients.</p> <pre><code>clientele generate-basic -o my_client/\n</code></pre>"},{"location":"usage/#functional-vs-class","title":"Functional vs Class","text":"<p>Use function-based clients (<code>generate</code>) when:</p> <ul> <li>You prefer a functional programming style.</li> <li>You want the simplest possible client.</li> <li>You don't need to maintain state between requests.</li> <li>You only need a single static configuration.</li> </ul> <p>Use class-based (<code>generate-class</code>) clients when:</p> <ul> <li>You prefer an object-oriented programming style.</li> <li>You need to maintain state or configuration in the client instance.</li> <li>You want to subclass and extend the client behavior.</li> <li>You need dynamic configuration or multiple clients with different settings.</li> </ul>"},{"location":"usage/#configuration","title":"Configuration","text":"<p>See the Configuration Guide.</p>"},{"location":"usage/#explore","title":"<code>explore</code>","text":"<p>Run the explorer mode. See explore.</p>"},{"location":"usage/#version","title":"<code>version</code>","text":"<p>Print the current version of Clientele:</p> <pre><code>```sh\n&gt; clientele version\nClientele 1.1.0\n```\n</code></pre>"},{"location":"usage/#regenerating","title":"Regenerating","text":"<p>At times you may wish to regenerate the client. </p> <p>This could be because the API has updated or you just want to use a newer version of Clientele.</p> <p>To force a regeneration you must pass the <code>--regen</code> or <code>-r</code> argument, for example:</p> <pre><code>```sh\nclientele generate -f example_openapi_specs/best.json -o my_client/  --regen t\n```\n</code></pre> <p>Note</p> <p>You can copy and paste the command from the <code>MANIFEST.md</code> file in your previously-generated client for a quick and easy regeneration.</p>"},{"location":"usage/#understanding-regeneration","title":"Understanding Regeneration","text":"<p>When you regenerate a client with <code>--regen t</code>, Clientele follows these rules:</p> <p>Files that WILL be overwritten:</p> <ul> <li><code>client.py</code> - Your API client functions/class</li> <li><code>schemas.py</code> - Pydantic models for request/response data</li> <li><code>http.py</code> - HTTP handling logic</li> <li><code>__init__.py</code> - Package initialization</li> <li><code>MANIFEST.md</code> - Metadata about the generated client</li> </ul> <p>Files that will NOT be overwritten:</p> <ul> <li><code>config.py</code> - Your custom configuration (API URL, auth tokens, headers)</li> </ul> <p>This design ensures your customizations in <code>config.py</code> are preserved while keeping the client code in sync with the latest API schema.</p>"},{"location":"usage/#the-manifestmd-file","title":"The MANIFEST.md File","text":"<p>Every generated client includes a <code>MANIFEST.md</code> file that records:</p> <ul> <li>The exact command used to generate the client</li> <li>The OpenAPI version of the source schema</li> <li>The Clientele version used</li> <li>Generation timestamp</li> </ul> <p>Example <code>MANIFEST.md</code>:</p> <pre><code># Manifest\n\nGenerated with [https://github.com/phalt/clientele](https://github.com/phalt/clientele)\nInstall with pipx:\n\n```sh\npipx install clientele\n```\n\nAPI VERSION: 0.1.0\nOPENAPI VERSION: 3.0.2\nCLIENTELE VERSION: 1.1.0\n\nRegenerate using this command:\n\n```sh\nclientele generate -f example_openapi_specs/best.json -o tests/async_test_client/ --asyncio t --regen t\n```\n\nExplore this API interactively:\n\n```sh\nclientele explore -c .\n```\n</code></pre>"},{"location":"usage/#regeneration-workflow","title":"Regeneration Workflow","text":"<p>Here's the recommended workflow for keeping your client in sync:</p> <ol> <li>API Updated: Your API has new endpoints or changed schemas</li> <li>Regenerate: Run <code>clientele generate</code> with <code>--regen t</code> <pre><code>clientele generate -u http://localhost:8000/openapi.json -o my_client/ --regen t\n</code></pre></li> <li>Review Changes: Use git to see what changed <pre><code>git diff my_client/\n</code></pre></li> <li>Inspect the changes.</li> <li>Test: Run your test suite to catch breaking changes <pre><code>pytest tests/\n</code></pre></li> <li>Commit: Add the changes to git <pre><code>git add my_client/\ngit commit -m \"Regenerate client for API v2.1\"\n</code></pre></li> </ol>"},{"location":"usage/#handling-breaking-changes","title":"Handling Breaking Changes","text":"<p>When the API introduces breaking changes, regeneration will reflect them:</p> <ul> <li>Removed endpoints \u2192 Functions deleted from <code>client.py</code></li> <li>Renamed fields \u2192 Schema properties change</li> <li>New required fields \u2192 Function signatures updated</li> <li>Changed response types \u2192 Schema unions modified</li> </ul> <p>You should have tests to catch these issues.</p> <p>If you need to support multiple API versions, consider generating separate clients for each version sing version-specific directories (e.g., <code>my_client_v1/</code>, <code>my_client_v2/</code>).</p>"},{"location":"usage/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>You can automate regeneration in CI/CD:</p> <pre><code># Example GitHub Actions workflow\n- name: Regenerate API client\n  run: |\n    clientele generate \\\n      -u http://api:8000/openapi.json \\\n      -o clients/my_api/ \\\n      --regen t\n\n    # Check if client changed\n    if ! git diff --quiet clients/my_api/; then\n      echo \"API client changed - review required\"\n      git diff clients/my_api/\n      exit 1\n    fi\n</code></pre> <p>This keeps your client in sync with the API schema.</p>"}]}