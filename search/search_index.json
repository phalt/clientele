{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u269c\ufe0f Home","text":""},{"location":"#example-code","title":"Example code","text":"<pre><code>from clientele import api\nfrom .schemas import Pokemon\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2/\")\n\n@client.get(\"/pokemon/{id}\")\ndef get_pokemon_name(id: int, result: Pokemon) -&gt; str:\n    return result.name\n</code></pre> <p>See more examples.</p>"},{"location":"#why-use-clientele","title":"Why use Clientele?","text":"<ul> <li>Just modern Python - Types, Pydantic, and HTTPX, that's it.</li> <li>Easy to learn - Clientele is visually similar to popular python API server frameworks.</li> <li>Easy to test - Works with existing tools like respx and pytest-httpx.</li> <li>Easy to configure - Clientele has sensible defaults and plenty of hooks for customisation.</li> <li>A comfortable abstraction - Focus on the data and the functionality, not the connectivity.</li> <li>OpenAPI support - Build your own client, or scaffold one from an OpenAPI schema.</li> </ul>"},{"location":"#async-support","title":"Async support","text":"<pre><code>@client.get(\"/pokemon/{id}\")\nasync def get_pokemon_name(id: int, result: Pokemon) -&gt; str:\n    return result.name\n</code></pre>"},{"location":"#automatic-data-validation","title":"Automatic data validation","text":"<pre><code>from clientele import api as clientele_api\nfrom .my_pydantic_models import CreateBookRequest, CreateBookResponse\n\nclient = clientele_api.APIClient(base_url=\"http://localhost:8000\")\n\n\n@client.post(\"/books\")\ndef create_book(data: CreateBookRequest, result: CreateBookReponse) -&gt; CreateBookResponse:\n    return result\n</code></pre>"},{"location":"#works-with-python-api-frameworks","title":"Works with Python API frameworks","text":"<p>Built and tested to be 100% compatible with the OpenAPI schemas generated from:</p> <ul> <li>FastAPI</li> <li>Django REST Framework via drf-spectacular</li> <li>Django Ninja</li> </ul> <p>See the working demos in our <code>server_examples/</code> directory.</p>"},{"location":"#openapi-support","title":"OpenAPI support","text":"<p>Clientele can create scaffolding for an API client from an OpenAPI schema with:</p> <ul> <li>Pydantic models generated from the schema objects.</li> <li>Smart function signatures generated from schema operations.</li> <li>Async support if you want a client with concurrency.</li> <li>A tiny output that is only 3 files big.</li> <li>Regeneration-friendly - update your API, regenerate, review the git diff, then ship it!</li> <li>Formatted code thanks to Ruff.</li> </ul> <p></p>"},{"location":"#api-client-explorer","title":"API Client explorer","text":"<p>Clientele has an <code>explore</code> mode for quickly testing and debugging APIs through an interactive REPL:</p> <pre><code># Explore an existing clientele-compatible client\nuvx clientele explore -c my_clientele_client/\n\n# Or generate a temporary client from any OpenAPI service on the web\nuvx clientele explore -u https://raw.githubusercontent.com/PokeAPI/pokeapi/master/openapi.yml\n# \ud83e\udd2b Pssst! Copy and paste this right now to try it!\n</code></pre> <p></p> <ul> <li>Autocomplete for operations and schemas.</li> <li>Execute API operations to test the API.</li> <li>Inspect schemas to see what the objects look like.</li> <li>Modify configuration within the REPL as you're testing.</li> </ul>"},{"location":"CHANGELOG/","title":"Change log","text":""},{"location":"CHANGELOG/#143","title":"1.4.3","text":"<ul> <li>A tiny fix with error handling and using <code>response_parser</code> with plain types.</li> </ul>"},{"location":"CHANGELOG/#142","title":"1.4.2","text":"<ul> <li>Fix <code>scaffold-api</code> generating post/put/patch/delete methods with a <code>,,</code> when dealing with optional args. Contributor: @peterHoburg.</li> </ul>"},{"location":"CHANGELOG/#141","title":"1.4.1","text":"<ul> <li>Correct <code>--regen</code> and <code>--asyncio</code> to be boolean flags in <code>scaffold-api</code> command. Contributor: @peterHoburg.</li> <li>Properly support <code>null</code> field for <code>anyOf</code> schemas in OpenAPI schema generation. They now produce <code>None</code> correctly.</li> </ul>"},{"location":"CHANGELOG/#140","title":"1.4.0","text":"<ul> <li>You can now pass <code>TypedDict</code> instances for the <code>data</code> parameter on <code>post</code>, <code>put</code>, <code>patch</code> and <code>delete</code> methods.</li> <li>Decoratored fucntions now accept a <code>response_parser</code> callback that will handle the response parsing. Use this to customise the <code>result</code> value that is sent back to the function.</li> </ul>"},{"location":"CHANGELOG/#130","title":"1.3.0","text":""},{"location":"CHANGELOG/#introducing-clientele-api-a-different-way-to-think-about-python-api-clients","title":"Introducing Clientele API - a different way to think about Python API Clients","text":"<ul> <li>Clientele API is a decorator-driven http client that can create elegant API integrations.</li> <li>Clientele API is considered a beta project for this release. It is an evolving idea that has been tested thoroughly and it works well in ideal conditions. Small changes to the API and usage may occur over time as we encounter unexpected scenarios.</li> </ul>"},{"location":"CHANGELOG/#generate-scaffolding-for-openapi-projects-with-clientele-api","title":"Generate scaffolding for OpenAPI projects with clientele API","text":"<ul> <li>The <code>scaffold-api</code> command will produce scaffolding from an OpenAPI schema and uses the new clientele api.</li> </ul>"},{"location":"CHANGELOG/#explore-apis-with-clientele-api-clients","title":"Explore APIs with Clientele API clients","text":"<ul> <li>The <code>explore</code> command has been updated to support clients that use the clientele api pattern.</li> </ul>"},{"location":"CHANGELOG/#improved-documentation","title":"Improved documentation","text":"<ul> <li>New documentation added to cover Clientele API.</li> <li>Documentation sections have been reorganised to reflect the key features of Clientele.</li> </ul>"},{"location":"CHANGELOG/#200-deprecation-notice","title":"2.0.0 deprecation notice","text":"<ul> <li>When clientele API reaches maturity, support for the current \"barebones\" style of OpenAPI scaffolders will be deprecated.</li> <li>This will be marked as the <code>2.0.0</code> release.</li> </ul>"},{"location":"CHANGELOG/#120","title":"1.2.0","text":"<ul> <li>Print operation information in explorer by typing the name of the operation without parenthesis. Prints information such as the docstring, return type, and input arguments.</li> </ul>"},{"location":"CHANGELOG/#110","title":"1.1.0","text":"<ul> <li>Schema inspection in explore REPL has been improved. Typing a schema name without parentheses now displays the schema's docstring and fields instead of the verbose inherited Pydantic BaseModel documentation.</li> <li>Config objects now handle correctly in explore REPL. Supports old style config functions and the new style classes</li> </ul>"},{"location":"CHANGELOG/#101","title":"1.0.1","text":"<ul> <li>Correct package installation dependencies.</li> </ul>"},{"location":"CHANGELOG/#100","title":"1.0.0","text":""},{"location":"CHANGELOG/#2025-12-27","title":"2025-12-27","text":"<p>Version 1.0.0 represents 12 months of work, planning, testing and using clientele with real APIs. It has major new features and some breaking changes. I recommend completely deleting your previous clients and rebuilding to ensure a smooth rollout.</p> <p>For most of this year I've been constrained by a lack of time to build the features I have planned. With the assistance of supervised agents I have been able to build out most of what I needed, and then spent time correcting and improving the agent's code to be functionally correct.</p> <p>The productivity boost has been immense and has helped me to realise the goals and ambitions I have for this project.</p>"},{"location":"CHANGELOG/#major-new-features","title":"Major new features","text":"<ul> <li>\ud83c\udd95 Explorer CLI: Use <code>clientele explore</code> to use a REPL and discover APIs interactively, even without writing any code.</li> <li>\u2699\ufe0f Rebuilt configuration: <code>config.py</code> has been re-engineered to use pydantic settings.</li> <li>\ud83d\udcdc Rebuilt parser - parsing OpenAPI schema into python objects is now handled entirely by Cicerone, our own OpenAPI parser that was built to meet our unique needs.</li> <li>Clientele now specifically offers 100% support for all major Python API frameworks: FastAPI, Django REST Framework, and Django-Ninja.</li> <li>Clientele is now tested and proven to generate clients for 2000+ openapi schemas as part of our CI. It runs weekly and we use it to ensure broad capability with all OpenAPI services.</li> </ul>"},{"location":"CHANGELOG/#clientele-code-generation-improvements","title":"Clientele code generation improvements","text":"<ul> <li>Fixed function parameter ordering (required parameters before optional ones).</li> <li>Nullable fields properly handled (OpenAPI 3.0 <code>nullable: true</code> and OpenAPI 3.1 array type notation)</li> <li>Fixed: Array responses without a <code>title</code> field now correctly generate type aliases instead of wrapper classes with a <code>test</code> property.</li> <li>Fixed: Responses with no content (e.g., 204 No Content) are now properly included in the status code map with <code>None</code> as the response type.</li> <li>Correctly handle reserved python keywords for schema model properties (i.e. <code>type</code>, <code>next</code> etc).</li> <li>New: Extended httpx configuration options in generated clients - timeout, follow_redirects, verify_ssl, http2, and max_redirects are now configurable.</li> <li>Removed the <code>validate</code> command from the CLI.</li> <li>Replaced <code>openapi-core</code> dependency with <code>cicerone==0.3.0</code> for OpenAPI schema parsing and introspection. This change provides faster, more minimal, and fully typed OpenAPI schema handling.</li> <li>New: Support for OpenAPI <code>deprecated</code> field - operations marked as deprecated will include deprecation warnings in generated docstrings.</li> <li>New: Support for OpenAPI <code>description</code> field - operation descriptions are now included in generated function docstrings for better documentation.</li> <li>Clientele is 100% typed, including the generated code, and verified using ty instead of mypy.</li> <li>Updated all dependencies to their latest stable versions.</li> </ul>"},{"location":"CHANGELOG/#0100","title":"0.10.0","text":"<ul> <li>New: Class-based client generator! Use <code>clientele generate-class</code> to generate a client with a <code>Client</code> class and methods instead of standalone functions.</li> <li>Class-based clients support both sync and async modes with <code>--asyncio t</code> flag.</li> <li>Class-based clients are perfect for object-oriented codebases and when you need to mock the client for testing.</li> <li>New: Dynamic configuration for class-based clients! Class-based clients now accept a <code>Config</code> object in their constructor, allowing you to create multiple clients with different configurations on the fly.</li> <li>The <code>config.py</code> file in class-based clients now generates a <code>Config</code> class instead of standalone functions, enabling runtime configuration changes.</li> <li>You can now instantiate clients with custom configuration: <code>client = Client(config=Config(api_base_url=\"https://api.example.com\", bearer_token=\"my-token\"))</code>.</li> <li>This addresses issues #42 and #49, enabling dynamic auth tokens and multiple clients with different configurations.</li> <li>Updated documentation with comprehensive examples of class-based client usage.</li> <li>Added <code>generate-class</code> command to CLI with full feature parity to the standard <code>generate</code> command.</li> <li>Add ABC (Abstract Base Class) pattern to generators with a <code>Generator</code> base class that all generators inherit from.</li> <li>Refactored all imports to import modules.</li> <li>Changed: Generated code is now auto-formatted with Ruff instead of Black.</li> <li>Breaking change for class-based clients: The <code>config.py</code> file structure has changed from functions to a class. Existing generated clients will need to be regenerated with <code>--regen t</code>.</li> <li>Fixed: OpenAPI <code>number</code> type now correctly maps to Python <code>float</code> instead of <code>int</code>. The <code>integer</code> type continues to map to <code>int</code>, and <code>number</code> with <code>format: \"decimal\"</code> continues to map to <code>decimal.Decimal</code>. This addresses issue #40.</li> <li>New: Python 3.13 and Python 3.14 support! Clientele and all generated clients now officially support Python 3.10, 3.11, 3.12, 3.13, and 3.14.</li> <li>Python 3.9 support has been dropped. If you need Python 3.9 support, please use version 0.9.0 or earlier.</li> </ul>"},{"location":"CHANGELOG/#090","title":"0.9.0","text":"<ul> <li>Support <code>patch</code> methods</li> <li>Fix <code>config.py</code> file being overwritten when generating new clients</li> </ul>"},{"location":"CHANGELOG/#083","title":"0.8.3","text":"<ul> <li>Fix bug with headers assignment</li> </ul>"},{"location":"CHANGELOG/#082","title":"0.8.2","text":"<ul> <li>Improved json support</li> </ul>"},{"location":"CHANGELOG/#081","title":"0.8.1","text":"<ul> <li>Function parameters no longer format to snake_case to maintain consistency with the OpenAPI schema.</li> </ul>"},{"location":"CHANGELOG/#080","title":"0.8.0","text":"<ul> <li>Improved support for Async clients which prevents a weird bug when running more than one event loop. Based on the suggestions from this httpx issue.</li> <li>We now use <code>ruff format</code> for coding formatting (not the client output).</li> <li><code>Decimal</code> support now extends to Decimal input values.</li> <li>Input and Output schemas will now have properties that directly match those provided by the OpenAPI schema. This fixes a bug where previously, the snake-case formatting did not match up with what the API expected to send or receive.</li> </ul>"},{"location":"CHANGELOG/#071","title":"0.7.1","text":"<ul> <li>Support for <code>Decimal</code> types.</li> </ul>"},{"location":"CHANGELOG/#070","title":"0.7.0","text":"<ul> <li>Updated all files to use the templates engine.</li> <li>Generator files have been reorganised in clientele to support future templates.</li> <li><code>constants.py</code> has been renamed to <code>config.py</code> to better reflect how it is used. It is not generated from a template like the other files.</li> <li>If you are using Python 3.10 or later, the <code>typing.Unions</code> types will generate as the short hand <code>|</code> instead.</li> <li>To regenerate a client (and to prevent accidental overrides) you must now pass <code>--regen t</code> or <code>-r t</code> to the <code>generate</code> command. This is automatically added to the line in <code>MANIFEST.md</code> to  help.</li> <li>Clientele will now automatically run black code formatter once a client is generated or regenerated.</li> <li>Clientele will now generate absolute paths to refer to adjacent files in the generated client, instead of relative paths. This assumes you are running the <code>clientele</code> command in the root directory of your project.</li> <li>A lot of documentation and docs strings updates so that code in the generated client is easier to understand.</li> <li>Improved the utility for snake-casing enum keys. Tests added for the functions.</li> <li>Python 3.12 support.</li> <li>Add a \"basic\" client using the command <code>generate-basic</code>. This can be used to keep a consistent file structure for an API that does not use OpenAPI.</li> </ul>"},{"location":"CHANGELOG/#063","title":"0.6.3","text":"<ul> <li>Packaged application installs in the correct location. Resolving #6</li> <li>Updated pyproject.toml to include a better selection of links.</li> </ul>"},{"location":"CHANGELOG/#062","title":"0.6.2","text":"<ul> <li>Ignore optional URL query parameters if they are <code>None</code>.</li> </ul>"},{"location":"CHANGELOG/#061","title":"0.6.1","text":"<ul> <li>Added <code>from __future__ import annotations</code> in files to help with typing evaluation.</li> <li>Update to use pydantic 2.4.</li> <li>A bunch of documentation and readme updates.</li> <li>Small wording and grammar fixes.</li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":"<ul> <li>Significantly improved handling for response schemas. Responses from API endpoints now look at the HTTP status code to pick the correct response schema to generate from the HTTP json data. When regenerating, you will notice a bit more logic generated in the <code>http.py</code> file to handle this.</li> <li>Significantly improved coverage of exceptions raised when trying to generate response schemas.</li> <li>Response types for a class are now sorted.</li> <li>Fixed a bug where <code>put</code> methods did not generate input data correctly.</li> </ul>"},{"location":"CHANGELOG/#052","title":"0.5.2","text":"<ul> <li>Fix pathing for <code>constants.py</code> - thanks to @matthewknight for the contribution!</li> <li>Added <code>CONTRIBUTORS.md</code></li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<ul> <li>Support for HTTP PUT methods</li> <li>Headers objects use <code>exclude_unset</code> to avoid passing <code>None</code> values as headers, which httpx does not support.</li> </ul> <p>Additionally, an async test client is now included in the test suite. It has identical tests to the standard one but uses the async client instead.</p>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/#please-delete-the-constantspy-file-when-updating-to-this-version-to-have-new-features-take-affect","title":"Please delete the constants.py file when updating to this version to have new features take affect","text":"<ul> <li>Paths are resolved correctly when generating clients in nested directories.</li> <li><code>additional_headers()</code> is now applied to every client, allowing you to set up headers for all requests made by your client.</li> <li>When the client cannot match an HTTP response to a return type for the function it will now raise an <code>http.APIException</code>. This object will have the <code>response</code> attached to it for inspection by the developer.</li> <li><code>MANIFEST</code> is now renamed to <code>MANIFEST.md</code> and will include install information for Clientele, as well as information on the command used to generate the client.</li> </ul>"},{"location":"CHANGELOG/#044","title":"0.4.4","text":"<p>Examples and documentation now includes a very complex example schema built using FastAPI that offers the following variations:</p> <ul> <li>Simple request / response (no input just an output)</li> <li>A request with a URL/Path parameter.</li> <li>Models with <code>int</code>, <code>str</code>, <code>list</code>, <code>dict</code>, references to other models, enums, and <code>list</code>s of other models and enums.</li> <li>A request with query parameters.</li> <li>A response model that has optional parameters.</li> <li>An HTTP POST request that takes an input model.</li> <li>An HTTP POST request that takes path parameters and also an input model.</li> <li>An HTTP GET request that requires an HTTP header, and returns it.</li> <li>An HTTP GET endpoint that returns the HTTP bearer authorization token (also makes clientele generate the http authentication for this schema).</li> </ul> <p>A huge test suite has been added to the CI pipeline for this project using a copy of the generated client from the schema above.</p>"},{"location":"CHANGELOG/#043","title":"0.4.3","text":"<ul> <li><code>Enums</code> now inherit from <code>str</code> as well so that they serialize to JSON properly. See this little nugget.</li> </ul>"},{"location":"CHANGELOG/#042","title":"0.4.2","text":"<ul> <li>Correctly use <code>model_rebuild</code> for complex schemas where there are nested schemas, his may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema.</li> <li>Do not raise for status, instead attempt to return the response if it cannot match a response type.</li> </ul>"},{"location":"CHANGELOG/#041","title":"0.4.1","text":"<ul> <li>Correctly generate lists of nested schema classes</li> <li>Correctly build response schemas that are emphemeral (such as when they just return an array of other schemas, or when they have no $ref).</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>Change install suggestion to use pipx as it works best as a global CLI tool.</li> <li>Improved support for OpenAPI 3.0.3 schemas (a test version is available in the example_openapi_specs directory).</li> <li><code>validate</code> command for validating an OpenAPI schema will work with clientele.</li> <li><code>version</code> command for showing the current version of clientele.</li> <li>Supports HTTP DELETE methods.</li> <li>Big refactor of how methods are generated to reduce duplicate code.</li> <li>Support optional header parameters in all request functions (where they are required).</li> <li>Very simple Oauth2 support - if it is discovered will set up HTTP Bearer auth for you.</li> <li>Uses <code>dict</code> and <code>list</code> instead of <code>typing.Dict</code> and <code>typing.List</code> respectively.</li> <li>Improved schema generation when schemas have $ref to other models.</li> </ul>"},{"location":"CHANGELOG/#032","title":"0.3.2","text":"<ul> <li>Minor changes to function name generation to make it more consistent.</li> <li>Optional parameters in schemas are working properly.</li> </ul>"},{"location":"CHANGELOG/#031","title":"0.3.1","text":"<ul> <li>Fixes a bug when generating HTTP Authentication schema.</li> <li>Fixes a bug when generating input classes for post functions, when the input schema doesn't exist yet.</li> <li>Generates pythonic function names in clients now, always (like <code>lower_case_snake_case</code>).</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>Now generates a <code>MANIFEST</code> file with information about the build versions</li> <li>Added a <code>constants.py</code> file to the output if one does not exist yet, which can be used to store values that you do not want to change between subsequent re-generations of the clientele client, such as the API base url.</li> <li>Authentication patterns now use <code>constants.py</code> for constants values.</li> <li>Removed <code>ipython</code> from package dependencies and moved to dev dependencies.</li> <li>Documentation! https://phalt.github.io/clientele/</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>Improved CLI output</li> <li>Code organisation is now sensible and not just one giant file</li> <li>Now supports an openapi spec generated from a dotnet project (<code>Microsoft.OpenApi.Models</code>)</li> <li>async client support  fully working</li> <li>HTTP Bearer support</li> <li>HTTP Basic support</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<ul> <li>Initial version</li> <li>Mostly works with a simple FastAPI generated spec (3.0.2)</li> <li>Works with Twilio's spec (see example_openapi_specs/ directory) (3.0.1)</li> <li>Almost works with stripes</li> </ul>"},{"location":"api-async/","title":"\ud83d\udd00 Async support","text":"<p>Clientele API supports both async and sync functions.</p> <p>They can even be mixed in together if you prefer.</p>"},{"location":"api-async/#async-and-sync-example","title":"Async and sync example","text":"<pre><code>from clientele import api as clientele_api\nfrom .my_config import Config\nfrom .my_models import BookResponse, CreateBookReponse, CreateBookRequest\n\nclient = clientele_api.APIClient(config=Config())\n\n@client.post(\"/books\")\ndef create_user(\n    data: CreateBookReponse,\n    result: CreateBookReponse,\n) -&gt; CreateBookReponse:\n    return result\n\n\n# Mix sync and async functions in the same client\n@client.get(\"/book/{book_id}\")\nasync def get_book(book_id: int, result: BookResponse) -&gt; BookResponse:\n    return result\n</code></pre>"},{"location":"api-async/#async-and-sync-usage","title":"Async and sync usage","text":"<pre><code>from my_clientele_client import client, schemas\n\n# handle sync requests\nresponse = client.create_book(\n    data=schemas.CreateBookRequest(title=\"My awesome book\")\n)\n\nmatch response:\n    case schemas.CreateBookResponse():\n        # handle valid response\n    case schemas.ValidationError():\n        # handle errors\n\n# Handle async requests\nbook_response = await client.get_book(book_id=123)\n</code></pre>"},{"location":"api-authentication/","title":"\ud83d\udd10 Authentication","text":"<p>Clientele API supports multiple authentication methods through the client configuration.</p>"},{"location":"api-authentication/#bearer-token","title":"Bearer Token","text":"<p>Bearer token authentication can be configured by adding an <code>Authorization</code> header.</p> <p>Configuration:</p> <pre><code># config.py\nfrom clientele import api as clientele_api\n\nclass Config(clientele_api.BaseConfig):\n    ...\n    headers = {\"Authorization\": \"MY_SECRET_TOKEN\"}\n    ...\n</code></pre>"},{"location":"api-authentication/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<p>Basic authentication can be configured using httpx.Auth:</p> <p>Configuration:</p> <pre><code># config.py\nimport httpx\nfrom clientele import api as clientele_api\nfrom my_settings import AUTH_TOKEN\n\nclass Config(clientele_api.BaseConfig):\n    ...\n    auth = httpx.BasicAuth(\"username\", \"password\")\n    ...\n</code></pre>"},{"location":"api-configuration/","title":"\u2699\ufe0f Configuration","text":""},{"location":"api-configuration/#base-url","title":"base url","text":"<p>You can configure Clientele with just a <code>base_url</code> and let it use sensible defaults for the client:</p> <pre><code>from clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://myapi.com/v1\")\n</code></pre>"},{"location":"api-configuration/#standard-configuration","title":"Standard configuration","text":"<p>We recommend subclassing <code>BaseConfig</code> and managing your own config:</p> <pre><code>from clientele import api as clientele_api\n\nconfig = clientele_api.BaseConfig(\n    base_url=\"https://api.example.com\",\n    headers={\"Authorization\": \"Bearer &lt;token&gt;\"},\n    timeout=10.0,\n)\nclient = clientele_api.APIClient(config=config)\n</code></pre> <p>The <code>BaseConfig</code> class is powered by pydantic-settings that automatically loads values from environment variables, <code>.env</code> files or just plain hard coded configuration.</p>"},{"location":"api-configuration/#configuration-options","title":"Configuration options","text":"<ul> <li><code>base_url: str</code> - the url for the API server</li> <li><code>headers: dict[str, str]</code> - headers that you want to send with http requests.</li> <li><code>timeout: float | None = 5.0</code> - the time to wait for an HTTP response before closing the connection.</li> <li><code>follow_redirects: bool = False</code> - if redirects should be followed.</li> <li><code>verify: bool | str = True</code> - if SSL connections should be verified.</li> <li><code>http2: bool = False</code> - if http2 should be used for making requests.</li> <li><code>auth: httpx.Auth | tuple[str, str] | None = None</code> - the authentication method for requests.</li> <li><code>limits: httpx.Limits | None = None</code> - the connection pool size for the underlying client.</li> <li><code>proxies: httpx.Proxy | None = None</code> - the proxies for the underlying client.</li> <li><code>transport: httpx.BaseTransport | httpx.AsyncBaseTransport | None = None</code> - custom transport objects for the underlying client.</li> <li><code>cookies: httpx.Cookies | None = None</code> - the cookies you want to send with http requests.</li> </ul>"},{"location":"api-configuration/#custom-httpx-client","title":"Custom httpx client","text":"<p>You can supply your own <code>httpx.Client</code> and <code>httpx.AsyncClient</code> if you prefer full control:</p> <pre><code>from clientele import api as clientele_api\nimport httpx\n\nclient = clientele_api.APIClient(\n    base_url=\"https://api.example.com\",\n    httpx_client=httpx.Client(), \n    httpx_async_client=httpx.AsyncClient()\n)\n</code></pre>"},{"location":"api-examples/","title":"\ud83c\udfaa Clientele by example","text":"<p>All these examples can be copied and pasted into a file and run in a python application.</p>"},{"location":"api-examples/#simple-get-request","title":"Simple GET request","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: dict) -&gt; dict:\n    return result\n</code></pre> <ul> <li>The simplest logic you can do with Clientele.</li> <li>No validation will be ran on the data.</li> </ul>"},{"location":"api-examples/#receive-specific-data-in-result","title":"Receive specific data in result","text":"<pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass PokemonInfo(BaseModel):\n    name: str\n    id: int\n\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: PokemonInfo) -&gt; PokemonInfo:\n    return result\n</code></pre> <ul> <li>Use Pydantic <code>BaseModel</code> to return only the data you want in the <code>result</code> parameter.</li> <li>Pydantic's <code>model_validate</code> will be ran against the <code>reponse.json</code>.</li> <li>Only values explicitly declared in the <code>BaseModel</code> will be returned.</li> </ul>"},{"location":"api-examples/#return-specific-data-after-result","title":"Return specific data after result","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: dict) -&gt; str:\n    return result.get(\"name\")\n</code></pre> <ul> <li>The return type of the decorated function does not need to match the <code>result</code> parameter.</li> <li>You can return whatever you like.</li> <li>This is also a good time to do logging, persistence of results, dispatching post-request actions, etc.</li> </ul>"},{"location":"api-examples/#query-parameters","title":"Query parameters","text":""},{"location":"api-examples/#using-parameters","title":"Using parameters","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/\")\ndef get_pokemon_page(result: dict, limit: int, offset: int) -&gt; dict:\n    return result\n</code></pre> <pre><code>get_pokemon_page(limit=10, offset=30)\n</code></pre> <ul> <li>Parameters not declared in the path string will instead become query parameters.</li> <li>Optional or <code>None</code> values will be ignored.</li> </ul>"},{"location":"api-examples/#using-query-dict","title":"Using query dict","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/\")\ndef get_pokemon_page(result: dict) -&gt; dict:\n    return result\n</code></pre> <pre><code>get_pokemon_page(query={\"limit\": 10, \"offset\": 30})\n</code></pre> <ul> <li>You can pass a dict <code>query</code> to achieve the same results.</li> <li>This does not need to be declared in your decorated function.</li> </ul>"},{"location":"api-examples/#simple-post-request","title":"Simple POST request","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://httpbin.org\")\n\n\n@client.post(\"/post\")\ndef post_input_data(data: dict, result: dict) -&gt; dict:\n    return result\n</code></pre> <ul> <li>The <code>data</code> parameter is serialized to JSON and sent in an HTTP POST request.</li> <li>This pattern is identical in <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> decorators functions.</li> </ul>"},{"location":"api-examples/#data-validation","title":"Data validation","text":"<pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://httpbin.org\")\n\n\nclass InputData(BaseModel):\n    name: str\n    email: str\n\n\n@client.post(\"/post\")\ndef post_input_data(data: InputData, result: dict) -&gt; InputData:\n    return result\n</code></pre> <ul> <li>Pydantic will run <code>model_validate</code> on the <code>data</code> parameter before sending the HTTP POST request.</li> <li>This pattern is identical in <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> decorators functions.</li> </ul>"},{"location":"api-examples/#inspect-http-responses","title":"Inspect HTTP responses","text":"<pre><code>from clientele import api\nimport httpx\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: dict, response: httpx.Response) -&gt; dict:\n    print(response.headers)\n    return result\n</code></pre> <ul> <li>Pass the <code>response</code> parameter to the decorated function to recive the <code>httpx.Response</code> object.</li> </ul>"},{"location":"api-examples/#control-response-parsing","title":"Control response parsing","text":""},{"location":"api-examples/#using-a-callback","title":"Using a callback","text":"<pre><code>from clientele import api\nimport httpx\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\ndef parse_response_myself(response: httpx.Response) -&gt; dict:\n    data = response.json()\n    return {\n        \"my_custom_key\": data[\"name\"],\n    }\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_parser=parse_response_myself)\ndef get_pokemon_info(pokemon_name: str, result: dict) -&gt; str:\n    return result[\"my_custom_key\"]\n</code></pre> <ul> <li>Pass a callable to the <code>response_parser</code> parameter to control how http responses are parsed.</li> <li>Clientele will no longer handle any data validation for you, but you have compelete control.</li> <li>The return type of this callback must match the type of the <code>result</code> parameter.</li> </ul>"},{"location":"api-examples/#using-strong-types","title":"Using strong types","text":"<pre><code>from clientele import api\nimport httpx\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass MyResult(BaseModel):\n    custom_key: str\n\n\ndef parse_response_myself(response: httpx.Response) -&gt; MyResult:\n    data = response.json()\n    return MyResult(\n        custom_key=data[\"name\"],\n    )\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_parser=parse_response_myself)\ndef get_pokemon_info(pokemon_name: str, result: MyResult) -&gt; str:\n    return result.custom_key\n</code></pre>"},{"location":"api-examples/#using-a-map","title":"Using a map","text":"<pre><code>import httpx\nfrom pydantic import BaseModel\n\nfrom clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass OkResult(BaseModel):\n    name: str\n\nclass NotFoundResult(BaseModel):\n    name: str\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_map={200: OkResult, 404: NotFoundResult})\ndef get_pokemon_info(pokemon_name: str, result: OkResult | NotFoundResult) -&gt; str:\n    return result.name\n</code></pre> <ul> <li>The <code>response_map</code> accepts <code>{int: ResponseModel}</code>.</li> <li>The HTTP response status code will be matched against the model and used as validation.</li> <li>If the http response does not match any status codes in the <code>response_map</code> then an <code>clientele.api.APIException</code> exception will be raised.</li> </ul>"},{"location":"api-examples/#handling-errors","title":"Handling errors","text":"<pre><code>from pydantic import BaseModel\n\nfrom clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass OnlyErroResult(BaseModel):\n    name: str\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_map={500: OnlyErroResult})\ndef get_pokemon_info(pokemon_name: str, result: OnlyErroResult) -&gt; str:\n    return result.name\n\n\ntry:\n    get_pokemon_info(\"pikachu\")\nexcept api.APIException as e:\n    print(f\"Error occurred: {e.reason}\")\n    print(f\"Response details: {e.response}\")\n</code></pre> <ul> <li>Unexpected response statuses will throw an <code>clientele.api.APIException</code> exception.</li> <li>If there is no <code>response_map</code> provided then Clientele will call <code>raise_for_status</code> on the <code>httpx.Response</code> object.</li> <li>If <code>response_map</code> is provided then the <code>httpx.Response</code> status code must match one of the keys.</li> <li>The <code>APIException</code> will have a human readable <code>reason</code>.</li> <li>The <code>APIException</code> will also have the <code>httpx.Response</code> that raised the exception for inspection.</li> </ul>"},{"location":"api-examples/#configuration","title":"Configuration","text":""},{"location":"api-examples/#using-baseconfig","title":"Using BaseConfig","text":"<pre><code>from clientele import api\nimport httpx\n\nmy_config = api.BaseConfig(base_url=\"https://httpbin.org\")\n\nclient = api.APIClient(config=my_config)\n\n\n@client.get(\"/get\")\ndef my_function(result: dict) -&gt; dict:\n    return result\n</code></pre> <ul> <li>Instead of providing <code>base_url</code> to <code>APIClient</code> you can instead provide a <code>BaseConfig</code> object.</li> <li>This gives you simplified access to common http configuration options.</li> </ul>"},{"location":"api-examples/#custom-headers","title":"Custom headers","text":"<pre><code>from clientele import api\nimport httpx\n\nmy_config = api.BaseConfig(\n    base_url=\"https://httpbin.org\", \n    headers={\"Custom-Header\": \"Hello, Clientele!\"}\n)\n\nclient = api.APIClient(config=my_config)\n\n\n@client.get(\"/get\")\ndef return_headers(result: dict) -&gt; str:\n    \"\"\"httpbin returns the headers it received.\"\"\"\n    return result[\"headers\"][\"Custom-Header\"]\n</code></pre> <ul> <li>Headers can be configured through <code>BaseConfig</code>.</li> <li>See full configuration options here.</li> </ul>"},{"location":"api-examples/#async","title":"Async","text":""},{"location":"api-examples/#make-multiple-requests-in-parallel","title":"Make multiple requests in parallel","text":"<pre><code>import asyncio\nfrom clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/{pokemon_id}\")\nasync def get_pokemon_name(pokemon_id: int, result: dict) -&gt; str:\n    return result[\"name\"]\n\n\nasync def gather():\n    async_tasks = [get_pokemon_name(pokemon_id=i) for i in range(1, 152)]\n    return await asyncio.gather(*async_tasks)\n\n\ndef get_all_pokemon_names():\n    return asyncio.run(gather())\n</code></pre> <ul> <li>Use the common <code>gather</code> / <code>run</code> pattern to build modular API calls with Clientele.</li> <li>This example executes 151 HTTP requests in parallel.</li> </ul>"},{"location":"api-overview/","title":"\ud83d\udcd5 Documentation","text":""},{"location":"api-overview/#http-get-example","title":"HTTP GET example","text":"<pre><code>from pydantic import BaseModel\nfrom clientele import api as clientele_api\nimport httpx\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@client.get(\"/users/{user_id}\")\ndef get_user(user_id: int, result: User, include_details: bool = True) -&gt; User:\n    return result\n\nuser = get_user(42)\n</code></pre> <p>How Clientele works:</p> <ul> <li>Path parameters inside <code>{}</code> are filled from the function arguments (e.g. <code>user_id</code>).</li> <li>Any remaining keyword arguments (like <code>include_details</code> above) become query parameters, but you can also provide a dict function parameter <code>query={...}</code> instead.</li> <li>The <code>result</code> parameter is mandatory and its type annotation (<code>User</code>) drives response parsing.</li> <li>Your function is injected with the <code>result</code> parameter - this is the response payload hydrated into your <code>result</code> parameter's type.</li> <li>The function's return value is independent - you can return the result directly, transform it, or return something completely different.</li> </ul>"},{"location":"api-overview/#http-post-example","title":"HTTP POST example","text":"<pre><code>from typing import TypedDict\nfrom pydantic import BaseModel\nfrom clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\n# Using Pydantic models\nclass CreateUserRequest(BaseModel):\n    name: str\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n@client.post(\"/users\")\ndef create_user(*, data: CreateUserRequest, result: User) -&gt; User:\n    return result\n\nuser = create_user(data=CreateUserRequest(name=\"Ada\"))\n\n# Or use TypedDict for the `data` and `result` parameters\nclass CreateUserRequestDict(TypedDict):\n    name: str\n\nclass UserDict(TypedDict):\n    id: int\n    name: str\n\n@client.post(\"/users\")\ndef create_user_with_dict(*, data: CreateUserRequestDict, result: UserDict) -&gt; UserDict:\n    return result\n\n# Pass dict directly - no instantiation needed\nuser = create_user_with_dict(data={\"name\": \"Ada\"})\n</code></pre> <p>How body-based methods (POST, PUT, PATCH, DELETE) work with Clientele:</p> <ul> <li>The request body must be supplied via the <code>data</code> keyword argument.</li> <li>The <code>data</code> parameter can be a Pydantic model or a TypedDict.</li> <li>For Pydantic models, the data is validated and serialized to JSON automatically.</li> <li>For TypedDict, the data is sent as-is (because TypedDict provides type hints without runtime validation).</li> <li>The <code>result</code> parameter is mandatory and determines how the response is parsed.</li> </ul>"},{"location":"api-overview/#put-patch-and-delete-examples","title":"PUT, PATCH, and DELETE examples","text":"<pre><code>from pydantic import BaseModel\nfrom clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\nclass UpdateUser(BaseModel):\n    name: str\n    email: str\n\nclass PatchNameUser(BaseModel):\n    name: str\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n# PUT with a full body\n@client.put(\"/users/{user_id}\")\ndef update_user(user_id: int, *, data: UpdateUser, result: User) -&gt; User:\n    return result\n\nupdated = update_user(1, data=UpdateUser(name=\"New Name\", email=\"test@foo.com\"))\n\n# PATCH with partial data\n@client.patch(\"/users/{user_id}\")\ndef patch_user_name(user_id: int, *, data: PatchNameUser, result: User) -&gt; User:\n    return result\n\npatched = patch_user_name(1, data=PatchUserName(name=\"New Name\"))\n\n# DELETE that returns an empty response body\n@client.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, *, result: None) -&gt; None:\n    return result\n\ndelete_user(1)\n</code></pre>"},{"location":"api-overview/#return-value-independence","title":"Return value independence","text":"<p>The <code>result</code> parameter defines what response you get from the API, but your function's return value is independent. This gives you flexibility:</p> <pre><code># Return the result directly (most common)\n@client.get(\"/users/{user_id}\")\ndef get_user(user_id: int, result: User) -&gt; User:\n    return result\n\n# Return a derived value\n@client.get(\"/users/{user_id}\")\ndef get_user_email(user_id: int, result: User) -&gt; str:\n    return result.email\n\n# Return multiple values as a tuple\n@client.post(\"/events\")\ndef create_event(data: EventIn, result: EventOut) -&gt; tuple[EventOut, str]:\n    log.info(\"Created event %s\", result.id)\n    return result, \"success\"\n</code></pre>"},{"location":"api-overview/#injected-parameters","title":"Injected parameters","text":"<p>Clientele will inject the following parameters into your function once an http response is returned:</p> <ul> <li><code>result</code>: an instance of the type specified in the <code>result</code> parameter annotation. This parameter is mandatory and its type annotation determines how the response is parsed. Can be a Pydantic model or a TypedDict.</li> <li><code>response</code>: the <code>httpx.Response</code> - useful for logging, debugging etc. (optional)</li> </ul>"},{"location":"api-overview/#response-parsing-rules","title":"Response parsing rules","text":"<ul> <li>If the response has a JSON content type, the payload is decoded from JSON.</li> <li>If the response type is not JSON then a <code>str</code> is returned.</li> <li>Empty body responses return <code>None</code>.</li> <li>The <code>result</code> parameter's type annotation drives response data validation. Pydantic models use <code>model_validate</code> for runtime validation, while TypedDict provides type hints without runtime validation.</li> </ul>"},{"location":"api-overview/#custom-response-parsing","title":"Custom response parsing","text":"<ul> <li>You can provide a callable <code>response_parser</code> to the decorator to handle your own response parsing.</li> <li><code>response_parser</code> will receive the <code>httpx.Response</code> object.</li> <li>The return type of the <code>response_parser</code> must match the type of the <code>result</code> parameter.</li> <li>You cannot provide <code>response_parser</code> and <code>response_mapping</code> (see below) at the same time.</li> </ul> <p>Example:</p> <pre><code>from clientele import api as clientele_api\nimport httpx\nfrom pydantic import BaseModel\n\nclient = clientele_api.APIClient(base_url=\"http://localhost:8000\")\n\nclass CustomResponseParserResponse(BaseModel):\n    name: str\n    other_value: str\n\n# A custom handler for parsing the response\ndef custom_parser(response: httpx.Response) -&gt; CustomResponseParserResponse:\n    data = response.json()\n    return CustomResponseParserResponse(name=data[\"name\"], other_value=\"other value\")\n\n# Annotate the decorate to use, `result` type must match\n@client.get(\"/users/{user_id}\", response_parser=custom_parser)\ndef get_user_custom_response(user_id: int, result: CustomResponseParserResponse) -&gt; str:\n    return result.other_value\n</code></pre>"},{"location":"api-overview/#handling-multiple-response-bodies-and-status-codes","title":"Handling multiple response bodies and status codes","text":"<p>Real APIs often return different response models based on the HTTP status code. This is also a common feature of OpenAPI schemas.</p> <p>The <code>response_map</code> parameter allows you to map status codes to specific Pydantic models or TypedDict classes, enabling proper type handling for success and error responses.</p> <pre><code>from pydantic import BaseModel\nfrom clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\nclass User(BaseModel):\n    id: int\n    name: str\n\nclass NotFoundError(BaseModel):\n    error: str\n    code: int\n\n@client.get(\n    \"/users/{user_id}\",\n    response_map={\n        200: User,\n        404: NotFoundError,\n    }\n)\ndef get_user(user_id: int, result: User | NotFoundError) -&gt; User | NotFoundError:\n    return result\n\n# Returns User for 200 responses\nuser = get_user(1)\nmatch user:\n    case User():\n        print(f\"Found user: {user.name}\")\n    case NotFoundError() :\n        print(f\"Error: {user.error}\")\n\n# For unexpected status codes, clientele.api.APIException is raised\ntry:\n    get_user(-999)  # imagine the server returns 500\nexcept clientele_api.APIException as e:\n    print(f\"Unexpected status: {e.response.status_code}\")\n    print(f\"Reason: {e.reason}\")\n</code></pre>"},{"location":"api-overview/#response_map-requirements","title":"<code>response_map</code> requirements","text":"<ol> <li>Keys must be valid HTTP status codes: Use the <code>codes</code> enum from <code>clientele.api</code> for reference, or any standard HTTP status code integers (100-599).</li> <li>Values must be Pydantic models or TypedDict: Each value must be a <code>BaseModel</code> subclass or a <code>TypedDict</code> class.</li> <li>Result parameter type must include all models: The <code>result</code> parameter's type annotation must be a Union containing all the Pydantic models or TypedDict classes used in <code>response_map</code>.</li> <li>Unexpected status codes raise <code>APIException</code>: If the server returns a status code not in the <code>response_map</code>, an <code>APIException</code> is raised with details about the unexpected status.</li> <li>Precedence: If <code>response_map</code> provides a model for the actual HTTP status code, that model is used. Otherwise, the <code>result</code> parameter annotation is used as the default for 2xx responses.</li> </ol>"},{"location":"api-overview/#multi-status-example-with-post","title":"Multi-status example with POST","text":"<p>If multiple statuses return the same response it is easy enough to extend the map:</p> <pre><code>@client.post(\n    \"/users\",\n    response_map={\n        201: User,\n        400: ValidationError,\n        422: ValidationError,\n    }\n)\ndef create_user(\n    data: User, result: User | ValidationError\n) -&gt; User | ValidationError:\n    return result\n\n# Handle different responses\nresponse = create_user(data=User(name=\"Alice\"))\nmatch response:\n    case User():\n        print(f\"Created user {response.id}\")\n    case ValidationError():\n        print(f\"Validation failed: {response.errors}\")\n</code></pre>"},{"location":"api-overview/#connection-persistence","title":"Connection persistence","text":"<p>Clientele API will generate a singleton instance for the async and sync http clients. When you import the module and issue multiple function calls it will use the same http connection.</p>"},{"location":"compatibility/","title":"\ud83d\udcb1 Compatibility","text":""},{"location":"compatibility/#testing-against-real-world-schemas","title":"Testing Against Real-World Schemas","text":"<p>We rigorously test Clientele to ensure it works with real-world OpenAPI schemas.</p> <p>We test against the entire APIs.guru OpenAPI Directory - a collection of 4000+ real-world OpenAPI schemas from hundreds of different APIs.</p> <p>This testing happens automatically:</p> <ul> <li>Weekly CI runs: Every Monday, GitHub Actions runs the test suite against all schemas</li> <li>Manual testing: Developers can run compatibility tests locally</li> <li>Continuous monitoring: Test results are tracked to catch regressions</li> </ul>"},{"location":"compatibility/#current-results","title":"Current results","text":"<p>As of our latest run, we successfully generate clients for 95.39% of schemas in the OpenAPI directory:</p> <pre><code>================================================================================\nSUMMARY\n================================================================================\nTotal schemas found: 4138\nSuccessful: 1884\nSkipped (version incompatible): 2163\nFailed: 91\nSuccess rate: 95.39% (1884/1975 testable schemas)\n\n91 schemas failed to generate clients:\n  - APIs/akeneo.com/1.0.0/swagger.yaml\n  - APIs/apicurio.local/registry/1.3.2.Final/openapi.yaml\n  - APIs/apidapp.com/2019-02-14T164701Z/openapi.yaml\n  - APIs/apideck.com/file-storage/10.0.0/openapi.yaml\n  - APIs/atlassian.com/jira/1001.0.0-SNAPSHOT/openapi.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Authoring/2.0/swagger.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Authoring/3.0-preview/swagger.yaml\n  - APIs/azure.com/cognitiveservices-LUIS-Programmatic/v2.0/swagger.yaml\n  - APIs/billingo.hu/3.0.7/openapi.yaml\n  - APIs/bunq.com/1.0/openapi.yaml\n  ... and 81 more\n  ```\n\n### Running Compatibility Tests\n\nYou can run the compatibility tests yourself:\n\n```bash\n# Test against all schemas (takes several minutes)\nmake test-openapi-directory\n\n# Test a limited subset for quick feedback\npython3 test_openapi_directory.py --limit 100\n\n# Stop on first failure for debugging\npython3 test_openapi_directory.py -x\n\n# Keep the cloned repository for inspection\npython3 test_openapi_directory.py --keep-repo\n</code></pre>"},{"location":"compatibility/#openapi-version-support","title":"OpenAPI Version Support","text":"<p>Clientele is designed for OpenAPI 3.0.x schemas and supports most standard-compliant implementations.</p>"},{"location":"compatibility/#fully-supported","title":"Fully Supported","text":"<ul> <li>OpenAPI 3.0.0, 3.0.1, 3.0.2, 3.0.3 - Full support for all standard features</li> </ul>"},{"location":"compatibility/#partial-support","title":"Partial Support","text":"<ul> <li>OpenAPI 3.1.x - Many OpenAPI 3.1 schemas work, but some advanced 3.1-specific features may not be fully supported yet.</li> </ul>"},{"location":"compatibility/#not-supported","title":"Not Supported","text":"<ul> <li>OpenAPI 2.0 (Swagger) - The 2.0 format is deprecated and significantly different from 3.0+. Clientele does not support it. If you have a Swagger 2.0 schema, consider upgrading it to OpenAPI 3.0+ first.</li> </ul>"},{"location":"compatibility/#api-compatibility","title":"API Compatibility","text":"<p>Clientele works with any tool that generates standard OpenAPI 3.0+ schemas. We actively test and verify compatibility with these Python API server frameworks:</p>"},{"location":"compatibility/#python-api-frameworks","title":"Python API Frameworks","text":""},{"location":"compatibility/#fastapi","title":"\u2705 FastAPI","text":"<p>Status: 100% compatibility guaranteed</p> <p>FastAPI is Clientele's primary target server framework. FastAPI's automatic OpenAPI schema generation works perfectly with Clientele.</p> <ul> <li>Schema location: Usually <code>/openapi.json</code></li> <li>operationId: Auto-generated or customizable via <code>operation_id</code> parameter</li> <li>Async support: Full support for both sync and async clients</li> <li>Authentication: Bearer tokens, Basic auth, OAuth2 flows</li> </ul> <p>Learn more: Using Clientele with FastAPI</p>"},{"location":"compatibility/#django-rest-framework-drf-spectacular","title":"\u2705 Django REST Framework + drf-spectacular","text":"<p>Status: Full compatibility</p> <p>Django REST Framework with drf-spectacular generates high-quality OpenAPI 3.0 schemas.</p> <ul> <li>Schema location: Configurable, typically <code>/api/schema/</code></li> <li>operationId: Customizable via <code>@extend_schema(operation_id=...)</code></li> <li>Serializers: Convert seamlessly to Pydantic models</li> <li>ViewSets: All CRUD operations supported</li> </ul> <p>We've tested Clientele with numerous DRF APIs - see this GitHub issue for specific schemas we've validated.</p> <p>Learn more: Using Clientele with Django REST Framework</p>"},{"location":"compatibility/#django-ninja","title":"\u2705 Django Ninja","text":"<p>Status: Native support</p> <p>Django Ninja uses Pydantic for schemas, which aligns perfectly with Clientele's output.</p> <ul> <li>Schema location: Usually <code>/api/openapi.json</code></li> <li>operationId: Customizable via <code>operation_id</code> parameter</li> <li>Schemas: Already uses Pydantic, no conversion needed</li> <li>Async support: Supports both sync and async views</li> </ul> <p>Learn more: Using Clientele with Django Ninja</p>"},{"location":"compatibility/#other-tested-apis","title":"Other Tested APIs","text":"<p>We've successfully generated clients from:</p> <ul> <li>Microsoft Azure APIs - Battle-tested and works well</li> <li>Twilio's API - Tested with real-world complexity</li> <li>Various public APIs with standard OpenAPI 3.0.x schemas</li> </ul>"},{"location":"compatibility/#schema-feature-support","title":"Schema Feature Support","text":""},{"location":"compatibility/#fully-supported-features","title":"Fully Supported Features","text":"<p>\u2705 Request/Response schemas - All HTTP methods (GET, POST, PUT, PATCH, DELETE) \u2705 Path parameters - URL path variables \u2705 Query parameters - URL query strings, optional and required \u2705 Request bodies - JSON request payloads \u2705 Multiple response types - Different responses per status code \u2705 Pydantic-compatible types - Strings, integers, floats, booleans, dates, enums \u2705 Arrays and lists - Including nested arrays \u2705 Nested objects - Complex object hierarchies \u2705 References (<code>$ref</code>) - Schema reuse throughout the spec \u2705 <code>oneOf</code> - Discriminated unions with type aliases \u2705 <code>anyOf</code> - Flexible union types \u2705 <code>allOf</code> - Schema composition and inheritance \u2705 <code>nullable</code> - Optional/nullable fields \u2705 Enums - Enumerated string values \u2705 HTTP Bearer authentication - Token-based auth \u2705 HTTP Basic authentication - Username/password auth</p>"},{"location":"compatibility/#partially-supported-or-limited","title":"Partially Supported or Limited","text":"<p>\u26a0\ufe0f File uploads - May require manual customization \u26a0\ufe0f OpenAPI 3.1 specific features - Some edge cases may not work \u26a0\ufe0f OAuth2 flows - Schema is parsed, but token acquisition must be handled manually in <code>config.py</code> \u26a0\ufe0f Complex polymorphism - Some exotic <code>oneOf</code>/<code>anyOf</code> combinations may need adjustment \u26a0\ufe0f Webhooks and Callbacks - Schema elements may be ignored</p>"},{"location":"compatibility/#not-supported_1","title":"Not Supported","text":"<p>\u274c File downloads - Response file handling not generated \u274c Server-Sent Events (SSE) - Streaming responses not supported \u274c WebSockets - Not applicable to HTTP clients \u274c Cookie authentication - Must be handled manually  </p>"},{"location":"compatibility/#known-schema-issues","title":"Known Schema Issues","text":""},{"location":"compatibility/#poor-openapi-implementations","title":"Poor OpenAPI Implementations","text":"<p>Despite a well-defined specification, we've discovered many tools generate non-standard OpenAPI schemas.</p> <p>What this means for you:</p> <ul> <li>Some schema generators sometimes have bugs or take liberties with the spec</li> <li>We can't guarantee 100% compatibility with every OpenAPI schema outside the core API server frameworks we test</li> </ul> <p>Recommendation:</p> <ul> <li>Report issues with specific schemas to help us improve</li> <li>For FastAPI, DRF, and Django Ninja, compatibility is guarenteed</li> </ul>"},{"location":"compatibility/#openapi-31-caveats","title":"OpenAPI 3.1 Caveats","text":"<p>OpenAPI 3.1 aligned with JSON Schema 2020-12, introducing changes:</p> <ul> <li><code>nullable</code> was replaced with <code>type: [...]</code> arrays</li> <li>Some keywords changed semantics</li> <li>Schema validation is stricter</li> </ul> <p>Current state:</p> <ul> <li>Nearly all OpenAPI 3.1 schemas work fine</li> <li>Some 3.1-specific features may not be fully supported</li> <li>We primarily target OpenAPI 3.0.x for guaranteed compatibility</li> </ul>"},{"location":"compatibility/#when-things-dont-work","title":"When Things Don't Work","text":"<p>If you encounter a schema that doesn't work with Clientele:</p> <ol> <li>Check the version: Ensure it's OpenAPI 3.0.x (not 2.0 or unusual 3.1 features)</li> <li>Try generation anyway: Sometimes validation is overly strict</li> <li>Report issues: Open a GitHub issue with your schema (or a minimal example)</li> </ol>"},{"location":"compatibility/#best-practices-for-compatibility","title":"Best Practices for Compatibility","text":""},{"location":"compatibility/#for-api-developers","title":"For API Developers","text":"<p>If you're developing an API that others will consume with Clientele:</p> <ol> <li>Use FastAPI, DRF + drf-spectacular, or Django Ninja for best results</li> <li>Provide custom <code>operationId</code> values for readable function names</li> <li>Document your schemas with descriptions and examples</li> <li>Test your OpenAPI schema with <code>clientele validate</code></li> <li>Avoid exotic schema features unless necessary</li> <li>Stick to OpenAPI 3.0.x for maximum compatibility</li> </ol>"},{"location":"compatibility/#for-client-developers","title":"For Client Developers","text":"<p>If you're consuming an API with Clientele:</p> <ol> <li>Validate first: Run <code>clientele validate</code> before generating</li> <li>Start with API server frameworks guides: If using FastAPI/DRF/Ninja, follow the specific guide</li> <li>Review generated code: Ensure it matches your expectations</li> <li>Test thoroughly: The generated client should be tested like any dependency</li> <li>Report issues: Help us improve by reporting problematic schemas</li> </ol>"},{"location":"compatibility/#summary","title":"Summary","text":"Feature Support Level Notes OpenAPI 3.0.x \u2705 Full Primary target, fully supported OpenAPI 3.1.x \u26a0\ufe0f Partial Most features work, some edge cases may not OpenAPI 2.0 \u274c None Not supported, use 3.0+ instead FastAPI \u2705 Full 100% compatibility DRF + drf-spectacular \u2705 Full Extensively tested Django Ninja \u2705 Full Native Pydantic alignment Complex schemas \u2705 Most <code>oneOf</code>, <code>anyOf</code>, <code>allOf</code>, <code>nullable</code> supported File operations \u26a0\ufe0f Limited May need manual customization Authentication \u2705 Basic/Bearer OAuth2 flows need manual token handling"},{"location":"design/","title":"\ud83c\udfa8 Design","text":""},{"location":"design/#a-brief-history-of-http-apis","title":"A brief history of HTTP APIs","text":"<p>Hello, I am Paul Hallett - a lead software engineer who has spent over 10 years fascinated by and building HTTP APIs for both massive and small tech companies.</p> <p>When I started building my first hobby project - PokeAPI - I had one issue I wanted to solve: show how important good API design is by building a \"pure\" example. PokeAPI was a huge success, and still is, with over 1 billion API requests a month, it is one of the most popular free HTTP APIs on the web.</p> <p>Around this time Swagger was being introduced. Slowly over time adoption built up. This was also around the same time the SaaS and \"API product\" boom happened - companies like Twilio, Stripe, and Sendgrid were the coolest startups in tech and their product was pure HTTP APIs. A lot of them offered Swagger schemas for their APIs.</p> <p>In 2015 Swagger was renamed to OpenAPI. Two years later the 3.0 version of finalised, with version 3.1 coming along in 2021.</p>"},{"location":"design/#openapi-client-generators","title":"OpenAPI client generators","text":"<p>Every few years I check the HTTP API landscape to see what has changed, and what new tooling is available.</p> <p>A big part of this research is seeing how far OpenAPI client generators have come.  </p> <p>Despite the heavy adoption of OpenAPI schema generators, the \"last mile\" (i.e. - generating, and using, a client library) still has a experience nowhere near the maturity as the schema generator landscape. The great thing about schema generators these days is they are seemlessly blended in - most API server frameworks, especially in the Python landscape, generate schemas as standard.</p> <p>But my experience with most client generators always falls into one of these buckets:</p> <ul> <li> <p>The generated code is difficult to read, meaning I don't fully trust it, and often leads to problems when trying to debug the code. Nearly all of the time the code is not idiomatic to Python.</p> </li> <li> <p>The generated code is often repetitive and very large, meaning it is tedious to support.</p> </li> <li> <p>You have to install a lot of extra tooling just to get started.</p> </li> </ul> <p>This experience isn't ideal, and is often such an impedance that it just isn't worth it. I would always prefer instead to take a template of my own choosing, refined from years of working with HTTP APIs, and adapt it to whatever new API I was consuming. And this isn't just my own personal opinion - in every place I have worked I have seen this - developers never using a client generator and instead opting to just roll with a custom built client.</p> <p>Just as the Python community made a great experience for schema generators, surely we could make one for client generators?</p>"},{"location":"design/#2023-and-the-start-of-clientele","title":"2023 and the start of Clientele","text":"<p>In the early part of 2023, I had to build an integration with a new HTTP API.</p> <p>So, like I did in the past, I used it as an opportunity to asses the landscape of OpenAPI client generators.</p> <p>And this was our summary at the time of writing:</p> <ul> <li> <p>API tools and providers had adopted OpenAPI very well. For example - tools like FastAPI and drf-spectacular now make it easy for the most popular python web server frameworks to publish OpenAPI schemas.</p> </li> <li> <p>There are a lot of options for generating clients. They all meet the need of \"generating a python client using the schema\". But, almost universally, they have a poor developer experience.</p> </li> </ul> <p>After evaluating many python client generators, I opted to use none of them and instead hand craft the API client myself. I used the OpenAPI schema as a source to develop the input and output objects. Then I wrote a small functional abstraction over the paths.</p> <p>Looking back over my organised, pythonic, minimal client integration, I had an idea:</p> <p>If this is the type of client I would like a client generator to produce; how hard could it be to work backwards and generate this layout?</p> <p>The schema became my input. The client I had just made became my output. I had all the parts I needed to start a project.</p> <p>This was the start of Clientele.</p>"},{"location":"design/#clientele","title":"Clientele","text":"<p>As a python developer I know what makes good, readable, idiomatic python.</p> <p>I also feel like I have a pretty good grasp on the best tools to be using in our python projects as I'm involved in the community and constantly trying out new stuff.</p> <p>By starting with a client library that I like to use, and working backwards, I was able to build a client generator that produced something that I felt that python developers actually wanted.</p> <p>But why is this the OpenAPI Python client that I think everyone should use?</p>"},{"location":"design/#strongly-typed-inputs-and-outputs","title":"Strongly-typed inputs and outputs","text":"<p>OpenAPI prides itself on being able to describe the input and output objects in its schema.</p> <p>This means you can build strongly-typed interfaces to the API. This helps to solve some common niggles when using an API - such as casting a value to a string when it should be an integer.</p> <p>With Clientele, I opted to use Pydantic to build the models from the OpenAPI schema.</p> <p>Pydantic doesn't only describe the shape of an object, it also validates the attributes. If an API sends back the wrong attributes at runtime, Pydantic will error and provide a detailed description of what went wrong. It's also super fast.</p>"},{"location":"design/#idiomatic-python","title":"Idiomatic Python","text":"<p>A lot of the client generators I tested produced a lot of obtuse and hard to read code.</p> <p>It was clear in a few cases that the client generator was built without understanding or knowledge of good Python conventions. Usually these client generators offered output in hundreds of programming languages, so they didn't dedicate any time to making the developer experience great in any of them.</p> <p>I also discovered more than one client generator that would work by reading a file at runtime. This is cool engineering, but it is impractical to use. When you develop with these clients, the available functions and objects don't exist until the code is running, and you can't use an IDE's autocomplete feature.</p> <p>Clientele sets out to be as pythonic as possible. </p> <p>It uses modern tools, idiomatic conventions, and provide some helpful bonuses like Ruff auto-formatting.</p>"},{"location":"design/#easy-to-understand","title":"Easy to understand","text":"<p>Eventually a developer will need to do some debugging, and sometimes they'll need to do it in the generated client code.</p> <p>A lot of the other client generators make obscure or obtuse code that is hard to pick apart and debug.</p> <p>Now, there's a suggestion that developers shouldn't have to look at this, and that's fair. </p> <p>But the reality doesn't match that expectation. Personally, I like to know what generated code is doing. I want to trust that it will work, and that I can adapt around it if needed. An interesting quirk of any code generator is you can't always inspect the source when evaluating whether to use it. Any other tool - you'd just go to GitHub and have a read around, but you can't with code generators.</p> <p>So the code that is generated needs to be easy to understand.</p> <p>Clientele doesn't do any tricks, or magic, or anything complex. The generated code has documentation and is designed to be readable. It is only a small layer on top of already well established tools, such as HTTPX.</p> <p>In fact, I have some generated clients in our project repository so you can see what it looks like. We even have example tests for you to learn how to integrate with it.</p> <p>It is that way because I know you will need to inspect it in the future. I want you to know that this is a sane and sensible tool.</p>"},{"location":"design/#supporting-python-api-frameworks","title":"Supporting Python API Frameworks","text":"<p>The python ecosystem for API server frameworks is very rich and mature. I love the options we have to build APIs with. I wanted to focus on supporting this ecosystem specifically because of how much I love the tooling, but also because it means I can focus on doing one thing great: client generation that specifically supports Python API server frameworks.</p> <p>You'll see in the project documentation that we explain how to use common API server frameworks like FastAPI, Django REST Framework and Django-ninja, and the project even has client and server examples to help demonstrate and prove it's usefulness.</p>"},{"location":"design/#clientele-api","title":"Clientele API","text":"<p>The best way to learn about the beginning of the clientele API is to read this blog post.</p>"},{"location":"examples/","title":"\ud83d\uddfa\ufe0f Tour of a Generated Client","text":"<p>Warning</p> <p>This is for the \"barebones\" style clients. Please see clientele api overview if you are using Clientele API.</p> <p>When you generate a client with Clientele, it creates several files that work together to provide a complete HTTP API client. </p> <p>This guide explains each file's purpose and which ones you'll interact with as a developer.</p>"},{"location":"examples/#what-gets-generated","title":"What gets generated?","text":"<p>Running <code>clientele generate</code> creates this file structure:</p> <pre><code>my_client/\n    MANIFEST.md\n    client.py\n    config.py\n    http.py\n    schemas.py\n</code></pre> <p>Let's explore each file.</p>"},{"location":"examples/#manifestmd","title":"MANIFEST.md","text":"<p>Purpose: Metadata and regeneration tracking</p> <p>The <code>MANIFEST.md</code> file contains metadata about your generated client:</p> <ul> <li>The Clientele version used to generate it</li> <li>The OpenAPI version of the source schema</li> <li>The API version</li> <li>The exact command to regenerate the client</li> </ul> <p>Should you edit it? No, this file is regenerated each time.</p> <p>Example:</p> <pre><code># Manifest\n\nGenerated with https://github.com/phalt/clientele\n\nAPI VERSION: 1.0.0\nOPENAPI VERSION: 3.0.2\nCLIENTELE VERSION: 1.4.3\n\nRegenerate using this command:\n\nclientele generate -f openapi.json -o my_client/ --regen t\n</code></pre> <p>This file is particularly useful when you need to regenerate the client after API changes. See Regenerating for details.</p>"},{"location":"examples/#clientpy","title":"client.py","text":"<p>Purpose: API endpoint functions or class</p> <p>This is the main file you'll import and use. </p> <p>It contains a function (or method if using <code>generate-class</code>) for each API endpoint.</p> <p>Should you edit it? No, this file is regenerated each time. Your usage code should import from it, not modify it.</p> <p>Function-based client example:</p> my_client/client.py<pre><code>from my_client import http, schemas\n\n\ndef get_user(user_id: int) -&gt; schemas.User:\n    \"\"\"Get user by ID\"\"\"\n    response = http.get(url=f\"/users/{user_id}\")\n    return http.handle_response(get_user, response)\n\n\ndef create_user(data: schemas.CreateUserRequest) -&gt; schemas.User:\n    \"\"\"Create a new user\"\"\"\n    response = http.post(url=\"/users\", data=data.model_dump())\n    return http.handle_response(create_user, response)\n</code></pre> <p>Class-based client example:</p> my_client/client.py<pre><code>from my_client import config, http, schemas\n\n\nclass Client:\n    \"\"\"API Client for making requests\"\"\"\n\n    def __init__(self, config: config.Config | None = None):\n        self.config = config or config.Config()\n        self._http_client = http.HTTPClient(self.config)\n\n    def get_user(self, user_id: int) -&gt; schemas.User:\n        \"\"\"Get user by ID\"\"\"\n        response = self._http_client.get(url=f\"/users/{user_id}\")\n        return http.handle_response(self.get_user, response)\n</code></pre> <p>Each function/method is fully typed and includes:</p> <ul> <li>Type hints for all parameters</li> <li>Return type annotations with all possible response types</li> <li>The endpoint's description as a docstring</li> </ul>"},{"location":"examples/#schemaspy","title":"schemas.py","text":"<p>Purpose: Pydantic models for requests and responses</p> <p>The <code>schemas.py</code> file contains Pydantic models for all request bodies, response bodies, and enums defined in your OpenAPI schema.</p> <p>Should you edit it? No, this file is regenerated each time. You use these schemas in your code but don't modify them.</p> <p>Example:</p> my_client/schemas.py<pre><code>import pydantic\nfrom enum import Enum\n\n\nclass User(pydantic.BaseModel):\n    id: int\n    username: str\n    email: str\n\n\nclass CreateUserRequest(pydantic.BaseModel):\n    username: str\n    email: str\n    password: str\n\n\nclass UserRole(str, Enum):\n    ADMIN = \"ADMIN\"\n    USER = \"USER\"\n    GUEST = \"GUEST\"\n</code></pre> <p>These schemas provide:</p> <ul> <li>Type safety: Your IDE can autocomplete fields and catch type errors</li> <li>Validation: Pydantic validates data at runtime</li> <li>Serialisation: Easy conversion to/from JSON</li> </ul> <p>Usage example:</p> <pre><code>from my_client import client, schemas\n\n# Create request data with validation\nuser_data = schemas.CreateUserRequest(\n    username=\"alice\",\n    email=\"alice@example.com\",\n    password=\"secret123\"\n)\n\n# Get a validated response\nuser = client.create_user(data=user_data)\nassert isinstance(user, schemas.User)\n</code></pre>"},{"location":"examples/#configpy","title":"config.py","text":"<p>Purpose: Client configuration and settings</p> <p>The <code>config.py</code> file contains a <code>Config</code> class that manages all client settings like API URL, authentication, timeouts, and HTTP behavior.</p> <p>Should you edit it? Yes! This is the one file that won't be overwritten when you regenerate. Customise it to suit your needs.</p> <p>Example:</p> my_client/config.py<pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Config(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        case_sensitive=False,\n    )\n\n    api_base_url: str = \"http://localhost\"\n    bearer_token: str = \"token\"\n    timeout: float = 5.0\n    verify_ssl: bool = True\n    # ... more settings\n\n\nconfig = Config()\n</code></pre> <p>The <code>Config</code> class uses pydantic-settings to load values from environment variables or <code>.env</code> files.</p> <p>For detailed configuration options and examples, see the OpenAPI Configuration Guide.</p>"},{"location":"examples/#httppy","title":"http.py","text":"<p>Purpose: HTTP client implementation and response handling</p> <p>This file contains the low-level HTTP logic: making requests with <code>httpx</code>, handling responses, parsing errors, and managing the response-to-schema mapping.</p> <p>Should you edit it? No. This file is regenerated each time and is not intended to be used by developers. You are welcome to read it and understand how it works. There isn't any magic.</p> <p>What's inside:</p> <ul> <li><code>get()</code>, <code>post()</code>, <code>put()</code>, <code>delete()</code>, <code>patch()</code> functions for making HTTP requests</li> <li><code>handle_response()</code> for converting HTTP responses to Pydantic models</li> <li><code>APIException</code> class for unexpected response codes</li> <li>Response code mapping for each endpoint</li> <li>HTTP client initialisation with your config settings</li> </ul> <p>You only need to interact with this file indirectly when handling API exceptions. See the Exception Handling guide for details.</p>"},{"location":"examples/#summary","title":"Summary","text":"<p>Here's a quick reference of what to do with each file:</p> File Purpose Edit? Import? <code>MANIFEST.md</code> Metadata and regeneration info \u274c No \u274c No <code>client.py</code> API functions/class \u274c No \u2705 Yes <code>schemas.py</code> Pydantic models \u274c No \u2705 Yes <code>config.py</code> Configuration \u2705 Yes \u2705 Yes <code>http.py</code> HTTP implementation \u274c No \u26a0\ufe0f Rarely <p>For more information:</p> <ul> <li>OpenAPI client scaffolder - How to generate clients</li> <li>OpenAPI Configuration - Configure the client</li> <li>Authentication - Set up authentication</li> <li>Exception Handling - Handle API exceptions</li> <li>Testing - Write tests for your client</li> </ul>"},{"location":"exceptions/","title":"\ud83d\udea8 Exception Handling","text":"<p>Clientele wll handle unexpected API responses by raising an <code>APIException</code>.</p>"},{"location":"exceptions/#when-apiexception-is-raised","title":"When APIException is Raised","text":"<p>The <code>APIException</code> is raised when the API returns a response code that doesn't match any of the expected response codes defined in the OpenAPI schema for that endpoint.</p> <p>Each API function has a mapping of expected response codes to response types. If the actual response code isn't in this mapping, Clientele raises an <code>APIException</code> instead of trying to parse the response.</p>"},{"location":"exceptions/#catching-apiexception","title":"Catching APIException","text":"<p>Import <code>APIException</code> from your client's <code>http</code> module:</p> <pre><code>from my_client import client, http\n\ntry:\n    user = client.get_user(user_id=999)\nexcept http.APIException as e:\n    # Handle unexpected response\n    print(f\"Unexpected status: {e.response.status_code}\")\n    print(f\"Response body: {e.response.text}\")\n</code></pre>"},{"location":"exceptions/#exception-attributes","title":"Exception Attributes","text":"<p>The <code>APIException</code> provides access to:</p> <ul> <li><code>response</code>: The raw <code>httpx.Response</code> object for debugging</li> <li><code>reason</code>: A string explaining why the exception was raised</li> </ul> <pre><code>try:\n    user = client.get_user(user_id=999)\nexcept http.APIException as e:\n    print(f\"Reason: {e.reason}\")\n    print(f\"Status: {e.response.status_code}\")\n    print(f\"Headers: {e.response.headers}\")\n    print(f\"Body: {e.response.text}\")\n</code></pre>"},{"location":"exceptions/#common-scenarios","title":"Common Scenarios","text":""},{"location":"exceptions/#server-error-500","title":"Server Error (500)","text":"<p>If the API returns a 500 error and it's not defined in the schema:</p> <pre><code>try:\n    result = client.create_user(data=user_data)\nexcept http.APIException as e:\n    if e.response.status_code &gt;= 500:\n        # Server error - retry logic\n        logger.error(f\"Server error: {e.response.status_code}\")\n</code></pre>"},{"location":"exceptions/#unexpected-client-error","title":"Unexpected Client Error","text":"<p>If the API returns an error code you didn't expect:</p> <pre><code>try:\n    result = client.delete_user(user_id=123)\nexcept http.APIException as e:\n    if e.response.status_code == 403:\n        # Not defined in schema, but API returned it\n        logger.warning(\"Permission denied\")\n    elif e.response.status_code == 404:\n        logger.info(\"User not found\")\n</code></pre>"},{"location":"exceptions/#best-practices","title":"Best Practices","text":"<ol> <li>Always catch APIException when calling API functions that might return unexpected responses</li> <li>Log the full response for debugging - it contains valuable information</li> <li>Check the OpenAPI schema if you consistently get <code>APIException</code> for a specific endpoint - the schema might be incomplete</li> <li>Use pattern matching (Python 3.10+) for clean error handling:</li> </ol> <pre><code>try:\n    result = client.get_user(user_id=999)\nexcept http.APIException as e:\n    match e.response.status_code:\n        case 404:\n            print(\"User not found\")\n        case 500:\n            print(\"Server error\")\n        case _:\n            print(f\"Unexpected error: {e.response.status_code}\")\n</code></pre>"},{"location":"explore/","title":"\ud83d\uddfa\ufe0f API Explorer","text":"<p>The <code>explore</code> command launches an interactive REPL that lets you explore and test API operations without writing any code. It's perfect for API discovery, testing, and debugging.</p> <p></p>"},{"location":"explore/#usage-modes","title":"Usage Modes","text":""},{"location":"explore/#explore-an-existing-client","title":"Explore an Existing Client","text":"<p>If you've already generated a client, you can explore it directly:</p> <pre><code>clientele explore -c pokeapi_client/\n</code></pre>"},{"location":"explore/#explore-from-a-schema-file","title":"Explore from a Schema File","text":"<p>Generate a temporary client and explore it in one command:</p> <pre><code>clientele explore -f pokeapi_openapi.yml\n</code></pre> <p>Clientele will:</p> <ol> <li>Generate a client in a temporary directory from the schema</li> <li>Load it into the REPL</li> <li>Clean up the temporary files when you exit</li> </ol>"},{"location":"explore/#explore-from-a-schema-url","title":"Explore from a Schema URL","text":"<p>You can also explore directly from a URL:</p> <pre><code>clientele explore -u https://raw.githubusercontent.com/PokeAPI/pokeapi/master/openapi.yml\n</code></pre>"},{"location":"explore/#interactive-features","title":"Interactive Features","text":"<p>Once inside the REPL, you have access to several powerful features:</p>"},{"location":"explore/#tab-autocomplete","title":"Tab Autocomplete","text":"<p>Press TAB to autocomplete:</p> <pre><code>&gt;&gt;&gt; api_v2_pokemon_  &lt;TAB&gt;\napi_v2_pokemon_list                 pokemon_read\napi_v2_pokemon_encounter_list       pokemon_form_list\n</code></pre>"},{"location":"explore/#execute-operations","title":"Execute Operations","text":"<p>Make API calls using the available operations</p> <pre><code># Simple operation with no parameters\n&gt;&gt;&gt; api_v2_ability_list()\n\n# Operation with parameters\n&gt;&gt;&gt; api_v2_pokemon_list(limit=5, offset=0)\n\n# Operation with a specific ID\n&gt;&gt;&gt; api_v2_pokemon_retrieve(id=25)\n</code></pre> <p>The REPL will:</p> <ul> <li>Validate your arguments against the operation signature</li> <li>Execute the API call</li> <li>Display timing information</li> <li>Format the response with syntax highlighting</li> </ul>"},{"location":"explore/#inspect-schemas","title":"Inspect Schemas","text":"<p>You can inspect Pydantic schemas by simply typing their name (without parentheses):</p> <pre><code>&gt;&gt;&gt; UserResponse\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 UserResponse \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 User response model containing user information.                           \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\nFields:\n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Field   \u2503 Type   \u2503 Required \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 id      \u2502 int    \u2502 \u2713        \u2502\n\u2502 name    \u2502 str    \u2502 \u2713        \u2502\n\u2502 email   \u2502 str    \u2502 \u2713        \u2502\n\u2502 active  \u2502 bool   \u2502 \u2717        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTotal: 4 fields\n</code></pre> <p>This displays: - The schema's docstring (if it has one) - All fields with their types - Whether each field is required or optional</p> <p>You can also use the <code>/schemas</code> command to list all available schemas or view specific schema details:</p> <pre><code># List all schemas\n&gt;&gt;&gt; /schemas\n\n# View a specific schema\n&gt;&gt;&gt; /schemas UserResponse\n</code></pre>"},{"location":"explore/#special-commands","title":"Special Commands","text":"<p>Commands starting with <code>/</code> provide additional functionality:</p> <p><code>/list</code> or <code>/operations</code> - List all available operations in a table:</p> <pre><code>&gt;&gt;&gt; /list\nAvailable Operations\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Operation                    \u2502 Method \u2502 Description                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 ability_list                 \u2502 GET    \u2502 List abilities              \u2502\n\u2502 ability_read                 \u2502 GET    \u2502 Get ability by ID or name   \u2502\n\u2502 pokemon_list                 \u2502 GET    \u2502 List pokemon                \u2502\n\u2502 pokemon_read                 \u2502 GET    \u2502 Get pokemon by ID or name   \u2502\n\u2502 berry_list                   \u2502 GET    \u2502 List berries                \u2502\n\u2502 move_list                    \u2502 GET    \u2502 List moves                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nTotal: 6 operations\n</code></pre> <p><code>/help</code> - Show help message with usage information:</p> <pre><code>&gt;&gt;&gt; /help\n\nClientele Interactive API Explorer\n\nUsage:\n  \u2022 Type operation names and press TAB to autocomplete\n  \u2022 Execute operations with Python-like syntax: operation_name(param=value)\n  \u2022 Use UP/DOWN arrows to navigate command history\n\nSpecial Commands:\n  /list, /operations  - List all available operations\n  /help                  - Show this help message\n  /exit, /quit         - Exit the REPL\n\nExamples:\n  get_users()                           - Execute operation without parameters\n  get_user(user_id=\"123\")               - Execute with parameters\n  create_user(data={\"name\": \"John\"})   - Pass complex data\n</code></pre> <p><code>/exit</code> or <code>/quit</code> - Exit the REPL (you can also use Ctrl+D):</p> <pre><code>&gt;&gt;&gt; /exit\nGoodbye! \ud83d\udc4b\n</code></pre>"},{"location":"explore/#command-history","title":"Command History","text":"<p>Navigate your command history with UP and DOWN arrow keys. Your history is saved to <code>~/.clientele_history</code> and persists between sessions.</p>"},{"location":"explore/#config","title":"Config","text":"<p>You can inspect and modify the config during a CLI session:</p> <pre><code># Show configuration values\n&gt;&gt;&gt; /config\nCurrent Configuration              \n\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 Setting      \u2503 Value              \u2503 Source    \u2503\n\u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529\n\u2502 base_url     \u2502 https://pokeapi.co \u2502 config.py \u2502\n\u2502 bearer_token \u2502 token              \u2502 config.py \u2502\n\u2502 user_key     \u2502 user               \u2502 config.py \u2502\n\u2502 pass_key     \u2502 password           \u2502 config.py \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nDebug Mode: OFF\n\n# Update a config value\n&gt;&gt;&gt; /config set base_url mynewurl.com\n\u2713 Set base_url = mynewurl.com\nThis override applies only to the current REPL session\n</code></pre> <p>Config changes only persist during the CLI session.</p>"},{"location":"explore/#debug","title":"Debug","text":"<p>You can enable debug mode to print useful information when using explore:</p> <pre><code># Show debug state\n&gt;&gt;&gt; /debug\nDebug Mode: OFF\n\nUse '/debug on' or '/debug off' to toggle debug mode\n# Update debug state\n&gt;&gt;&gt; /debug on\n\u2713 Debug mode enabled\nHTTP requests and responses will be logged\n</code></pre>"},{"location":"explore/#response-formatting","title":"Response Formatting","text":"<p>The explore command automatically formats responses for readability:</p> <p>JSON Responses - Syntax-highlighted with proper indentation:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Alice\",\n  \"email\": \"alice@example.com\"\n}\n</code></pre> <p>Timing Information - Every request shows execution time:</p> <pre><code>\u2713 Success in 0.45s\n</code></pre> <p>Error Handling - Errors are displayed in a clear, formatted panel:</p> <pre><code>\u2717 Error in 0.12s\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Error \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 ValueError: Missing required parameter: user_id     \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"explore/#compatibility","title":"Compatibility","text":"<p>The explore command works with:</p> <ul> <li>\u2705 Standard function-based clients (<code>generate</code>)</li> <li>\u2705 Class-based clients (<code>generate-class</code>)</li> <li>\u2705 Both sync and async clients</li> <li>\u2705 Clients with authentication configured</li> <li>\u2705 All OpenAPI 3.0+ schemas</li> </ul>"},{"location":"explore/#limitations","title":"Limitations","text":"<ul> <li>The explore command is interactive only - not suitable for CI/CD or automated testing</li> <li>Operations are executed against the actual API - be careful with destructive operations</li> <li>For automated testing, use the generated client directly in your test suite</li> </ul>"},{"location":"install/","title":"\ud83d\ude80 Install","text":""},{"location":"install/#uv","title":"uv","text":"<pre><code>uv tool install clientele\n</code></pre>"},{"location":"install/#pip","title":"pip","text":"<pre><code>pip install clientele\n</code></pre> <p>Once installed, you can run <code>clientele version</code> to make sure you have the latest version:</p> <pre><code>&gt; clientele version\nclientele 1.4.3\n</code></pre>"},{"location":"install/#next-steps","title":"Next steps","text":"<ul> <li>Clientele API guide to write your own API client</li> <li>OpenAPI client scaffolder to scaffold an API client from an OpenAPI schema</li> <li>API Explorer to explore an API through an interactive REPL</li> <li>API server integration to learn how to integrate with popular Python API servers</li> </ul>"},{"location":"openapi-authentication/","title":"Authentication","text":"<p>Warning</p> <p>This is for the \"barebones\" style clients. Please see api authentication if you are using Clientele framework.</p> <p>Clientele supports multiple authentication methods through the client configuration.</p>"},{"location":"openapi-authentication/#supported-authentication-types","title":"Supported Authentication Types","text":""},{"location":"openapi-authentication/#bearer-token","title":"Bearer Token","text":"<p>Bearer token authentication adds an <code>Authorization</code> header with a token to all requests.</p> <p>Configuration:</p> <pre><code>from my_client import config\n\n# Via code\ncfg = config.Config(bearer_token=\"your-secret-token\")\n\n# Via environment variable\nexport BEARER_TOKEN=\"your-secret-token\"\n</code></pre> <p>What happens under the hood:</p> <p>Clientele sets the <code>Authorization</code> header on every request:</p> <pre><code>Authorization: Bearer your-secret-token\n</code></pre>"},{"location":"openapi-authentication/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<p>Basic authentication uses a username and password.</p> <p>Configuration:</p> <pre><code>from my_client import config\n\n# Via code\ncfg = config.Config(\n    user_key=\"username\",\n    pass_key=\"password\"\n)\n\n# Via environment variables\nexport USER_KEY=\"username\"\nexport PASS_KEY=\"password\"\n</code></pre> <p>What happens under the hood:</p> <p>Clientele encodes the credentials and sets the <code>Authorization</code> header:</p> <pre><code>Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=\n</code></pre> <p>Optional authentication:</p> <p>If both <code>user_key</code> and <code>pass_key</code> are empty or <code>None</code>, authentication is disabled:</p> <pre><code>cfg = config.Config(user_key=\"\", pass_key=\"\")  # No auth\n</code></pre>"},{"location":"openapi-authentication/#custom-headers","title":"Custom Headers","text":"<p>For APIs that use custom authentication headers (like API keys), use <code>additional_headers</code>:</p> <p>Configuration:</p> <pre><code>from my_client import config\n\ncfg = config.Config(\n    additional_headers={\n        \"X-API-Key\": \"your-api-key\",\n        \"X-Client-ID\": \"your-client-id\"\n    }\n)\n\n# Via environment (requires custom config.py setup)\nexport ADDITIONAL_HEADERS='{\"X-API-Key\": \"your-api-key\"}'\n</code></pre> <p>What happens under the hood:</p> <p>These headers are added to every request alongside any authentication headers.</p>"},{"location":"openapi-authentication/#multiple-authentication-methods","title":"Multiple Authentication Methods","text":"<p>Some APIs support multiple authentication methods. Configure all applicable options:</p> <pre><code>cfg = config.Config(\n    bearer_token=\"fallback-token\",\n    additional_headers={\n        \"X-API-Key\": \"preferred-key\"\n    }\n)\n</code></pre> <p>Both headers will be sent with each request.</p>"},{"location":"openapi-authentication/#environment-specific-configuration","title":"Environment-Specific Configuration","text":""},{"location":"openapi-authentication/#development","title":"Development","text":"<pre><code># config.py\nclass Config(BaseSettings):\n    api_base_url: str = \"http://localhost:8000\"\n    bearer_token: str = \"dev-token-12345\"\n</code></pre>"},{"location":"openapi-authentication/#production","title":"Production","text":"<pre><code># .env file\nAPI_BASE_URL=https://api.production.com\nBEARER_TOKEN=prod-***-secret-token-***\n</code></pre> <pre><code># Code stays the same\nfrom my_client import config\nclient = Client(config=config.config)  # Loads from environment\n</code></pre>"},{"location":"openapi-authentication/#class-based-clients","title":"Class-Based Clients","text":"<p>For class-based clients, pass the configured object when creating the client:</p> <pre><code>from my_client.client import Client\nfrom my_client import config\n\n# Custom config\ncfg = config.Config(\n    api_base_url=\"https://api.example.com\",\n    bearer_token=\"secret-token\"\n)\n\nclient = Client(config=cfg)\n</code></pre>"},{"location":"openapi-authentication/#function-based-clients","title":"Function-Based Clients","text":"<p>For function-based clients, update the singleton config:</p> <pre><code>from my_client import config\n\n# Update the global config\nconfig.config = config.Config(\n    api_base_url=\"https://api.example.com\",\n    bearer_token=\"secret-token\"\n)\n\n# All function calls now use this config\nfrom my_client import client\nresponse = client.get_user(user_id=123)\n</code></pre>"},{"location":"openapi-authentication/#debugging-authentication","title":"Debugging Authentication","text":"<p>If you're getting authentication errors:</p> <ol> <li>Check the headers being sent:</li> </ol> <pre><code>from my_client import http\n\n# The headers are stored in http.client_headers\nprint(http.client_headers)\n</code></pre> <ol> <li>Verify the token format matches what the API expects</li> <li>Test manually with curl to confirm the authentication works:</li> </ol> <pre><code>curl -H \"Authorization: Bearer your-token\" https://api.example.com/endpoint\n</code></pre>"},{"location":"openapi-authentication/#see-also","title":"See Also","text":"<ul> <li>OpenAPI Configuration Guide - Full list of configuration options for OpenAPI clients</li> <li>Exception Handling - Handle authentication errors</li> </ul>"},{"location":"openapi-cli/","title":"\ud83c\udfd7\ufe0f Client Scaffolder","text":"<p>Note</p> <p>You can type <code>clientele COMMAND --help</code> at anytime to see information about the available arguments.</p>"},{"location":"openapi-cli/#openapi-scaffold-styles","title":"OpenAPI scaffold styles","text":"<p>Clientele offers four styles of client generators.</p>"},{"location":"openapi-cli/#clientele-api-generators","title":"Clientele API generators","text":"<p>These generators will produce scaffolding that uses the clientele API:</p> <ol> <li><code>generate-basic</code> - Basic scaffolding with no generated code.</li> <li><code>scaffold-api</code> - A fully scaffolded client integration either async or sync.</li> </ol>"},{"location":"openapi-cli/#barebones-generators","title":"Barebones generators","text":"<p>Clientele can provide generated http clients that do not use clientele API and instead provide a <code>http.py</code> package that manages most of the core http request/response logic.</p> <p>Warning</p> <p>These options are considered deprecated from clientele version 2.0.0 and will not be supported in future versions.</p> <ol> <li><code>generate</code> - a barebones function-based client either as async or sync.</li> <li><code>generate-class</code> - a barebones class-based client either as async or sync.</li> </ol>"},{"location":"openapi-cli/#scaffold-api","title":"scaffold-api","text":"<p>The <code>scaffold-api</code> command can be used to scaffold an entire API client integration from an OpenAPI schema.</p> <p>This command will generate:</p> <ul> <li>All available operations in the <code>operations</code> of the OpenAPI spec as fully typed, decorated functions.</li> <li>All available <code>schemas</code> in the <code>schemas</code> of the OpenAPI spec as Pyantic models.</li> </ul> <pre><code>clientele scaffold-api -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre>"},{"location":"openapi-cli/#from-a-url","title":"From a URL","text":"<p>Use the <code>-u</code> or <code>--url</code> argument.</p> <p><code>-o</code> or <code>--output</code> is the target directory for the generated client.</p> <pre><code>clientele scaffold-api -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre>"},{"location":"openapi-cli/#from-a-file","title":"From a file","text":"<p>Alternatively you can provide a local file using the <code>-f</code> or <code>--file</code> argument.</p> <pre><code>clientele scaffold-api -f path/to/file.json -o my_client/\n</code></pre>"},{"location":"openapi-cli/#asyncio","title":"Async.io","text":"<p>If you prefer an asyncio client, just pass <code>--asyncio</code> to your command.</p> <pre><code>clientele scaffold-api -f path/to/file.json -o my_client/ --asyncio\n</code></pre>"},{"location":"openapi-cli/#generate-basic","title":"generate-basic","text":"<p>The <code>generate-basic</code> command can be used to scaffold a basic file structure for an HTTP client.</p> <p>It does not require an OpenAPI schema.</p> <p>It will generate some basic imports and a sample configuration class.</p> <p>This command is there for when have an HTTP API without an OpenAPI schema, but you want to keep a consistent file structure with other Clientele API clients.</p> <pre><code>clientele generate-basic -o my_client/\n</code></pre>"},{"location":"openapi-cli/#generate","title":"<code>generate</code>","text":"<p>Warning</p> <p>This option is considered deprecated from clientele version 2.0.0 and will not be supported in future versions.</p> <p>Generate a barebones function-based Python HTTP Client from an OpenAPI Schema.</p> <p>It accepts the same arguments as <code>scaffold-api</code>.</p>"},{"location":"openapi-cli/#generate-class","title":"<code>generate-class</code>","text":"<p>Warning</p> <p>This option is considered deprecated from clientele version 2.0.0 and will not be supported in future versions.</p> <p>Generate a barebones class-based Python HTTP Client from an OpenAPI Schema. </p> <p>This generator creates a <code>Client</code> class object with methods for each API endpoint instead of functions in a module.</p>"},{"location":"openapi-cli/#usage","title":"Usage","text":"<p>The <code>generate-class</code> command accepts the same arguments as <code>generate</code>:</p> <pre><code>clientele generate-class -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre> <p>It accepts the same arguments as <code>scaffold-api</code>.</p>"},{"location":"openapi-configuration/","title":"\u2699\ufe0f Barebones Configuration","text":"<p>Warning</p> <p>This is for the \"barebones\" style clients. Please see api configuration if you are using Clientele framework.</p> <p>Both function-based and class-based clients support extensive configuration options to customize HTTP client behavior using pydantic-settings.</p>"},{"location":"openapi-configuration/#configuration-options","title":"Configuration Options","text":"<p>All generated clients support the following configuration options:</p>"},{"location":"openapi-configuration/#authentication","title":"Authentication","text":"<ul> <li><code>api_base_url</code>: Base URL for the API (default: <code>\"http://localhost\"</code>)</li> <li><code>user_key</code>: Username for HTTP Basic authentication (default: <code>\"user\"</code>)</li> <li><code>pass_key</code>: Password for HTTP Basic authentication (default: <code>\"password\"</code>)</li> <li><code>bearer_token</code>: Token for HTTP Bearer authentication (default: <code>\"token\"</code>)</li> <li><code>additional_headers</code>: Additional headers to include in all requests (default: <code>{}</code>)</li> </ul> <p>Optional Authentication</p> <p>For clients with HTTP Basic authentication, if both <code>user_key</code> and <code>pass_key</code> are empty or <code>None</code>, authentication will be disabled. This allows you to optionally disable authentication when needed.</p>"},{"location":"openapi-configuration/#http-behavior","title":"HTTP Behavior","text":"<ul> <li><code>timeout</code>: Request timeout in seconds (default: <code>5.0</code>)</li> <li><code>follow_redirects</code>: Whether to automatically follow HTTP redirects (default: <code>False</code>)</li> <li><code>max_redirects</code>: Maximum number of redirects to follow (default: <code>20</code>)</li> </ul>"},{"location":"openapi-configuration/#security","title":"Security","text":"<ul> <li><code>verify_ssl</code>: Whether to verify SSL certificates (default: <code>True</code>)</li> </ul>"},{"location":"openapi-configuration/#performance","title":"Performance","text":"<ul> <li><code>http2</code>: Whether to enable HTTP/2 support (default: <code>False</code>)</li> <li><code>limits</code>: Connection pool limits via <code>httpx.Limits</code> (default: <code>None</code>)</li> <li><code>transport</code>: Custom transport via <code>httpx.HTTPTransport</code> or <code>httpx.AsyncHTTPTransport</code> (default: <code>None</code>)</li> </ul>"},{"location":"openapi-configuration/#function-based-client-configuration","title":"Function-Based Client Configuration","text":"<p>Function-based clients use a <code>Config</code> object powered by pydantic-settings that automatically loads values from environment variables:</p> <pre><code># In your generated client's config.py file\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass Config(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"ignore\",\n    )\n\n    api_base_url: str = \"http://localhost\"\n    bearer_token: str = \"token\"\n    timeout: float = 5.0\n    follow_redirects: bool = False\n    verify_ssl: bool = True\n    http2: bool = False\n    # ... other configuration options\n\n# Create a singleton instance\nconfig = Config()\n</code></pre>"},{"location":"openapi-configuration/#setting-values","title":"Setting Values","text":"<p>There are three ways to configure function-based clients:</p>"},{"location":"openapi-configuration/#1-environment-variables-recommended-for-production","title":"1. Environment Variables (Recommended for Production)","text":"<pre><code>export API_BASE_URL=\"https://api.production.com\"\nexport BEARER_TOKEN=\"your-secret-token\"\nexport TIMEOUT=30.0\nexport HTTP2=true\nexport FOLLOW_REDIRECTS=true\n</code></pre>"},{"location":"openapi-configuration/#2-direct-instantiation-for-testingdevelopment","title":"2. Direct Instantiation (For Testing/Development)","text":"<pre><code># Modify the default values in config.py\nfrom my_client import config\n\nconfig.config = config.Config(\n    api_base_url=\"https://api.example.com\",\n    bearer_token=\"my-token\",\n    timeout=30.0,\n    http2=True\n)\n</code></pre>"},{"location":"openapi-configuration/#3-env-file-requires-python-dotenv","title":"3. .env File (Requires python-dotenv)","text":"<pre><code># .env file in your project root\nAPI_BASE_URL=https://api.example.com\nBEARER_TOKEN=my-token\nTIMEOUT=30.0\nVERIFY_SSL=false\n</code></pre>"},{"location":"openapi-configuration/#4-custom-environment-variable-names","title":"4. Custom Environment Variable Names","text":"<p>If the default environment variable names are too generic for your use case, you can customize them using pydantic's <code>Field</code> with the <code>validation_alias</code> parameter:</p> <pre><code># In your generated client's config.py file\nfrom pydantic import Field\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\nclass Config(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_file=\".env\",\n        env_file_encoding=\"utf-8\",\n        case_sensitive=False,\n        extra=\"ignore\",\n    )\n\n    api_base_url: str = Field(\n        default=\"http://localhost\",\n        validation_alias=\"MY_APP_API_BASE_URL\"\n    )\n    bearer_token: str = Field(\n        default=\"token\",\n        validation_alias=\"MY_APP_BEARER_TOKEN\"\n    )\n    timeout: float = Field(\n        default=5.0,\n        validation_alias=\"MY_APP_TIMEOUT\"\n    )\n    # ... other configuration options\n\nconfig = Config()\n</code></pre> <p>Now you can use custom environment variable names:</p> <pre><code>export MY_APP_API_BASE_URL=\"https://api.production.com\"\nexport MY_APP_BEARER_TOKEN=\"your-secret-token\"\nexport MY_APP_TIMEOUT=30.0\n</code></pre> <p>This is particularly useful when:</p> <ul> <li>You have multiple API clients in the same application</li> <li>You want to avoid naming conflicts with other environment variables</li> <li>Your organization has specific naming conventions for environment variables</li> </ul>"},{"location":"openapi-configuration/#class-based-client-configuration","title":"Class-Based Client Configuration","text":"<p>Class-based clients use the same <code>Config</code> class with the same pydantic-settings support. Pass configuration options when creating the client:</p> <pre><code>from my_client.client import Client\nfrom my_client import config\n\n# From environment variables\ncfg = config.Config()  # Automatically loads from env vars\nclient = Client(config=cfg)\n\n# Or with explicit values\ncustom_config = config.Config(\n    api_base_url=\"https://api.production.com\",\n    bearer_token=\"your-api-token\",\n    timeout=30.0,\n    follow_redirects=True,\n    verify_ssl=True,\n    http2=True,\n    max_redirects=10,\n)\n\nclient = Client(config=custom_config)\n</code></pre>"},{"location":"openapi-configuration/#configuration-examples","title":"Configuration Examples","text":""},{"location":"openapi-configuration/#increase-timeout-for-slow-apis","title":"Increase Timeout for Slow APIs","text":"<pre><code># Function-based client (via environment variable)\nexport TIMEOUT=60.0\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(timeout=60.0)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(timeout=60.0)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"openapi-configuration/#enable-http2-for-better-performance","title":"Enable HTTP/2 for Better Performance","text":"<pre><code># Function-based client (via environment variable)\nexport HTTP2=true\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(http2=True)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(http2=True)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"openapi-configuration/#development-environment-disable-ssl-verification","title":"Development Environment (Disable SSL Verification)","text":"<p>Warning</p> <p>Only disable SSL verification in development environments. Never disable it in production!</p> <pre><code># Function-based client (via environment variable)\nexport VERIFY_SSL=false\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(verify_ssl=False)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(verify_ssl=False)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"openapi-configuration/#follow-redirects","title":"Follow Redirects","text":"<pre><code># Function-based client (via environment variables)\nexport FOLLOW_REDIRECTS=true\nexport MAX_REDIRECTS=5\n\n# Function-based client (via code)\nfrom my_client import config\nconfig.config = config.Config(follow_redirects=True, max_redirects=5)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(follow_redirects=True, max_redirects=5)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"openapi-configuration/#configure-connection-pool-limits","title":"Configure Connection Pool Limits","text":"<p>Control connection pooling behavior with <code>httpx.Limits</code>:</p> <pre><code>import httpx\n\n# Function-based client\n# Note: Complex objects like httpx.Limits must be set in code, not env vars\nfrom my_client import config\nconfig.config = config.Config(\n    limits=httpx.Limits(\n        max_keepalive_connections=10,\n        max_connections=20,\n        keepalive_expiry=5.0\n    )\n)\n\n# Class-based client\nfrom my_client import config\ncfg = config.Config(\n    limits=httpx.Limits(\n        max_keepalive_connections=10,\n        max_connections=20\n    )\n)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"openapi-configuration/#configure-custom-transport","title":"Configure Custom Transport","text":"<p>Customize low-level HTTP behavior with a custom transport:</p> <pre><code>import httpx\n\n# Function-based client (sync)\n# Note: Complex objects like httpx.HTTPTransport must be set in code\nfrom my_client import config\nconfig.config = config.Config(\n    transport=httpx.HTTPTransport(\n        retries=3,\n        local_address=\"0.0.0.0\"\n    )\n)\n\n# Function-based client (async)\nfrom my_async_client import config\nconfig.config = config.Config(\n    transport=httpx.AsyncHTTPTransport(retries=3)\n)\n\n# Class-based client (sync)\nfrom my_client import config\ncfg = config.Config(\n    transport=httpx.HTTPTransport(retries=3)\n)\nclient = Client(config=cfg)\n\n# Class-based client (async)\nfrom my_client import config\ncfg = config.Config(\n    transport=httpx.AsyncHTTPTransport(retries=3)\n)\nclient = AsyncClient(config=cfg)\n</code></pre>"},{"location":"openapi-configuration/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"openapi-configuration/#mixing-environment-variables-and-code","title":"Mixing Environment Variables and Code","text":"<p>You can load base configuration from environment variables and override specific values in code:</p> <pre><code>import httpx\nfrom my_client import config\n\n# Loads API_BASE_URL, BEARER_TOKEN, etc. from environment\n# But overrides timeout and adds custom limits\ncfg = config.Config(\n    timeout=60.0,  # Override env var if present\n    limits=httpx.Limits(max_connections=50)  # Can't be set via env\n)\nclient = Client(config=cfg)\n</code></pre>"},{"location":"openapi-configuration/#multiple-clients-with-different-configurations","title":"Multiple Clients with Different Configurations","text":"<p>Class-based clients make it easy to create multiple clients with different configurations:</p> <pre><code>from my_client.client import Client\nfrom my_client import config\n\n# Production client\nprod_config = config.Config(\n    api_base_url=\"https://api.production.com\",\n    bearer_token=\"prod-token\",\n    verify_ssl=True\n)\nprod_client = Client(config=prod_config)\n\n# Staging client\nstaging_config = config.Config(\n    api_base_url=\"https://api.staging.com\",\n    bearer_token=\"staging-token\",\n    verify_ssl=False\n)\nstaging_client = Client(config=staging_config)\n\n# Use both clients in the same application\nprod_response = prod_client.get_user(user_id=123)\nstaging_response = staging_client.get_user(user_id=123)\n</code></pre>"},{"location":"openapi-regeneration/","title":"Regeneration","text":"<p>At times you may wish to regenerate a client.</p> <p>This could be because the API has updated or you just want to use a newer version of Clientele.</p> <p>To force a regeneration you must pass the <code>--regen</code> or <code>-r</code> argument, for example:</p> <pre><code>clientele scaffold-api -f example_openapi_specs/best.json -o my_client/  --regen\n</code></pre> <p>Note</p> <p>You can copy and paste the command from the <code>MANIFEST.md</code> file in your previously-generated client for a quick and easy regeneration.</p>"},{"location":"openapi-regeneration/#understanding-regeneration","title":"Understanding Regeneration","text":"<p>When you regenerate a client with <code>--regen</code>, Clientele follows these rules:</p> <p>Files that WILL be overwritten:</p> <ul> <li><code>client.py</code> - Your API client functions/class</li> <li><code>schemas.py</code> - Pydantic models for request/response data</li> <li><code>MANIFEST.md</code> - Metadata about the generated client</li> </ul> <p>Files that will NOT be overwritten:</p> <ul> <li><code>config.py</code> - Your custom configuration (API URL, auth tokens, headers)</li> </ul> <p>This design ensures your customizations in <code>config.py</code> are preserved while keeping the client code in sync with the latest API schema.</p>"},{"location":"openapi-regeneration/#the-manifestmd-file","title":"The MANIFEST.md File","text":"<p>Every generated client includes a <code>MANIFEST.md</code> file that records:</p> <ul> <li>The exact command used to generate the client</li> <li>The OpenAPI version of the source schema</li> <li>The Clientele version used</li> <li>Generation timestamp</li> </ul> <p>Example <code>MANIFEST.md</code>:</p> <pre><code># Manifest\n\nGenerated with [https://github.com/phalt/clientele](https://github.com/phalt/clientele)\nInstall with pipx:\n\n```sh\npipx install clientele\n```\n\nAPI VERSION: 0.1.0\nOPENAPI VERSION: 3.0.2\nCLIENTELE VERSION: 1.4.3\n\nRegenerate using this command:\n\n```sh\nclientele scaffold-api -f example_openapi_specs/best.json -o tests/async_test_client/ --asyncio --regen\n```\n\nExplore this API interactively:\n\n```sh\nclientele explore -c .\n```\n</code></pre>"},{"location":"openapi-regeneration/#recommended-workflow","title":"Recommended Workflow","text":"<p>Here's the recommended workflow for keeping your client in sync:</p> <ol> <li>API Updated: Your API has new endpoints or changed schemas</li> <li>Regenerate: Run <code>clientele generate</code> with <code>--regen t</code> <pre><code>clientele scaffold-api -u http://localhost:8000/openapi.json -o my_client/ --regen\n</code></pre></li> <li>Review Changes: Use git to see what changed <pre><code>git diff my_client/\n</code></pre></li> <li>Inspect the changes.</li> <li>Test: Run your test suite to catch breaking changes <pre><code>pytest tests/\n</code></pre></li> <li>Commit: Add the changes to git <pre><code>git add my_client/\ngit commit -m \"Regenerated client for API v2.1\"\n</code></pre></li> </ol>"},{"location":"openapi-regeneration/#handling-breaking-changes","title":"Handling Breaking Changes","text":"<p>When the API introduces breaking changes, regeneration will reflect them:</p> <ul> <li>Removed endpoints \u2192 Functions deleted from <code>client.py</code></li> <li>Renamed fields \u2192 Schema properties change</li> <li>New required fields \u2192 Function signatures updated</li> <li>Changed response types \u2192 Schema unions modified</li> </ul> <p>You should have tests to catch these issues.</p> <p>If you need to support multiple API versions, consider generating separate clients for each version sing version-specific directories (e.g., <code>my_client_v1/</code>, <code>my_client_v2/</code>).</p>"},{"location":"openapi-regeneration/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>You can automate regeneration in CI/CD:</p> <pre><code># Example GitHub Actions workflow\n- name: Regenerate API client\n  run: |\n    clientele scaffold-api \\\n      -u http://api:8000/openapi.json \\\n      -o clients/my_api/ \\\n      --regen\n\n    # Check if client changed\n    if ! git diff --quiet clients/my_api/; then\n      echo \"API client changed - review required\"\n      git diff clients/my_api/\n      exit 1\n    fi\n</code></pre> <p>This keeps your client in sync with the API schema.</p>"},{"location":"references/","title":"\ud83d\udd17 References in OpenAPI","text":"<p>Clientele fully supports OpenAPI's <code>$ref</code> mechanism for reusing schema definitions across your API specification. This page explains how references work and what Clientele does when generating clients with them.</p>"},{"location":"references/#what-are-refs","title":"What are <code>$ref</code>s?","text":"<p>In OpenAPI, <code>$ref</code> (short for \"reference\") lets you define a schema, parameter, or response once and reuse it throughout your specification.</p> <p>Here's a simple example:</p> <pre><code>{\n  \"components\": {\n    \"schemas\": {\n      \"User\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": { \"type\": \"integer\" },\n          \"name\": { \"type\": \"string\" }\n        }\n      },\n      \"UserList\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"users\": {\n            \"type\": \"array\",\n            \"items\": { \"$ref\": \"#/components/schemas/User\" }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Instead of duplicating the <code>User</code> schema definition everywhere you need it, you use <code>$ref</code> to reference it.</p>"},{"location":"references/#how-clientele-handles-references","title":"How Clientele handles references","text":"<p>Clientele resolves all <code>$ref</code> declarations in your OpenAPI schema and generates properly-typed Python code using Pydantic models.</p>"},{"location":"references/#types-of-references-supported","title":"Types of references supported","text":"<p>Clientele handles <code>$ref</code> in all the places the OpenAPI specification allows:</p>"},{"location":"references/#1-schema-properties","title":"1. Schema properties","text":"<p>When a property references another schema:</p> <pre><code>{\n  \"Response\": {\n    \"properties\": {\n      \"user\": { \"$ref\": \"#/components/schemas/User\" }\n    }\n  }\n}\n</code></pre> <p>Generates:</p> <pre><code>class User(pydantic.BaseModel):\n    id: int\n    name: str\n\nclass Response(pydantic.BaseModel):\n    user: \"User\" \n</code></pre>"},{"location":"references/#2-array-items","title":"2. Array items","text":"<p>When array items reference a schema:</p> <pre><code>{\n  \"UserList\": {\n    \"properties\": {\n      \"users\": {\n        \"type\": \"array\",\n        \"items\": { \"$ref\": \"#/components/schemas/User\" }\n      }\n    }\n  }\n}\n</code></pre> <p>Generates:</p> <pre><code>class UserList(pydantic.BaseModel):\n    users: list[User]\n</code></pre>"},{"location":"references/#3-enum-references","title":"3. Enum references","text":"<p>References to enum schemas work just as you'd expect:</p> <pre><code>{\n  \"Status\": {\n    \"type\": \"string\",\n    \"enum\": [\"active\", \"inactive\"]\n  },\n  \"Response\": {\n    \"properties\": {\n      \"status\": { \"$ref\": \"#/components/schemas/Status\" }\n    }\n  }\n}\n</code></pre> <p>Generates:</p> <pre><code>class Status(str, enum.Enum):\n    ACTIVE = \"active\"\n    INACTIVE = \"inactive\"\n\nclass Response(pydantic.BaseModel):\n    status: \"Status\"\n</code></pre>"},{"location":"references/#4-response-references","title":"4. Response references","text":"<p>OpenAPI lets you define reusable responses in <code>components/responses</code>:</p> <pre><code>components:\n  responses:\n    ErrorResponse:\n      description: Standard error response\n      content:\n        application/json:\n          schema:\n            $ref: '#/components/schemas/Error'\n  schemas:\n    Error:\n      type: object\n      properties:\n        message:\n          type: string\n\npaths:\n  /users:\n    get:\n      responses:\n        '400':\n          $ref: '#/components/responses/ErrorResponse'\n</code></pre> <p>Clientele resolves the response reference and generates the corresponding schema just once:</p> <pre><code>class Error(pydantic.BaseModel):\n    message: str\n</code></pre>"},{"location":"references/#5-parameter-references","title":"5. Parameter references","text":"<p>You can define reusable parameters:</p> <pre><code>components:\n  parameters:\n    PageNumber:\n      name: page\n      in: query\n      schema:\n        type: integer\n\npaths:\n  /users:\n    get:\n      parameters:\n        - $ref: '#/components/parameters/PageNumber'\n</code></pre> <p>Clientele includes these in the generated function signatures or header classes.</p>"},{"location":"references/#6-composed-schemas-allof","title":"6. Composed schemas (allOf)","text":"<p>OpenAPI's <code>allOf</code> lets you compose schemas from multiple references:</p> <pre><code>components:\n  schemas:\n    BaseUser:\n      type: object\n      properties:\n        id:\n          type: integer\n    UserDetails:\n      type: object\n      properties:\n        email:\n          type: string\n    FullUser:\n      allOf:\n        - $ref: '#/components/schemas/BaseUser'\n        - $ref: '#/components/schemas/UserDetails'\n</code></pre> <p>Generates a single merged schema:</p> <pre><code>class FullUser(pydantic.BaseModel):\n    id: int       # From BaseUser\n    email: str    # From UserDetails\n</code></pre>"},{"location":"references/#nested-references","title":"Nested references","text":"<p>Clientele handles deeply nested references without any issues:</p> <pre><code>{\n  \"Comment\": {\n    \"properties\": {\n      \"author\": { \"$ref\": \"#/components/schemas/User\" }\n    }\n  },\n  \"Post\": {\n    \"properties\": {\n      \"comments\": {\n        \"type\": \"array\",\n        \"items\": { \"$ref\": \"#/components/schemas/Comment\" }\n      }\n    }\n  }\n}\n</code></pre> <p>Generates properly typed nested structures:</p> <pre><code>class User(pydantic.BaseModel):\n    id: int\n    name: str\n\nclass Comment(pydantic.BaseModel):\n    author: User\n\nclass Post(pydantic.BaseModel):\n    comments: list[Comment]\n</code></pre>"},{"location":"references/#working-with-generated-code","title":"Working with generated code","text":"<p>The generated code using references works seamlessly at runtime:</p> <pre><code>from my_api import schemas\n\n# Create a user\nuser = schemas.User(id=1, name=\"Alice\")\n\n# Use in a response\nresponse = schemas.Response(user=user)\n\n# Type checking works!\nreveal_type(response.user)  # Revealed type is \"User\"\n\n# IDE auto-completion works too\nresponse.user.name  # \u2190 Your IDE suggests 'id' and 'name'\n</code></pre>"},{"location":"references/#real-world-example","title":"Real-world example","text":"<p>Here's a complete example showing multiple reference types working together:</p>"},{"location":"references/#openapi-schema","title":"OpenAPI Schema","text":"<pre><code>{\n  \"components\": {\n    \"schemas\": {\n      \"UserRole\": {\n        \"type\": \"string\",\n        \"enum\": [\"admin\", \"user\", \"guest\"]\n      },\n      \"User\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": { \"type\": \"integer\" },\n          \"name\": { \"type\": \"string\" },\n          \"role\": { \"$ref\": \"#/components/schemas/UserRole\" }\n        }\n      },\n      \"TeamResponse\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"name\": { \"type\": \"string\" },\n          \"members\": {\n            \"type\": \"array\",\n            \"items\": { \"$ref\": \"#/components/schemas/User\" }\n          },\n          \"owner\": { \"$ref\": \"#/components/schemas/User\" }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"references/#generated-code","title":"Generated Code","text":"<pre><code>import enum\nimport pydantic\n\nclass UserRole(str, enum.Enum):\n    ADMIN = \"admin\"\n    USER = \"user\"\n    GUEST = \"guest\"\n\nclass User(pydantic.BaseModel):\n    id: int\n    name: str\n    role: UserRule\n\nclass TeamResponse(pydantic.BaseModel):\n    name: str\n    members: list[User]\n    owner: User\n</code></pre>"},{"location":"references/#usage","title":"Usage","text":"<pre><code>from my_api import schemas\n\n# Create users with enum roles\nadmin = schemas.User(\n    id=1, \n    name=\"Alice\", \n    role=schemas.UserRole.ADMIN\n)\nmember = schemas.User(\n    id=2, \n    name=\"Bob\", \n    role=schemas.UserRole.USER\n)\n\n# Create a team response\nteam = schemas.TeamResponse(\n    name=\"Engineering\",\n    members=[admin, member],\n    owner=admin\n)\n\n# Everything is properly typed\nassert isinstance(team.owner, schemas.User)\nassert team.owner.role == schemas.UserRole.ADMIN\n</code></pre>"},{"location":"references/#summary","title":"Summary","text":"<p>Clientele handles all forms of <code>$ref</code> in OpenAPI schemas:</p> Reference Type Location Supported Example Schema in property <code>properties.user.$ref</code> \u2705 <code>user: \"User\"</code> Schema in array <code>items.$ref</code> \u2705 <code>list[\"User\"]</code> Enum reference <code>properties.status.$ref</code> \u2705 <code>status: \"Status\"</code> Response reference <code>responses.400.$ref</code> \u2705 Schema generated Parameter reference <code>parameters.$ref</code> \u2705 Included in functions allOf composition <code>allOf[n].$ref</code> \u2705 Merged into one schema"},{"location":"server-django-ninja/","title":"\ud83e\udd77 Using Clientele with Django Ninja","text":"<p>This guide shows you how to scaffold a Python client for a Django Ninja API using Clientele.</p> <p>\ud83d\udca1 Working Example: See a real Django Ninja application with code examples from this guide in <code>server_examples/django_ninja/</code></p>"},{"location":"server-django-ninja/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Django application with Django Ninja installed</li> <li>Django Ninja automatically generates OpenAPI schemas (enabled by default)</li> </ul>"},{"location":"server-django-ninja/#step-1-get-your-openapi-schema","title":"Step 1: Get Your OpenAPI Schema","text":"<p>Django Ninja automatically generates an OpenAPI schema for your API. By default, it's available at:</p> <pre><code>http://your-api-domain/api/openapi.json\n</code></pre> <p>For local development:</p> <pre><code>http://localhost:8000/api/openapi.json\n</code></pre> <p>The exact path depends on how you've mounted your Django Ninja API in your URLs.</p>"},{"location":"server-django-ninja/#example-django-ninja-setup","title":"Example Django Ninja Setup","text":"<pre><code># urls.py\nfrom django.urls import path\nfrom ninja import NinjaAPI\n\napi = NinjaAPI()\n\n# Your endpoints here...\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>With this setup, the OpenAPI schema is at: <code>http://localhost:8000/api/openapi.json</code></p>"},{"location":"server-django-ninja/#downloading-the-schema","title":"Downloading the Schema","text":"<p>You can either:</p> <p>Option A: Use the URL directly (if the API is accessible):</p> <pre><code>clientele scaffold-api -u http://localhost:8000/api/openapi.json -o my_client/\n</code></pre> <p>Option B: Download the schema file first:</p> <pre><code>curl http://localhost:8000/api/openapi.json &gt; openapi.json\nclientele scaffold-api -f openapi.json -o my_client/\n</code></pre>"},{"location":"server-django-ninja/#step-2-scaffold-the-client","title":"Step 2: Scaffold the Client","text":"<pre><code>clientele scaffold-api -u http://localhost:8000/api/openapi.json -o my_client/\n</code></pre>"},{"location":"server-django-ninja/#async-client","title":"Async Client","text":"<p>Django Ninja supports both sync and async views. If you want an async client:</p> <pre><code>clientele scaffold-api -u http://localhost:8000/api/openapi.json -o my_client/ --asyncio\n</code></pre>"},{"location":"server-django-ninja/#step-3-use-the-scaffolded-client","title":"Step 3: Use the scaffolded Client","text":""},{"location":"server-django-ninja/#usage-example","title":"Usage Example","text":"<pre><code>from my_client import client, schemas\n\n# Call a GET endpoint\nresponse = client.list_users_api_users_get()\n\n# Call a POST endpoint with data\nuser_data = schemas.UserIn(\n    username=\"alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_api_users_post(data=user_data)\n\n# Handle responses\nmatch response:\n    case schemas.UserOut():\n        print(f\"User created: {response.username}\")\n    case schemas.Error():\n        print(f\"Error: {response.message}\")\n</code></pre>"},{"location":"server-django-ninja/#async-usage-example","title":"Async usage Example","text":"<p>If your Django Ninja views are async:</p> <pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.UserIn(\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_api_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"server-django-ninja/#working-with-operation_id","title":"Working with operation_id","text":"<p>Django Ninja generates <code>operation_id</code> values for each endpoint, which Clientele uses to create function names.</p>"},{"location":"server-django-ninja/#default-operation-id","title":"Default Operation ID","text":"<p>By default, Django Ninja generates operation IDs from the function name and path:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n\n@api.get(\"/users\")\ndef list_users(request):\n    return []\n</code></pre> <p>This might generate: <code>list_users_api_users_get</code></p>"},{"location":"server-django-ninja/#custom-operation_id","title":"Custom operation_id","text":"<p>You can customize the operation ID in Django Ninja to get cleaner function names:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n\n@api.get(\"/users\", operation_id=\"list_users\")\ndef get_users(request):\n    return []\n\n@api.post(\"/users\", operation_id=\"create_user\")\ndef create_user(request, user: UserIn):\n    return user\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of <code>client.list_users_api_users_get()</code></li> <li><code>client.create_user()</code> instead of <code>client.create_user_api_users_post()</code></li> </ul>"},{"location":"server-django-ninja/#authentication","title":"Authentication","text":"<p>See api authentication.</p>"},{"location":"server-django-ninja/#regenerating-the-client","title":"Regenerating the Client","text":"<p>See regeneration.</p>"},{"location":"server-django-ninja/#schemas-and-pydantic","title":"Schemas and Pydantic","text":"<p>Django Ninja uses Pydantic for schemas, which aligns perfectly with Clientele!</p>"},{"location":"server-django-ninja/#django-ninja-schema","title":"Django Ninja Schema","text":"<pre><code>from ninja import Schema\n\nclass UserIn(Schema):\n    username: str\n    email: str\n    age: int\n\nclass UserOut(Schema):\n    id: int\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n</code></pre>"},{"location":"server-django-ninja/#generated-client-schemas","title":"Generated Client Schemas","text":"<p>Clientele converts these to Pydantic models in the client:</p> <pre><code># In my_client/schemas.py\nimport pydantic\nfrom datetime import datetime\n\nclass UserIn(pydantic.BaseModel):\n    username: str\n    email: str\n    age: int\n\nclass UserOut(pydantic.BaseModel):\n    id: int\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n</code></pre>"},{"location":"server-django-ninja/#usage","title":"Usage","text":"<pre><code># Create request data\nuser_data = schemas.UserIn(\n    username=\"alice\",\n    email=\"alice@example.com\",\n    age=30\n)\n\n# Get typed response\nresponse = client.create_user(data=user_data)\n# response is typed as schemas.UserOut\nprint(response.id)\n</code></pre>"},{"location":"server-django-ninja/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>Django Ninja's path and query parameters are automatically converted to function arguments:</p> <p>Django Ninja Endpoint</p> <pre><code>from ninja import Query\n\n@api.get(\"/users/{user_id}\")\ndef get_user(request, user_id: int, include_posts: bool = Query(False)):\n    return {\n        \"user_id\": user_id,\n        \"include_posts\": include_posts\n    }\n</code></pre> <p>Client Usage</p> <pre><code># Required path parameter, optional query parameter\nresponse = client.get_user_api_users_user_id_get(\n    user_id=123,\n    include_posts=True\n)\n</code></pre>"},{"location":"server-django-ninja/#response-models","title":"Response Models","text":"<p>Django Ninja's response models become Pydantic schemas in the client:</p> <p>Django Ninja Endpoint</p> <pre><code>class UserOut(Schema):\n    id: int\n    username: str\n    email: str\n\n@api.get(\"/users/{user_id}\", response=UserOut)\ndef get_user(request, user_id: int):\n    return UserOut(\n        id=user_id,\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n</code></pre> <p>Generated Client Usage</p> <pre><code>response = client.get_user_api_users_user_id_get(user_id=123)\n# response is typed as schemas.UserOut\nprint(response.username)\n</code></pre>"},{"location":"server-django-ninja/#best-practices","title":"Best Practices","text":"<ol> <li>Use custom <code>operation_id</code> values for cleaner function names</li> <li>Keep schemas in sync by regenerating after API changes</li> <li>Version your generated client in git to track changes</li> <li>Test thoroughly after regenerating</li> <li>Document your endpoints - Django Ninja includes docstrings in the schema</li> </ol>"},{"location":"server-django-ninja/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about regeneration workflow</li> <li>Configure authentication</li> <li>Set up testing with respx</li> </ul>"},{"location":"server-drf/","title":"\ud83e\udd84 Using Clientele with Django REST Framework","text":"<p>This guide shows you how to scaffold a Python client for a Django REST Framework (DRF) API using Clientele and drf-spectacular.</p> <p>\ud83d\udca1 Working Example: See a real Django REST Framework application with code examples from this guide in <code>server_examples/django_rest_framework/</code></p>"},{"location":"server-drf/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Django REST Framework application</li> <li>drf-spectacular installed and configured</li> </ul>"},{"location":"server-drf/#why-drf-spectacular","title":"Why drf-spectacular?","text":"<p>Django REST Framework doesn't include built-in OpenAPI schema generation. drf-spectacular is the recommended solution for generating OpenAPI 3.0 schemas from DRF applications. It's actively maintained and provides excellent OpenAPI support.</p>"},{"location":"server-drf/#step-1-install-and-configure-drf-spectacular","title":"Step 1: Install and Configure drf-spectacular","text":"<p>If you haven't already set up drf-spectacular, follow these steps:</p>"},{"location":"server-drf/#install-drf-spectacular","title":"Install drf-spectacular","text":"<pre><code>pip install drf-spectacular\n</code></pre>"},{"location":"server-drf/#configure-django-settings","title":"Configure Django Settings","text":"<p>Add to your <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    'rest_framework',\n    'drf_spectacular',\n    # ...\n]\n\nREST_FRAMEWORK = {\n    # ...\n    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',\n}\n\nSPECTACULAR_SETTINGS = {\n    'TITLE': 'Your API',\n    'DESCRIPTION': 'Your API description',\n    'VERSION': '1.0.0',\n    'SERVE_INCLUDE_SCHEMA': False,\n}\n</code></pre>"},{"location":"server-drf/#add-url-patterns","title":"Add URL Patterns","text":"<p>In your <code>urls.py</code>:</p> <pre><code>from drf_spectacular.views import SpectacularAPIView\nfrom django.urls import path\n\nurlpatterns = [\n    # ...\n    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),\n]\n</code></pre>"},{"location":"server-drf/#step-2-get-your-openapi-schema","title":"Step 2: Get Your OpenAPI Schema","text":"<p>After configuring drf-spectacular, your OpenAPI schema is available at:</p> <pre><code>http://your-api-domain/api/schema/\n</code></pre> <p>For local development:</p> <pre><code>http://localhost:8000/api/schema/\n</code></pre>"},{"location":"server-drf/#downloading-the-schema","title":"Downloading the Schema","text":"<p>You can either:</p> <p>Option A: Use the URL directly (if the API is accessible):</p> <pre><code>clientele scaffold-api -u http://localhost:8000/api/schema/ -o my_client/\n</code></pre> <p>Option B: Download the schema file first:</p> <pre><code>curl http://localhost:8000/api/schema/ &gt; openapi.json\nclientele scaffold-api -f openapi.json -o my_client/\n</code></pre> <p>Option C: Generate schema file with Django management command:</p> <pre><code>python manage.py spectacular --file openapi.json\nclientele scaffold-api -f openapi.json -o my_client/\n</code></pre>"},{"location":"server-drf/#step-3-scaffold-the-client","title":"Step 3: Scaffold the Client","text":"<pre><code>clientele scaffold-api -u http://localhost:8000/api/schema/ -o my_client/\n</code></pre>"},{"location":"server-drf/#async-client","title":"Async Client","text":"<p>If you want an async client (note: DRF itself is synchronous, but the client can be async):</p> <pre><code>clientele scaffold-api -u http://localhost:8000/api/schema/ -o my_client/ --asyncio\n</code></pre>"},{"location":"server-drf/#step-4-use-the-scaffolded-client","title":"Step 4: Use the scaffolded Client","text":""},{"location":"server-drf/#usage-example","title":"Usage Example","text":"<pre><code>from my_client import client, schemas\n\n# List resources\nresponse = client.list_users_api_users_get()\n\n# Create a resource\nuser_data = schemas.UserRequest(\n    username=\"alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_api_users_post(data=user_data)\n\n# Handle responses\nmatch response:\n    case schemas.User():\n        print(f\"User created: {response.username}\")\n    case schemas.ValidationError():\n        print(f\"Validation failed: {response.detail}\")\n</code></pre>"},{"location":"server-drf/#async-usage-example","title":"Async usage Example","text":"<pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.UserRequest(\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_api_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"server-drf/#improving-operationid-in-drf","title":"Improving operationId in DRF","text":"<p>By default, drf-spectacular generates operation IDs from view names and paths. You can customize them for cleaner function names.</p>"},{"location":"server-drf/#using-extend_schema-decorator","title":"Using extend_schema Decorator","text":"<pre><code>from drf_spectacular.utils import extend_schema\nfrom rest_framework import viewsets\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n    @extend_schema(operation_id=\"list_users\")\n    def list(self, request):\n        return super().list(request)\n\n    @extend_schema(operation_id=\"create_user\")\n    def create(self, request):\n        return super().create(request)\n\n    @extend_schema(operation_id=\"get_user\")\n    def retrieve(self, request, pk=None):\n        return super().retrieve(request, pk)\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of a generic operation ID</li> <li><code>client.create_user()</code> instead of verbose auto-generated names</li> <li><code>client.get_user()</code> for clean, readable function names</li> </ul>"},{"location":"server-drf/#for-function-based-views","title":"For Function-Based Views","text":"<pre><code>from drf_spectacular.utils import extend_schema\nfrom rest_framework.decorators import api_view\n\n@extend_schema(\n    operation_id=\"get_user_stats\",\n    responses={200: UserStatsSerializer}\n)\n@api_view(['GET'])\ndef user_stats(request, user_id):\n    # ...\n    return Response(data)\n</code></pre>"},{"location":"server-drf/#authentication","title":"Authentication","text":"<p>See api authentication.</p>"},{"location":"server-drf/#regenerating-the-client","title":"Regenerating the Client","text":"<p>See regeneration.</p>"},{"location":"server-drf/#serializers-and-schemas","title":"Serializers and Schemas","text":"<p>DRF serializers become Pydantic models in the generated client:</p>"},{"location":"server-drf/#drf-serializer","title":"DRF Serializer","text":"<pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'is_active']\n</code></pre>"},{"location":"server-drf/#generated-pydantic-schema","title":"Generated Pydantic Schema","text":"<pre><code># In my_client/schemas.py\nimport pydantic\n\nclass User(pydantic.BaseModel):\n    id: int\n    username: str\n    email: str\n    is_active: bool\n</code></pre>"},{"location":"server-drf/#usage","title":"Usage","text":"<pre><code># The client returns properly typed responses\nresponse = client.get_user_api_users_id_get(id=123)\n# response is typed as schemas.User\nprint(response.username)\n</code></pre>"},{"location":"server-drf/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>Query parameters are automatically converted to function arguments:</p> <p>DRF View with Filtering</p> <pre><code>class UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filterset_fields = ['is_active', 'username']\n</code></pre> <p>Client Usage</p> <pre><code># Query parameters become function arguments\nresponse = client.list_users_api_users_get(\n    is_active=True,\n    username=\"alice\"\n)\n</code></pre>"},{"location":"server-drf/#response-models","title":"Response Models","text":"<p>DRF's serializers become response models in the client:</p> <p>DRF ViewSet</p> <pre><code>from rest_framework import serializers, viewsets\n\nclass User(serializers.ModelSerializer):\n    class Meta:\n        model = UserModel\n        fields = ['id', 'username', 'email']\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = UserModel.objects.all()\n    serializer_class = User\n</code></pre> <p>Generated Client Usage</p> <pre><code>response = client.get_user_api_users_id_get(id=123)\n# response is typed as schemas.User\nprint(response.username)\n</code></pre>"},{"location":"server-drf/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>@extend_schema</code> to provide clear operation IDs and response types</li> <li>Keep schemas in sync by regenerating after API changes</li> <li>Version your generated client in git to track changes</li> <li>Test thoroughly after regenerating</li> <li>Document your serializers - drf-spectacular uses docstrings in schema generation</li> </ol>"},{"location":"server-drf/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about regeneration workflow</li> <li>Configure authentication</li> <li>Set up testing with respx</li> </ul>"},{"location":"server-fastapi/","title":"\u26a1\ufe0f Using Clientele with FastAPI","text":"<p>This guide shows you how to scaffold a Python client for a FastAPI application using Clientele.</p> <p>\ud83d\udca1 Working Example: See a real FastAPI application with code examples from this guide in <code>server_examples/fastapi/</code></p>"},{"location":"server-fastapi/#prerequisites","title":"Prerequisites","text":"<ul> <li>A FastAPI application with API endpoints</li> <li>FastAPI's automatic OpenAPI schema generation enabled (enabled by default)</li> </ul>"},{"location":"server-fastapi/#step-1-get-your-openapi-schema","title":"Step 1: Get Your OpenAPI Schema","text":"<p>FastAPI automatically generates an OpenAPI schema for your API. You can access it at:</p> <pre><code>http://your-api-domain/openapi.json\n</code></pre> <p>For example, if your FastAPI app is running locally on port 8000:</p> <pre><code>http://localhost:8000/openapi.json\n</code></pre>"},{"location":"server-fastapi/#downloading-the-schema","title":"Downloading the Schema","text":"<p>You can either:</p> <p>Option A: Use the URL directly (if the API is accessible):</p> <pre><code>clientele scaffold-api -u http://localhost:8000/openapi.json -o my_client/\n</code></pre> <p>Option B: Download the schema file first:</p> <pre><code>curl http://localhost:8000/openapi.json &gt; openapi.json\nclientele scaffold-api -f openapi.json -o my_client/\n</code></pre>"},{"location":"server-fastapi/#step-2-scaffold-the-client","title":"Step 2: Scaffold the Client","text":"<pre><code>clientele scaffold-api -u http://localhost:8000/openapi.json -o my_client/\n</code></pre>"},{"location":"server-fastapi/#async-client","title":"Async Client","text":"<p>If your FastAPI app uses async endpoints and you want an async client:</p> <pre><code>clientele scaffold-api -u http://localhost:8000/openapi.json -o my_client/ --asyncio\n</code></pre>"},{"location":"server-fastapi/#step-3-use-the-scaffolded-client","title":"Step 3: Use the scaffolded Client","text":""},{"location":"server-fastapi/#usage-example","title":"Usage Example","text":"<pre><code>from my_client import client, schemas\n\n# Call a simple GET endpoint\nresponse = client.get_users_users_get()\n\n# Call a POST endpoint with data\nuser_data = schemas.CreateUserRequest(\n    name=\"Alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_users_post(data=user_data)\n\n# Handle different response types\nmatch response:\n    case schemas.UserResponse():\n        print(f\"User created: {response.name}\")\n    case schemas.HTTPValidationError():\n        print(f\"Validation error: {response.detail}\")\n</code></pre>"},{"location":"server-fastapi/#async-usage-example","title":"Async usage Example","text":"<pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.CreateUserRequest(\n        name=\"Alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"server-fastapi/#working-with-operationid","title":"Working with operationId","text":"<p>FastAPI generates <code>operationId</code> values for each endpoint, which Clientele uses to create function names.</p>"},{"location":"server-fastapi/#default-operationid-generation","title":"Default operationId Generation","text":"<p>By default, FastAPI creates operation IDs like: <code>{function_name}_{path}_{method}</code></p> <p>For example:</p> <ul> <li>Function <code>get_users()</code> at path <code>/users</code> with GET \u2192 <code>get_users_users_get</code></li> <li>Function <code>create_user()</code> at path <code>/users</code> with POST \u2192 <code>create_user_users_post</code></li> </ul>"},{"location":"server-fastapi/#custom-operationid","title":"Custom operationId","text":"<p>You can customize the operation ID in FastAPI to get cleaner function names:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/users\", operation_id=\"list_users\")\ndef get_users():\n    return []\n\n@app.post(\"/users\", operation_id=\"create_user\")\ndef create_user(user: UserCreate):\n    return user\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of <code>client.get_users_users_get()</code></li> <li><code>client.create_user()</code> instead of <code>client.create_user_users_post()</code></li> </ul>"},{"location":"server-fastapi/#authentication","title":"Authentication","text":"<p>See api authentication.</p>"},{"location":"server-fastapi/#regenerating-the-client","title":"Regenerating the Client","text":"<p>See regeneration.</p>"},{"location":"server-fastapi/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>FastAPI's path and query parameters are automatically converted to function arguments:</p> <p>FastAPI Endpoint</p> <pre><code>@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int, include_posts: bool = False):\n    return {\"user_id\": user_id, \"include_posts\": include_posts}\n</code></pre> <p>Client Usage</p> <pre><code># Required path parameter, optional query parameter\nresponse = client.get_user_users_user_id_get(\n    user_id=123,\n    include_posts=True\n)\n</code></pre>"},{"location":"server-fastapi/#response-models","title":"Response Models","text":"<p>FastAPI's response models become Pydantic schemas in the client:</p> <p>FastAPI Endpoint</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.get(\"/users/{user_id}\", response_model=User)\ndef get_user(user_id: int):\n    return User(id=user_id, name=\"Alice\", email=\"alice@example.com\")\n</code></pre> <p>Generated Client Usage</p> <pre><code>response = client.get_user_users_user_id_get(user_id=123)\n# response is typed as schemas.User\nprint(response.name)\n</code></pre>"},{"location":"server-fastapi/#best-practices","title":"Best Practices","text":"<ol> <li>Use custom operationId values for cleaner function names</li> <li>Keep schemas in sync by regenerating after API changes</li> <li>Version your generated client in git to track changes</li> <li>Test thoroughly after regenerating</li> <li>Use the same Python version for both API and client when possible</li> </ol>"},{"location":"server-fastapi/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about regeneration workflow</li> <li>Configure authentication</li> <li>Set up testing with respx</li> </ul>"},{"location":"testing/","title":"\ud83e\uddea Testing","text":"<p>Clientele is designed for easy testing.</p> <p>Our own test suite shows how you can write mock tests for your API client.</p> <pre><code>import pytest\nfrom httpx import Response\nfrom respx import MockRouter\n\nfrom .test_client import client, constants, schemas\n\nBASE_URL = constants.api_base_url()\n\n\n@pytest.mark.respx(base_url=BASE_URL)\ndef test_simple_request_simple_request_get(respx_mock: MockRouter):\n    # Given\n    mocked_response = {\"status\": \"hello world\"}\n    mock_path = \"/simple-request\"\n    respx_mock.get(mock_path).mock(\n        return_value=Response(json=mocked_response, status_code=200)\n    )\n    # When\n    response = client.simple_request_simple_request_get()\n    # Then\n    assert isinstance(response, schemas.SimpleResponse)\n    assert len(respx_mock.calls) == 1\n    call = respx_mock.calls[0]\n    assert call.request.url == BASE_URL + mock_path\n</code></pre> <p>We recommend installing respx for writing your tests.</p>"}]}