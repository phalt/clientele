{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\u269c\ufe0f Home","text":""},{"location":"#what-is-clientele","title":"What is Clientele?","text":"<p>Clientele is a comprehensive framework for building and maintaining API Integrations.</p> <p>Focus on the functionality and the data you want from an API, and let Clientele handle the rest.</p> <p>Build, test, and maintain API integrations confidently.</p>"},{"location":"#example-code","title":"Example code","text":"<pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2/\")\n\nclass Pokemon(BaseModel):\n    name: str\n\n@client.get(\"/pokemon/{id}\")\ndef get_pokemon_name(id: int, result: Pokemon) -&gt; str:\n    return result.name\n</code></pre> <p>See more examples</p>"},{"location":"#why-use-clientele","title":"Why use Clientele?","text":"<ul> <li>A comfortable abstraction - Encourages consistency and focus on the functionality.</li> <li>Easy to learn - Clientele is visually similar to popular python API server frameworks.</li> <li>Easy to test - All the testing tools you need to maintain API integrations.</li> <li>Easy to configure - Sensible HTTP defaults and plenty of hooks for customisation.</li> <li>Easy data validation - Built in data validation using Pydantic.</li> <li>Core built-ins - Caching, Network, and Retry handling built specifically for HTTP.</li> <li>Use your own HTTP - Clientele can support any Python HTTP library.</li> <li>OpenAPI support - Build your own client, or scaffold one from an OpenAPI schema.</li> <li>GraphQL support - Clientele has a GraphQLClient tailored for GraphQL APIs.</li> </ul>"},{"location":"#async-support","title":"Async support","text":"<pre><code>@client.get(\"/pokemon/{id}\")\nasync def get_pokemon_name(id: int, result: Pokemon) -&gt; str:\n    return result.name\n</code></pre>"},{"location":"#automatic-data-validation","title":"Automatic data validation","text":"<pre><code>from clientele import api as clientele_api\nfrom .my_pydantic_models import CreateBookRequest, CreateBookResponse\n\nclient = clientele_api.APIClient(base_url=\"http://localhost:8000\")\n\n\n@client.post(\"/books\")\ndef create_book(data: CreateBookRequest, result: CreateBookResponse) -&gt; CreateBookResponse:\n    return result\n</code></pre>"},{"location":"#graphql-support","title":"GraphQL support","text":"<pre><code>from pydantic import BaseModel\nfrom clientele.graphql import GraphQLClient\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\nclass Repository(BaseModel):\n    name: str\n    stargazerCount: int\n\nclass RepositoryQueryData(BaseModel):\n    repository: Repository\n\nclass RepositoryQueryResponse(BaseModel):\n    data: RepositoryQueryData\n\n@client.query(\"\"\"\n    query($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n            name\n            stargazerCount\n        }\n    }\n\"\"\")\ndef get_repo(owner: str, name: str, result: RepositoryQueryResponse) -&gt; Repository:\n    return result.data.repository\n</code></pre>"},{"location":"#works-with-python-api-frameworks","title":"Works with Python API frameworks","text":"<p>Building an API service in Python? Clientele can build you a client library in seconds.</p> <p>Clientele is built and tested to be 100% compatible with the OpenAPI schemas generated from:</p> <ul> <li>FastAPI</li> <li>Django REST Framework via drf-spectacular</li> <li>Django Ninja</li> </ul> <p>See the working demos in our <code>server_examples/</code> directory.</p>"},{"location":"#openapi-support","title":"OpenAPI support","text":"<p>Clientele can create scaffolding for an API client from an OpenAPI schema with:</p> <ul> <li>Pydantic models generated from the schema objects.</li> <li>Decorated function signatures generated from schema operations.</li> <li>Async support if you want a client with concurrency.</li> <li>A tiny output that is only 3 files big.</li> <li>Regeneration-friendly - update your API, regenerate, review the git diff, then ship it!</li> <li>Formatted code thanks to Ruff.</li> </ul> <p></p>"},{"location":"CHANGELOG/","title":"Change log","text":""},{"location":"CHANGELOG/#1110","title":"1.11.0","text":""},{"location":"CHANGELOG/#graphqlclient-support","title":"GraphQLClient support","text":"<ul> <li>A method for building GraphQL integrations has been introduced.</li> <li>It follows the \"Clientele\" pattern of the standard <code>APIClient</code>.</li> </ul> <p>Query example:</p> <pre><code>@client.query('''\n    query($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n            name\n            stargazerCount\n        }\n    }\n''')\ndef get_repo(owner: str, name: str, result: RepositoryData) -&gt; Repository:\n    return result.repository\n</code></pre> <p>Mutation example:</p> <pre><code>@client.mutation('''\n    mutation($title: String!) {\n        createIssue(input: {title: $title}) {\n            issue { id title }\n        }\n    }\n''')\ndef create_issue(title: str, result: IssueData) -&gt; Issue:\n    return result.createIssue.issue\n</code></pre>"},{"location":"CHANGELOG/#1100","title":"1.10.0","text":"<ul> <li>Dropped <code>scaffold-api</code> command</li> <li>Dropped <code>generate-basic</code> command</li> <li>Drop <code>httpx_client</code> from <code>APIClient</code></li> <li>Drop <code>httpx_async_client</code> from <code>APIClient</code></li> </ul>"},{"location":"CHANGELOG/#192","title":"1.9.2","text":"<p>This release includes testing tools to make API integration testing easier.</p>"},{"location":"CHANGELOG/#responsefactory","title":"ResponseFactory","text":"<ul> <li>Added <code>ResponseFactory</code> to <code>clientele.testing</code> for quick response fixtures.</li> <li>Create common HTTP responses easily: <code>ok()</code>, <code>created()</code>, <code>not_found()</code>, <code>bad_request()</code>, <code>internal_server_error()</code>, and more.</li> </ul>"},{"location":"CHANGELOG/#networkerrorfactory","title":"NetworkErrorFactory","text":"<ul> <li>Added <code>NetworkErrorFactory</code> factory to <code>clientele.testing</code> for simulating network-level failures.</li> <li>Simulate common network errors like <code>timeout()</code>, <code>connection_refused()</code>, <code>connection_reset()</code>, and <code>dns_failure()</code>.</li> <li><code>FakeHTTPBackend</code> now supports <code>queue_error()</code> to queue errors for specific paths.</li> </ul>"},{"location":"CHANGELOG/#191","title":"1.9.1","text":"<ul> <li>Fix streaming responses to truly yield instead of consuming the full response.</li> <li>Introduces new http_backend methods for handling streaming however the backend chooses.</li> </ul>"},{"location":"CHANGELOG/#190","title":"1.9.0","text":""},{"location":"CHANGELOG/#retry-support","title":"Retry support","text":"<ul> <li>Built-in <code>retries.retry</code> decorator for handling retry logic.</li> <li>This is built on top of <code>stamina</code> - a popular and reliable retry package.</li> <li>The retry logic is customised to suit Clientele's exception handling.</li> </ul> <pre><code>from clientele import api, retries\n\nclient = api.APIClient(api.BaseConfig(base_url=\"https://httpbin.org/\"))\n\n@retries.retry(attempts=3)\n@client.get(\"/status/{status_code}\")\ndef get_status(status_code: int, result: dict) -&gt; dict:\n    return result\n</code></pre>"},{"location":"CHANGELOG/#improved-testing","title":"Improved testing","text":"<ul> <li>We have drastically improved the testing support for Clientele.</li> <li>The <code>FakeHTTPBackend</code> is now designed for testing.</li> <li>The <code>queue_response</code> method now takes a <code>http.Response</code> object as well as the path.</li> <li>The new <code>configure_client_for_testing</code> function accepts an existing client and then returns it with a new testing backend.</li> </ul> <pre><code>from clientele.testing import configure_client_for_testing\nfrom clientele import http\nfrom my_api_client import client, my_function\n\ndef my_test():\n    # Swap normal backend for a Fake HTTP backend\n    fake_backend: http.FakeHTTPBackend = configure_client_for_testing(my_api_client.client)\n\n    # Configure HTTP responses\n    fake_backend.queue_response(\n        path=\"/users\",\n        response_obj=Response(\n            status_code=201,\n            content=b'{\"id\": 10, \"name\": \"Bob\"}',\n            headers={\"content-type\": \"application/json\"},\n        ),\n    )\n\n    # Call function as normal, but it now calls the fake backend\n    response = my_function()\n</code></pre>"},{"location":"CHANGELOG/#dropped-explore-command","title":"Dropped <code>explore</code> command","text":"<ul> <li>While it is a cool feature, it distracts from the purpose of Clientele, so it is being removed.</li> </ul>"},{"location":"CHANGELOG/#181","title":"1.8.1","text":"<ul> <li>Add <code>configure</code> method to <code>APIClient</code> - enabling reconfiguration of clients. Thank you Christian Assing for the contribution.</li> </ul>"},{"location":"CHANGELOG/#180","title":"1.8.0","text":""},{"location":"CHANGELOG/#request-logging","title":"Request Logging","text":"<ul> <li>Added optional request/response logging to <code>APIClient</code> via the <code>logger</code> parameter in <code>BaseConfig</code>. Logs include method, URL, status code, and elapsed time in seconds.</li> <li>Uses a <code>Logger</code> Protocol with <code>@runtime_checkable</code> for flexibility.</li> <li>Thank you Mat\u00edas Gim\u00e9nez for the contribution.</li> </ul>"},{"location":"CHANGELOG/#cli-commands-update","title":"CLI commands update","text":"<ul> <li>A new command <code>start-api</code> has been introduced.</li> <li>The new command will replace <code>scaffold-api</code> and <code>generate-basic</code> in 2.0.0</li> <li>Currently it behaves as an alias for both.</li> <li>If not url or file is provided, will call <code>generate-basic</code>, otherwise it calls <code>scaffold-api</code>.</li> </ul> <p>Start a basic client with one command:</p> <pre><code>uvx clientele start-api -o /path/to/my_client\n</code></pre> <ul> <li>Dropped the <code>generate</code> and <code>generate-class</code> commands from the CLI.</li> </ul>"},{"location":"CHANGELOG/#171","title":"1.7.1","text":"<ul> <li>Support for OpenAPI discriminated unions (<code>oneOf</code> + <code>discriminator</code>). Schemas with discriminators now generate proper Pydantic discriminated unions using <code>typing.Annotated[..., pydantic.Field(discriminator=\"...\")]</code>.</li> </ul>"},{"location":"CHANGELOG/#170","title":"1.7.0","text":""},{"location":"CHANGELOG/#http-backends","title":"HTTP Backends","text":"<ul> <li>Clientele now supports configurable HTTP backends.</li> <li>If you want to use <code>aiohttp</code>, <code>reqwests</code> or <code>niquests</code> you can write an <code>HTTPBackend</code> so Clientele can support it.</li> <li>Clientele ships with a default <code>HttpxHTTPBackend</code> that will be used if no other is configured.</li> <li>Introduces a new <code>clientele.http.Response</code> wrapper for generic handling of responses.</li> <li>The <code>response_parser</code> callbacks now take the generic <code>clientele.http.Response</code> instead of <code>httpx.Response</code>.</li> <li>Introduces a new <code>FakeHTTPBackend</code> that can be used for testing.</li> </ul>"},{"location":"CHANGELOG/#direct-requests","title":"Direct requests","text":"<ul> <li>An optional approach for making requests with Clientele is now available.</li> <li>This approach does not enforce the decorator pattern.</li> <li>But still offers smart data hydration and response mapping.</li> <li>Support for both async and sync.</li> </ul>"},{"location":"CHANGELOG/#161","title":"1.6.1","text":"<ul> <li><code>cache_backend</code> can now be set in the <code>BaseConfig</code>, and will be used if it is not None. This saves you having to annotate the cache backend repeatedly in decorators.</li> </ul>"},{"location":"CHANGELOG/#160","title":"1.6.0","text":""},{"location":"CHANGELOG/#streaming-responses","title":"Streaming responses","text":"<ul> <li>Clientele now supports streaming responses via Server Sent Events.</li> <li>Streaming is controlled via the <code>streaming_response=True</code> parameter on all HTTP method decorators (<code>get</code>, <code>post</code>, <code>put</code>, <code>patch</code>, <code>delete</code>).</li> <li>Clientele will attempt to hydrate the response into the correct type supplied by the <code>result</code> parameter.</li> <li><code>response_parser</code> callbacks are supported and will be applied to each streamed item.</li> <li><code>response_map</code> is not currently supported for streaming endpoints.</li> </ul> <pre><code>from typing import AsyncIterator\nfrom pydantic import BaseModel\nfrom clientele import api\n\nclient = api.APIClient(base_url=\"http://localhost:8000\")\n\nclass Event(BaseModel):\n    text: str\n\n@client.get(\"/events\", streaming_response=True)\nasync def stream_events(*, result: AsyncIterator[Event]) -&gt; AsyncIterator[Event]:\n    return result\n</code></pre> <p>Usage:</p> <pre><code>async for event in await stream_events():\n    print(event.text)\n</code></pre>"},{"location":"CHANGELOG/#mypy-support","title":"Mypy support","text":"<ul> <li>A mypy plugin has been added that correctly handles Clientele. You will no longer see issues for the <code>result</code> and <code>response</code> arguments. Big shout out to Christian Assing for this contribution.</li> </ul>"},{"location":"CHANGELOG/#other-changes","title":"Other changes","text":"<ul> <li>The <code>scaffold-api</code> command now outputs a standard <code>pyproject.toml</code> into the client directory. It will not be overwritten on subsequent regenerations.</li> <li>Big code refactor - reorganising the <code>request</code> preparation and type handling into separate files.</li> </ul>"},{"location":"CHANGELOG/#150","title":"1.5.0","text":"<ul> <li>Introduce <code>cache.memoize</code> decorator for sensible, http-specific caching of HTTP get requests.</li> <li>Add documentation covering common approaches to handling retry logic.</li> </ul>"},{"location":"CHANGELOG/#143","title":"1.4.3","text":"<ul> <li>A tiny fix with error handling and using <code>response_parser</code> with plain types.</li> </ul>"},{"location":"CHANGELOG/#142","title":"1.4.2","text":"<ul> <li>Fix <code>scaffold-api</code> generating post/put/patch/delete methods with a <code>,,</code> when dealing with optional args. Contributor: @peterHoburg.</li> </ul>"},{"location":"CHANGELOG/#141","title":"1.4.1","text":"<ul> <li>Correct <code>--regen</code> and <code>--asyncio</code> to be boolean flags in <code>scaffold-api</code> command. Contributor: @peterHoburg.</li> <li>Properly support <code>null</code> field for <code>anyOf</code> schemas in OpenAPI schema generation. They now produce <code>None</code> correctly.</li> </ul>"},{"location":"CHANGELOG/#140","title":"1.4.0","text":"<ul> <li>You can now pass <code>TypedDict</code> instances for the <code>data</code> parameter on <code>post</code>, <code>put</code>, <code>patch</code> and <code>delete</code> methods.</li> <li>Decorated functions now accept a <code>response_parser</code> callback that will handle the response parsing. Use this to customise the <code>result</code> value that is sent back to the function.</li> </ul>"},{"location":"CHANGELOG/#130","title":"1.3.0","text":""},{"location":"CHANGELOG/#introducing-clientele-api-a-different-way-to-think-about-python-api-clients","title":"Introducing Clientele API - a different way to think about Python API Clients","text":"<ul> <li>Clientele API is a decorator-driven http client that can create elegant API integrations.</li> <li>Clientele API is considered a beta project for this release. It is an evolving idea that has been tested thoroughly and it works well in ideal conditions. Small changes to the API and usage may occur over time as we encounter unexpected scenarios.</li> </ul>"},{"location":"CHANGELOG/#generate-scaffolding-for-openapi-projects-with-clientele-api","title":"Generate scaffolding for OpenAPI projects with clientele API","text":"<ul> <li>The <code>scaffold-api</code> command will produce scaffolding from an OpenAPI schema and uses the new clientele api.</li> </ul>"},{"location":"CHANGELOG/#explore-apis-with-clientele-api-clients","title":"Explore APIs with Clientele API clients","text":"<ul> <li>The <code>explore</code> command has been updated to support clients that use the clientele api pattern.</li> </ul>"},{"location":"CHANGELOG/#improved-documentation","title":"Improved documentation","text":"<ul> <li>New documentation added to cover Clientele API.</li> <li>Documentation sections have been reorganised to reflect the key features of Clientele.</li> </ul>"},{"location":"CHANGELOG/#200-deprecation-notice","title":"2.0.0 deprecation notice","text":"<ul> <li>When clientele API reaches maturity, support for the current \"barebones\" style of OpenAPI scaffolders will be deprecated.</li> <li>This will be marked as the <code>2.0.0</code> release.</li> </ul>"},{"location":"CHANGELOG/#120","title":"1.2.0","text":"<ul> <li>Print operation information in explorer by typing the name of the operation without parenthesis. Prints information such as the docstring, return type, and input arguments.</li> </ul>"},{"location":"CHANGELOG/#110","title":"1.1.0","text":"<ul> <li>Schema inspection in explore REPL has been improved. Typing a schema name without parentheses now displays the schema's docstring and fields instead of the verbose inherited Pydantic BaseModel documentation.</li> <li>Config objects now handle correctly in explore REPL. Supports old style config functions and the new style classes</li> </ul>"},{"location":"CHANGELOG/#101","title":"1.0.1","text":"<ul> <li>Correct package installation dependencies.</li> </ul>"},{"location":"CHANGELOG/#100","title":"1.0.0","text":""},{"location":"CHANGELOG/#2025-12-27","title":"2025-12-27","text":"<p>Version 1.0.0 represents 12 months of work, planning, testing and using clientele with real APIs. It has major new features and some breaking changes. I recommend completely deleting your previous clients and rebuilding to ensure a smooth rollout.</p> <p>For most of this year I've been constrained by a lack of time to build the features I have planned. With the assistance of supervised agents I have been able to build out most of what I needed, and then spent time correcting and improving the agent's code to be functionally correct.</p> <p>The productivity boost has been immense and has helped me to realise the goals and ambitions I have for this project.</p>"},{"location":"CHANGELOG/#major-new-features","title":"Major new features","text":"<ul> <li>\ud83c\udd95 Explorer CLI: Use <code>clientele explore</code> to use a REPL and discover APIs interactively, even without writing any code.</li> <li>\u2699\ufe0f Rebuilt configuration: <code>config.py</code> has been re-engineered to use pydantic settings.</li> <li>\ud83d\udcdc Rebuilt parser - parsing OpenAPI schema into python objects is now handled entirely by Cicerone, our own OpenAPI parser that was built to meet our unique needs.</li> <li>Clientele now specifically offers 100% support for all major Python API frameworks: FastAPI, Django REST Framework, and Django-Ninja.</li> <li>Clientele is now tested and proven to generate clients for 2000+ openapi schemas as part of our CI. It runs weekly and we use it to ensure broad capability with all OpenAPI services.</li> </ul>"},{"location":"CHANGELOG/#clientele-code-generation-improvements","title":"Clientele code generation improvements","text":"<ul> <li>Fixed function parameter ordering (required parameters before optional ones).</li> <li>Nullable fields properly handled (OpenAPI 3.0 <code>nullable: true</code> and OpenAPI 3.1 array type notation)</li> <li>Fixed: Array responses without a <code>title</code> field now correctly generate type aliases instead of wrapper classes with a <code>test</code> property.</li> <li>Fixed: Responses with no content (e.g., 204 No Content) are now properly included in the status code map with <code>None</code> as the response type.</li> <li>Correctly handle reserved python keywords for schema model properties (i.e. <code>type</code>, <code>next</code> etc).</li> <li>New: Extended httpx configuration options in generated clients - timeout, follow_redirects, verify_ssl, http2, and max_redirects are now configurable.</li> <li>Removed the <code>validate</code> command from the CLI.</li> <li>Replaced <code>openapi-core</code> dependency with <code>cicerone==0.3.0</code> for OpenAPI schema parsing and introspection. This change provides faster, more minimal, and fully typed OpenAPI schema handling.</li> <li>New: Support for OpenAPI <code>deprecated</code> field - operations marked as deprecated will include deprecation warnings in generated docstrings.</li> <li>New: Support for OpenAPI <code>description</code> field - operation descriptions are now included in generated function docstrings for better documentation.</li> <li>Clientele is 100% typed, including the generated code, and verified using ty instead of mypy.</li> <li>Updated all dependencies to their latest stable versions.</li> </ul>"},{"location":"CHANGELOG/#0100","title":"0.10.0","text":"<ul> <li>New: Class-based client generator! Use <code>clientele generate-class</code> to generate a client with a <code>Client</code> class and methods instead of standalone functions.</li> <li>Class-based clients support both sync and async modes with <code>--asyncio t</code> flag.</li> <li>Class-based clients are perfect for object-oriented codebases and when you need to mock the client for testing.</li> <li>New: Dynamic configuration for class-based clients! Class-based clients now accept a <code>Config</code> object in their constructor, allowing you to create multiple clients with different configurations on the fly.</li> <li>The <code>config.py</code> file in class-based clients now generates a <code>Config</code> class instead of standalone functions, enabling runtime configuration changes.</li> <li>You can now instantiate clients with custom configuration: <code>client = Client(config=Config(api_base_url=\"https://api.example.com\", bearer_token=\"my-token\"))</code>.</li> <li>This addresses issues #42 and #49, enabling dynamic auth tokens and multiple clients with different configurations.</li> <li>Updated documentation with comprehensive examples of class-based client usage.</li> <li>Added <code>generate-class</code> command to CLI with full feature parity to the standard <code>generate</code> command.</li> <li>Add ABC (Abstract Base Class) pattern to generators with a <code>Generator</code> base class that all generators inherit from.</li> <li>Refactored all imports to import modules.</li> <li>Changed: Generated code is now auto-formatted with Ruff instead of Black.</li> <li>Breaking change for class-based clients: The <code>config.py</code> file structure has changed from functions to a class. Existing generated clients will need to be regenerated with <code>--regen t</code>.</li> <li>Fixed: OpenAPI <code>number</code> type now correctly maps to Python <code>float</code> instead of <code>int</code>. The <code>integer</code> type continues to map to <code>int</code>, and <code>number</code> with <code>format: \"decimal\"</code> continues to map to <code>decimal.Decimal</code>. This addresses issue #40.</li> <li>New: Python 3.13 and Python 3.14 support! Clientele and all generated clients now officially support Python 3.10, 3.11, 3.12, 3.13, and 3.14.</li> <li>Python 3.9 support has been dropped. If you need Python 3.9 support, please use version 0.9.0 or earlier.</li> </ul>"},{"location":"CHANGELOG/#090","title":"0.9.0","text":"<ul> <li>Support <code>patch</code> methods</li> <li>Fix <code>config.py</code> file being overwritten when generating new clients</li> </ul>"},{"location":"CHANGELOG/#083","title":"0.8.3","text":"<ul> <li>Fix bug with headers assignment</li> </ul>"},{"location":"CHANGELOG/#082","title":"0.8.2","text":"<ul> <li>Improved json support</li> </ul>"},{"location":"CHANGELOG/#081","title":"0.8.1","text":"<ul> <li>Function parameters no longer format to snake_case to maintain consistency with the OpenAPI schema.</li> </ul>"},{"location":"CHANGELOG/#080","title":"0.8.0","text":"<ul> <li>Improved support for Async clients which prevents a weird bug when running more than one event loop. Based on the suggestions from this httpx issue.</li> <li>We now use <code>ruff format</code> for coding formatting (not the client output).</li> <li><code>Decimal</code> support now extends to Decimal input values.</li> <li>Input and Output schemas will now have properties that directly match those provided by the OpenAPI schema. This fixes a bug where previously, the snake-case formatting did not match up with what the API expected to send or receive.</li> </ul>"},{"location":"CHANGELOG/#071","title":"0.7.1","text":"<ul> <li>Support for <code>Decimal</code> types.</li> </ul>"},{"location":"CHANGELOG/#070","title":"0.7.0","text":"<ul> <li>Updated all files to use the templates engine.</li> <li>Generator files have been reorganised in clientele to support future templates.</li> <li><code>constants.py</code> has been renamed to <code>config.py</code> to better reflect how it is used. It is not generated from a template like the other files.</li> <li>If you are using Python 3.10 or later, the <code>typing.Unions</code> types will generate as the short hand <code>|</code> instead.</li> <li>To regenerate a client (and to prevent accidental overrides) you must now pass <code>--regen t</code> or <code>-r t</code> to the <code>generate</code> command. This is automatically added to the line in <code>MANIFEST.md</code> to help.</li> <li>Clientele will now automatically run black code formatter once a client is generated or regenerated.</li> <li>Clientele will now generate absolute paths to refer to adjacent files in the generated client, instead of relative paths. This assumes you are running the <code>clientele</code> command in the root directory of your project.</li> <li>A lot of documentation and docs strings updates so that code in the generated client is easier to understand.</li> <li>Improved the utility for snake-casing enum keys. Tests added for the functions.</li> <li>Python 3.12 support.</li> <li>Add a \"basic\" client using the command <code>generate-basic</code>. This can be used to keep a consistent file structure for an API that does not use OpenAPI.</li> </ul>"},{"location":"CHANGELOG/#063","title":"0.6.3","text":"<ul> <li>Packaged application installs in the correct location. Resolving #6</li> <li>Updated pyproject.toml to include a better selection of links.</li> </ul>"},{"location":"CHANGELOG/#062","title":"0.6.2","text":"<ul> <li>Ignore optional URL query parameters if they are <code>None</code>.</li> </ul>"},{"location":"CHANGELOG/#061","title":"0.6.1","text":"<ul> <li>Added <code>from __future__ import annotations</code> in files to help with typing evaluation.</li> <li>Update to use pydantic 2.4.</li> <li>A bunch of documentation and readme updates.</li> <li>Small wording and grammar fixes.</li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":"<ul> <li>Significantly improved handling for response schemas. Responses from API endpoints now look at the HTTP status code to pick the correct response schema to generate from the HTTP json data. When regenerating, you will notice a bit more logic generated in the <code>http.py</code> file to handle this.</li> <li>Significantly improved coverage of exceptions raised when trying to generate response schemas.</li> <li>Response types for a class are now sorted.</li> <li>Fixed a bug where <code>put</code> methods did not generate input data correctly.</li> </ul>"},{"location":"CHANGELOG/#052","title":"0.5.2","text":"<ul> <li>Fix pathing for <code>constants.py</code> - thanks to @matthewknight for the contribution!</li> <li>Added <code>CONTRIBUTORS.md</code></li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<ul> <li>Support for HTTP PUT methods</li> <li>Headers objects use <code>exclude_unset</code> to avoid passing <code>None</code> values as headers, which httpx does not support.</li> </ul> <p>Additionally, an async test client is now included in the test suite. It has identical tests to the standard one but uses the async client instead.</p>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":""},{"location":"CHANGELOG/#please-delete-the-constantspy-file-when-updating-to-this-version-to-have-new-features-take-affect","title":"Please delete the constants.py file when updating to this version to have new features take affect","text":"<ul> <li>Paths are resolved correctly when generating clients in nested directories.</li> <li><code>additional_headers()</code> is now applied to every client, allowing you to set up headers for all requests made by your client.</li> <li>When the client cannot match an HTTP response to a return type for the function it will now raise an <code>http.APIException</code>. This object will have the <code>response</code> attached to it for inspection by the developer.</li> <li><code>MANIFEST</code> is now renamed to <code>MANIFEST.md</code> and will include install information for Clientele, as well as information on the command used to generate the client.</li> </ul>"},{"location":"CHANGELOG/#044","title":"0.4.4","text":"<p>Examples and documentation now includes a very complex example schema built using FastAPI that offers the following variations:</p> <ul> <li>Simple request / response (no input just an output)</li> <li>A request with a URL/Path parameter.</li> <li>Models with <code>int</code>, <code>str</code>, <code>list</code>, <code>dict</code>, references to other models, enums, and <code>list</code>s of other models and enums.</li> <li>A request with query parameters.</li> <li>A response model that has optional parameters.</li> <li>An HTTP POST request that takes an input model.</li> <li>An HTTP POST request that takes path parameters and also an input model.</li> <li>An HTTP GET request that requires an HTTP header, and returns it.</li> <li>An HTTP GET endpoint that returns the HTTP bearer authorization token (also makes clientele generate the http authentication for this schema).</li> </ul> <p>A huge test suite has been added to the CI pipeline for this project using a copy of the generated client from the schema above.</p>"},{"location":"CHANGELOG/#043","title":"0.4.3","text":"<ul> <li><code>Enums</code> now inherit from <code>str</code> as well so that they serialize to JSON properly. See this little nugget.</li> </ul>"},{"location":"CHANGELOG/#042","title":"0.4.2","text":"<ul> <li>Correctly use <code>model_rebuild</code> for complex schemas where there are nested schemas, his may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema.</li> <li>Do not raise for status, instead attempt to return the response if it cannot match a response type.</li> </ul>"},{"location":"CHANGELOG/#041","title":"0.4.1","text":"<ul> <li>Correctly generate lists of nested schema classes</li> <li>Correctly build response schemas that are emphemeral (such as when they just return an array of other schemas, or when they have no $ref).</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>Change install suggestion to use pipx as it works best as a global CLI tool.</li> <li>Improved support for OpenAPI 3.0.3 schemas (a test version is available in the example_openapi_specs directory).</li> <li><code>validate</code> command for validating an OpenAPI schema will work with clientele.</li> <li><code>version</code> command for showing the current version of clientele.</li> <li>Supports HTTP DELETE methods.</li> <li>Big refactor of how methods are generated to reduce duplicate code.</li> <li>Support optional header parameters in all request functions (where they are required).</li> <li>Very simple Oauth2 support - if it is discovered will set up HTTP Bearer auth for you.</li> <li>Uses <code>dict</code> and <code>list</code> instead of <code>typing.Dict</code> and <code>typing.List</code> respectively.</li> <li>Improved schema generation when schemas have $ref to other models.</li> </ul>"},{"location":"CHANGELOG/#032","title":"0.3.2","text":"<ul> <li>Minor changes to function name generation to make it more consistent.</li> <li>Optional parameters in schemas are working properly.</li> </ul>"},{"location":"CHANGELOG/#031","title":"0.3.1","text":"<ul> <li>Fixes a bug when generating HTTP Authentication schema.</li> <li>Fixes a bug when generating input classes for post functions, when the input schema doesn't exist yet.</li> <li>Generates pythonic function names in clients now, always (like <code>lower_case_snake_case</code>).</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>Now generates a <code>MANIFEST</code> file with information about the build versions</li> <li>Added a <code>constants.py</code> file to the output if one does not exist yet, which can be used to store values that you do not want to change between subsequent re-generations of the clientele client, such as the API base url.</li> <li>Authentication patterns now use <code>constants.py</code> for constants values.</li> <li>Removed <code>ipython</code> from package dependencies and moved to dev dependencies.</li> <li>Documentation! https://phalt.github.io/clientele/</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>Improved CLI output</li> <li>Code organisation is now sensible and not just one giant file</li> <li>Now supports an openapi spec generated from a dotnet project (<code>Microsoft.OpenApi.Models</code>)</li> <li>async client support fully working</li> <li>HTTP Bearer support</li> <li>HTTP Basic support</li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<ul> <li>Initial version</li> <li>Mostly works with a simple FastAPI generated spec (3.0.2)</li> <li>Works with Twilio's spec (see example_openapi_specs/ directory) (3.0.1)</li> <li>Almost works with stripes</li> </ul>"},{"location":"api-async/","title":"\ud83d\udd00 Async support","text":"<p>Clientele API supports both async and sync functions.</p> <p>They can even be mixed in together if you prefer.</p>"},{"location":"api-async/#async-and-sync-example","title":"Async and sync example","text":"<pre><code>from clientele import api as clientele_api\nfrom .my_config import Config\nfrom .my_models import BookResponse, CreateBookResponse, CreateBookRequest\n\nclient = clientele_api.APIClient(config=Config())\n\n@client.post(\"/books\")\ndef create_user(\n    data: CreateBookResponse,\n    result: CreateBookResponse,\n) -&gt; CreateBookResponse:\n    return result\n\n\n# Mix sync and async functions in the same client\n@client.get(\"/book/{book_id}\")\nasync def get_book(book_id: int, result: BookResponse) -&gt; BookResponse:\n    return result\n</code></pre>"},{"location":"api-async/#async-and-sync-usage","title":"Async and sync usage","text":"<pre><code>from my_clientele_client import client, schemas\n\n# handle sync requests\nresponse = client.create_book(\n    data=schemas.CreateBookRequest(title=\"My awesome book\")\n)\n\nmatch response:\n    case schemas.CreateBookResponse():\n        # handle valid response\n    case schemas.ValidationError():\n        # handle errors\n\n# Handle async requests\nbook_response = await client.get_book(book_id=123)\n</code></pre>"},{"location":"api-authentication/","title":"\ud83d\udd10 Authentication","text":"<p>Clientele API supports multiple authentication methods through the client configuration.</p>"},{"location":"api-authentication/#bearer-token","title":"Bearer Token","text":"<p>Bearer token authentication can be configured by adding an <code>Authorization</code> header.</p> <p>Configuration:</p> <pre><code># config.py\nfrom clientele import api as clientele_api\n\nclass Config(clientele_api.BaseConfig):\n    ...\n    headers = {\"Authorization\": \"MY_SECRET_TOKEN\"}\n    ...\n</code></pre>"},{"location":"api-authentication/#http-basic-authentication","title":"HTTP Basic Authentication","text":"<p>Basic authentication can be configured using httpx.Auth:</p> <p>Configuration:</p> <pre><code># config.py\nimport httpx\nfrom clientele import api as clientele_api\nfrom my_settings import AUTH_TOKEN\n\nclass Config(clientele_api.BaseConfig):\n    ...\n    auth = httpx.BasicAuth(\"username\", \"password\")\n    ...\n</code></pre>"},{"location":"api-cache/","title":"\ud83d\udcbe Caching","text":"<p>Clientele provides built-in support for caching HTTP GET requests using the <code>@memoize</code> decorator.</p>"},{"location":"api-cache/#quick-start","title":"Quick Start","text":"<pre><code>from clientele import api, cache\n\nclient = api.APIClient(base_url=\"https://api.example.com\")\n\n@cache.memoize(ttl=300)  # Cache for 5 minutes\n@client.get(\"/users/{id}\")\ndef get_user(id: int, result: dict) -&gt; dict:\n    return result\n\n# First call - hits the API\nuser = get_user(id=123)\n\n# Second call - returns cached result\nuser = get_user(id=123)  # No HTTP request made!\n</code></pre>"},{"location":"api-cache/#how-it-works","title":"How It Works","text":"<p>The <code>@memoize</code> decorator:</p> <ol> <li>Extracts request context from the underlying <code>@client.get()</code> decorator</li> <li>Generates cache keys from the HTTP method, path template, and function parameters</li> <li>Checks the cache before executing the HTTP request</li> <li>Stores results with optional TTL (time-to-live) expiration</li> <li>Respects LRU eviction when the cache reaches its maximum size</li> </ol> <p>GET Requests Only</p> <p>Only use <code>@memoize</code> with GET requests (idempotent operations). POST/PUT/PATCH/DELETE should not be cached as they modify server state.</p>"},{"location":"api-cache/#configuration","title":"Configuration","text":""},{"location":"api-cache/#basic-ttl-time-to-live","title":"Basic TTL (Time-To-Live)","text":"<p>Set how long cached responses remain valid:</p> <pre><code>@memoize(ttl=300)  # 5 minutes\n@client.get(\"/pokemon/{id}\")\ndef get_pokemon(id: int, result: dict) -&gt; dict:\n    return result\n</code></pre>"},{"location":"api-cache/#custom-cache-keys","title":"Custom Cache Keys","text":"<p>Override the default key generation with a custom function:</p> <pre><code>@memoize(\n    ttl=600,\n    key=lambda user_id: f\"user:{user_id}\"  # Custom key format\n)\n@client.get(\"/users/{user_id}\")\ndef get_user(user_id: int, result: dict) -&gt; dict:\n    return result\n</code></pre> <p>The custom key function receives all parameters except <code>result</code> and <code>response</code> (which are injected by Clientele).</p>"},{"location":"api-cache/#conditional-caching","title":"Conditional Caching","text":"<p>Enable or disable caching based on configuration:</p> <pre><code>import os\n\nENABLE_CACHE = os.getenv(\"ENABLE_CACHE\", \"true\") == \"true\"\n\n@memoize(ttl=300, enabled=ENABLE_CACHE)\n@client.get(\"/pokemon/{id}\")\ndef get_pokemon(id: int, result: dict) -&gt; dict:\n    return result\n</code></pre>"},{"location":"api-cache/#custom-backend","title":"Custom Backend","text":"<p>Swap the default in-memory backend for your own:</p> <pre><code>from clientele.cache import memoize, MemoryBackend\n\n# Create a backend with smaller cache size\nsmall_cache = MemoryBackend(max_size=50)\n\n@memoize(ttl=300, backend=small_cache)\n@client.get(\"/items/{id}\")\ndef get_item(id: int, result: dict) -&gt; dict:\n    return result\n</code></pre> <p>Alternatively you can set it through the <code>BaseConfig</code> object to prevent constantly setting it through the decorator:</p> <pre><code>from clientele import api, cache\n\nclient = api.APIClient(config=api.BaseConfig(\n    base_url=\"https://myapi.com/\",\n    # Set to your own backend here\n    cache_backend=cache.MemoryBackend\n))\n\n@cache.memoize(ttl=300)\n@client.get(\"/items/{id}\")\ndef get_item(id: int, result: dict) -&gt; dict:\n    return result\n</code></pre>"},{"location":"api-cache/#async-support","title":"Async Support","text":"<p>The <code>@memoize</code> decorator works seamlessly with async functions:</p> <pre><code>@memoize(ttl=300)\n@client.get(\"/users/{id}\")\nasync def get_user(id: int, result: dict) -&gt; dict:\n    return result\n\n# Usage\nuser = await get_user(id=123)\nuser = await get_user(id=123)  # Cached!\n</code></pre>"},{"location":"api-cache/#cache-key-generation","title":"Cache Key Generation","text":"<p>Cache keys are automatically generated from:</p> <ol> <li>HTTP method - Prepended to the key (e.g., <code>GET:</code>)</li> <li>Path template - The API endpoint path</li> <li>Function parameters - Sorted alphabetically for consistency</li> </ol> <p>Example cache keys:</p> <pre><code># GET /pokemon/{id} with id=25\n# Key: \"GET:/pokemon/{id}:id=25\"\n\n# GET /search with query=\"python\", limit=10\n# Key: \"GET:/search:limit=10:query=python\"\n</code></pre>"},{"location":"api-cache/#excluded-parameters","title":"Excluded Parameters","text":"<p>The following parameters are automatically excluded from cache keys because they are injected by Clientele at runtime:</p> <ul> <li><code>result</code> - The parsed response object</li> <li><code>response</code> - The raw HTTP response</li> <li><code>data</code> - The request body</li> </ul>"},{"location":"api-cache/#writing-a-custom-backend","title":"Writing a Custom Backend","text":"<p>The <code>MemoryBackend</code> is suitable for single-process applications.</p> <p>For production systems, you may want Redis, Memcached, or disk-based caching.</p>"},{"location":"api-cache/#redis-backend-example","title":"Redis Backend example","text":"<p>Implement the <code>CacheBackend</code> protocol:</p> <pre><code>import redis\nfrom typing import Any, Optional\nfrom clientele import cache\n\nclass RedisBackend(cache.CacheBackend):\n    \"\"\"Redis-based cache backend example.\"\"\"\n\n    def __init__(self, redis_url: str):\n        self.redis = redis.from_url(redis_url)\n\n    def get(self, key: str) -&gt; Optional[Any]:\n        \"\"\"Retrieve a value from Redis.\"\"\"\n        import pickle\n        data = self.redis.get(key)\n        if data is None:\n            return None\n        return pickle.loads(data)\n\n    def set(self, key: str, value: Any, ttl: Optional[int] = None) -&gt; None:\n        \"\"\"Store a value in Redis with optional TTL.\"\"\"\n        import pickle\n        serialized = pickle.dumps(value)\n        if ttl is not None:\n            self.redis.setex(key, ttl, serialized)\n        else:\n            self.redis.set(key, serialized)\n\n    def delete(self, key: str) -&gt; None:\n        \"\"\"Remove a value from Redis.\"\"\"\n        self.redis.delete(key)\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear all values (use with caution!).\"\"\"\n        self.redis.flushdb()\n\n    def exists(self, key: str) -&gt; bool:\n        \"\"\"Check if a key exists in Redis.\"\"\"\n        return bool(self.redis.exists(key))\n</code></pre>"},{"location":"api-cache/#using-your-custom-backend","title":"Using Your Custom Backend","text":"<pre><code>from clientele import cache\n\n# Create and configure your backend\nredis_cache = RedisBackend(redis_url=\"redis://localhost:6379/0\")\n\n# Use per-decorator\n@cache.memoize(ttl=300, backend=redis_cache)\n@client.get(\"/users/{id}\")\ndef get_user(id: int, result: dict) -&gt; dict:\n    return result\n</code></pre> <ul> <li>API Configuration - General API client configuration</li> <li>Async Support - Using async/await with Clientele</li> <li>Testing - How to test code that uses caching</li> </ul>"},{"location":"api-configuration/","title":"\u2699\ufe0f Configuration","text":""},{"location":"api-configuration/#base-url","title":"base url","text":"<p>You can configure Clientele with just a <code>base_url</code> and let it use sensible defaults for the client:</p> <pre><code>from clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://myapi.com/v1\")\n</code></pre>"},{"location":"api-configuration/#standard-configuration","title":"Standard configuration","text":"<p>We recommend subclassing <code>BaseConfig</code> and managing your own config:</p> <pre><code>from clientele import api as clientele_api\n\nconfig = clientele_api.BaseConfig(\n    base_url=\"https://api.example.com\",\n    headers={\"Authorization\": \"Bearer &lt;token&gt;\"},\n    timeout=10.0,\n)\nclient = clientele_api.APIClient(config=config)\n</code></pre> <p>The <code>BaseConfig</code> class is powered by pydantic-settings that automatically loads values from environment variables, <code>.env</code> files or just plain hard coded configuration.</p>"},{"location":"api-configuration/#configuration-options","title":"Configuration options","text":"<ul> <li><code>base_url: str</code> - the url for the API server</li> <li><code>headers: dict[str, str]</code> - headers that you want to send with http requests.</li> <li><code>timeout: float | None = 5.0</code> - the time to wait for an HTTP response before closing the connection.</li> <li><code>follow_redirects: bool = False</code> - if redirects should be followed.</li> <li><code>verify: bool | str = True</code> - if SSL connections should be verified.</li> <li><code>http2: bool = False</code> - if http2 should be used for making requests.</li> <li><code>auth: httpx.Auth | tuple[str, str] | None = None</code> - the authentication method for requests.</li> <li><code>limits: httpx.Limits | None = None</code> - the connection pool size for the underlying client.</li> <li><code>proxies: httpx.Proxy | None = None</code> - the proxies for the underlying client.</li> <li><code>transport: httpx.BaseTransport | httpx.AsyncBaseTransport | None = None</code> - custom transport objects for the underlying client.</li> <li><code>cookies: httpx.Cookies | None = None</code> - the cookies you want to send with http requests.</li> <li><code>cache_backend</code> - the cache backend you want to use when caching results.</li> <li><code>http_backend</code> - the http backend you want to use when making HTTP requests.</li> </ul>"},{"location":"api-configuration/#custom-httpx-client","title":"Custom httpx client","text":"<p>You can supply your own <code>httpx.Client</code> and <code>httpx.AsyncClient</code> if you prefer full control:</p> <p>Warning</p> <p>These options are considered deprecated from clientele version 2.0.0 and will not be supported in future versions.</p> <p>Use http backends instead.</p> <pre><code>from clientele import api as clientele_api\nimport httpx\n\nclient = clientele_api.APIClient(\n    base_url=\"https://api.example.com\",\n    httpx_client=httpx.Client(),\n    httpx_async_client=httpx.AsyncClient()\n)\n</code></pre>"},{"location":"api-configuration/#reconfiguration","title":"Reconfiguration","text":"<p>You can reconfigure an existing client (<code>APIClient</code>) at any time using the <code>configure</code> method. This is useful when you want to change options at runtime based on application specific configuration or logic:</p> <pre><code>from clientele import api as clientele_api\nfrom application.config import app_config\n\n# standard configuration\nbase_config = clientele_api.BaseConfig(\n    base_url=\"https://api.example.com\",\n    timeout=10.0,\n)\nclient = clientele_api.APIClient(config=base_config)\n\n@client.get(\"/users/{user_id}\")\ndef get_user(user_id: int, result: User) -&gt; User:\n    return result\n\nclass MyApplication:\n    def __init__(self, api_client: clientele_api.APIClient):\n        self.api_client = api_client\n\n    def run(self):\n        # get configuration from application settings\n        url = app_config.url\n        token = app_config.token\n\n        # reconfigure the client with new settings\n        self.api_client.configure(\n            clientele_api.BaseConfig(\n                base_url=url,\n                headers={\"Authorization\": f\"Bearer {token}\"},\n            )\n        )\n        # proceed with using the api client as usual after reconfiguration\n        get_user(user_id=123)\n\n\nif __name__ == \"__main__\":\n    app = MyApplication(api_client=client)\n    app.run()\n</code></pre> <p>The <code>configure</code> method accepts the same parameters as the <code>APIClient</code> constructor.</p>"},{"location":"api-direct-requests/","title":"\ud83c\udfaf Direct requests","text":"<p>Clientele allows you to make direct requests without decorating functions.</p> <p>This approach is useful if you want to make ad-hoc requests but still want the data validation and response hydration.</p>"},{"location":"api-direct-requests/#get-requests","title":"GET requests","text":"<pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\nclass Pokemon(BaseModel):\n    name: str\n    height: int\n    weight: int\n\nresult = client.request(\n    \"GET\",\n    \"/pokemon/{pokemon_id}\",\n    response_map={200: Pokemon},\n    pokemon_id=1\n)\n</code></pre> <ul> <li>The <code>response_map</code> parameter is required</li> <li>Additional kwargs are mapped to the path parameter</li> </ul>"},{"location":"api-direct-requests/#post-requests","title":"POST requests","text":"<pre><code>result = client.request(\n    \"POST\",\n    \"/pokemon\",\n    response_map={201: Pokemon},\n    data=CreatePokemonRequest(name=\"PikachuTew\")\n)\n</code></pre>"},{"location":"api-direct-requests/#async","title":"Async","text":"<p>The <code>arequest</code> method provides an identical interface but in an async context.</p>"},{"location":"api-direct-requests/#trade-offs","title":"Trade-offs","text":"<p>This approach is intended for smaller ad-hoc requests.</p> <p>This approach misses all of the benefits of binding to a decorated function:</p> <ul> <li>Strongly typed inputs for input parameters</li> <li>An abstract functional interface to the API</li> <li>Streaming responses are not supported</li> </ul> <p>This approach still retains:</p> <ul> <li>Strongly typed responses</li> <li>Data validation on the responses</li> <li>Hydration of the responses</li> </ul>"},{"location":"api-examples/","title":"\ud83c\udfaa Clientele by example","text":"<p>All these examples can be copied and pasted into a file and run in a python application.</p>"},{"location":"api-examples/#simple-get-request","title":"Simple GET request","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: dict) -&gt; dict:\n    return result\n</code></pre> <ul> <li>The simplest logic you can do with Clientele.</li> <li>No validation will be ran on the data.</li> </ul>"},{"location":"api-examples/#receive-specific-data-in-result","title":"Receive specific data in result","text":"<pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass PokemonInfo(BaseModel):\n    name: str\n    id: int\n\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: PokemonInfo) -&gt; PokemonInfo:\n    return result\n</code></pre> <ul> <li>Use Pydantic <code>BaseModel</code> to return only the data you want in the <code>result</code> parameter.</li> <li>Pydantic's <code>model_validate</code> will be ran against the <code>response.json</code>.</li> <li>Only values explicitly declared in the <code>BaseModel</code> will be returned.</li> </ul>"},{"location":"api-examples/#return-specific-data-after-result","title":"Return specific data after result","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: dict) -&gt; str:\n    return result.get(\"name\")\n</code></pre> <ul> <li>The return type of the decorated function does not need to match the <code>result</code> parameter.</li> <li>You can return whatever you like.</li> <li>This is also a good time to do logging, persistence of results, dispatching post-request actions, etc.</li> </ul>"},{"location":"api-examples/#query-parameters","title":"Query parameters","text":""},{"location":"api-examples/#using-parameters","title":"Using parameters","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/\")\ndef get_pokemon_page(result: dict, limit: int, offset: int) -&gt; dict:\n    return result\n</code></pre> <pre><code>get_pokemon_page(limit=10, offset=30)\n</code></pre> <ul> <li>Parameters not declared in the path string will instead become query parameters.</li> <li>Optional or <code>None</code> values will be ignored.</li> </ul>"},{"location":"api-examples/#using-query-dict","title":"Using query dict","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/\")\ndef get_pokemon_page(result: dict) -&gt; dict:\n    return result\n</code></pre> <pre><code>get_pokemon_page(query={\"limit\": 10, \"offset\": 30})\n</code></pre> <ul> <li>You can pass a dict <code>query</code> to achieve the same results.</li> <li>This does not need to be declared in your decorated function.</li> </ul>"},{"location":"api-examples/#simple-post-request","title":"Simple POST request","text":"<pre><code>from clientele import api\n\nclient = api.APIClient(base_url=\"https://httpbin.org\")\n\n\n@client.post(\"/post\")\ndef post_input_data(data: dict, result: dict) -&gt; dict:\n    return result\n</code></pre> <ul> <li>The <code>data</code> parameter is serialized to JSON and sent in an HTTP POST request.</li> <li>This pattern is identical in <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> decorators functions.</li> </ul>"},{"location":"api-examples/#data-validation","title":"Data validation","text":"<pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://httpbin.org\")\n\n\nclass InputData(BaseModel):\n    name: str\n    email: str\n\n\n@client.post(\"/post\")\ndef post_input_data(data: InputData, result: dict) -&gt; InputData:\n    return result\n</code></pre> <ul> <li>Pydantic will run <code>model_validate</code> on the <code>data</code> parameter before sending the HTTP POST request.</li> <li>This pattern is identical in <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> decorators functions.</li> </ul>"},{"location":"api-examples/#inspect-http-responses","title":"Inspect HTTP responses","text":"<pre><code>from clientele import api\nimport httpx\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/{pokemon_name}\")\ndef get_pokemon_info(pokemon_name: str, result: dict, response: httpx.Response) -&gt; dict:\n    print(response.headers)\n    return result\n</code></pre> <ul> <li>Pass the <code>response</code> parameter to the decorated function to receive the <code>httpx.Response</code> object.</li> </ul>"},{"location":"api-examples/#control-response-parsing","title":"Control response parsing","text":""},{"location":"api-examples/#using-a-callback","title":"Using a callback","text":"<pre><code>from clientele import api\nimport httpx\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\ndef parse_response_myself(response: httpx.Response) -&gt; dict:\n    data = response.json()\n    return {\n        \"my_custom_key\": data[\"name\"],\n    }\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_parser=parse_response_myself)\ndef get_pokemon_info(pokemon_name: str, result: dict) -&gt; str:\n    return result[\"my_custom_key\"]\n</code></pre> <ul> <li>Pass a callable to the <code>response_parser</code> parameter to control how http responses are parsed.</li> <li>Clientele will no longer handle any data validation for you, but you have complete control.</li> <li>The return type of this callback must match the type of the <code>result</code> parameter.</li> </ul>"},{"location":"api-examples/#using-strong-types","title":"Using strong types","text":"<pre><code>from clientele import api\nimport httpx\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass MyResult(BaseModel):\n    custom_key: str\n\n\ndef parse_response_myself(response: httpx.Response) -&gt; MyResult:\n    data = response.json()\n    return MyResult(\n        custom_key=data[\"name\"],\n    )\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_parser=parse_response_myself)\ndef get_pokemon_info(pokemon_name: str, result: MyResult) -&gt; str:\n    return result.custom_key\n</code></pre>"},{"location":"api-examples/#using-a-map","title":"Using a map","text":"<pre><code>import httpx\nfrom pydantic import BaseModel\n\nfrom clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass OkResult(BaseModel):\n    name: str\n\nclass NotFoundResult(BaseModel):\n    name: str\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_map={200: OkResult, 404: NotFoundResult})\ndef get_pokemon_info(pokemon_name: str, result: OkResult | NotFoundResult) -&gt; str:\n    return result.name\n</code></pre> <ul> <li>The <code>response_map</code> accepts <code>{int: ResponseModel}</code>.</li> <li>The HTTP response status code will be matched against the model and used as validation.</li> <li>If the http response does not match any status codes in the <code>response_map</code> then an <code>clientele.api.APIException</code> exception will be raised.</li> </ul>"},{"location":"api-examples/#handling-errors","title":"Handling errors","text":"<pre><code>from pydantic import BaseModel\n\nfrom clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\nclass OnlyErrorResult(BaseModel):\n    name: str\n\n\n@client.get(\"/pokemon/{pokemon_name}\", response_map={500: OnlyErrorResult})\ndef get_pokemon_info(pokemon_name: str, result: OnlyErrorResult) -&gt; str:\n    return result.name\n\n\ntry:\n    get_pokemon_info(\"pikachu\")\nexcept api.APIException as e:\n    print(f\"Error occurred: {e.reason}\")\n    print(f\"Response details: {e.response}\")\n</code></pre> <ul> <li>Unexpected response statuses will throw an <code>clientele.api.APIException</code> exception.</li> <li>If there is no <code>response_map</code> provided then Clientele will call <code>raise_for_status</code> on the <code>httpx.Response</code> object.</li> <li>If <code>response_map</code> is provided then the <code>httpx.Response</code> status code must match one of the keys.</li> <li>The <code>APIException</code> will have a human readable <code>reason</code>.</li> <li>The <code>APIException</code> will also have the <code>httpx.Response</code> that raised the exception for inspection.</li> </ul>"},{"location":"api-examples/#configuration","title":"Configuration","text":""},{"location":"api-examples/#using-baseconfig","title":"Using BaseConfig","text":"<pre><code>from clientele import api\nimport httpx\n\nmy_config = api.BaseConfig(base_url=\"https://httpbin.org\")\n\nclient = api.APIClient(config=my_config)\n\n\n@client.get(\"/get\")\ndef my_function(result: dict) -&gt; dict:\n    return result\n</code></pre> <ul> <li>Instead of providing <code>base_url</code> to <code>APIClient</code> you can instead provide a <code>BaseConfig</code> object.</li> <li>This gives you simplified access to common http configuration options.</li> </ul>"},{"location":"api-examples/#custom-headers","title":"Custom headers","text":"<pre><code>from clientele import api\nimport httpx\n\nmy_config = api.BaseConfig(\n    base_url=\"https://httpbin.org\", \n    headers={\"Custom-Header\": \"Hello, Clientele!\"}\n)\n\nclient = api.APIClient(config=my_config)\n\n\n@client.get(\"/get\")\ndef return_headers(result: dict) -&gt; str:\n    \"\"\"httpbin returns the headers it received.\"\"\"\n    return result[\"headers\"][\"Custom-Header\"]\n</code></pre> <ul> <li>Headers can be configured through <code>BaseConfig</code>.</li> <li>See full configuration options here.</li> </ul>"},{"location":"api-examples/#async","title":"Async","text":""},{"location":"api-examples/#make-multiple-requests-in-parallel","title":"Make multiple requests in parallel","text":"<pre><code>import asyncio\nfrom clientele import api\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n\n@client.get(\"/pokemon/{pokemon_id}\")\nasync def get_pokemon_name(pokemon_id: int, result: dict) -&gt; str:\n    return result[\"name\"]\n\n\nasync def gather():\n    async_tasks = [get_pokemon_name(pokemon_id=i) for i in range(1, 152)]\n    return await asyncio.gather(*async_tasks)\n\n\ndef get_all_pokemon_names():\n    return asyncio.run(gather())\n</code></pre> <ul> <li>Use the common <code>gather</code> / <code>run</code> pattern to build modular API calls with Clientele.</li> <li>This example executes 151 HTTP requests in parallel.</li> </ul>"},{"location":"api-examples/#caching","title":"Caching","text":""},{"location":"api-examples/#simple-caching-example","title":"Simple caching example","text":"<pre><code>from clientele import api, cache\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@cache.memoize(ttl=300)  # Cache for 5 minutes\n@client.get(\"/pokemon/{pokemon_id}\")\ndef get_pokemon(pokemon_id: int, result: dict) -&gt; dict:\n    return result\n</code></pre> <pre><code># First call - hits the API\npikachu = get_pokemon(pokemon_id=25)\n\n# Second call - returns cached result (no HTTP request)\npikachu_cached = get_pokemon(pokemon_id=25)\n</code></pre>"},{"location":"api-examples/#caching-paginated-results","title":"Caching Paginated Results","text":"<pre><code>from clientele import api, cache\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@cache.memoize(ttl=300)\n@client.get(\"/pokemon\")\ndef list_pokemon(limit: int, offset: int, result: dict) -&gt; dict:\n    return result\n</code></pre> <pre><code># Each limit/offset combination is cached separately\npage1 = list_pokemon(limit=20, offset=0)\npage2 = list_pokemon(limit=20, offset=20)\npage1_again = list_pokemon(limit=20, offset=0)  # Cached!\n</code></pre>"},{"location":"api-examples/#caching-with-query-parameters","title":"Caching with Query Parameters","text":"<pre><code>from clientele import api, cache\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@cache.memoize(ttl=600)\n@client.get(\"/ability\")\ndef list_abilities(limit: int, offset: int, result: dict) -&gt; dict:\n    return result\n</code></pre> <pre><code># Different query params = different cache entries\nabilities1 = list_abilities(limit=10, offset=0)\nabilities2 = list_abilities(limit=20, offset=0)  # Different cache entry\nabilities3 = list_abilities(limit=10, offset=0)  # Uses cached abilities1\n</code></pre>"},{"location":"api-examples/#namespace-isolation-with-custom-keys","title":"Namespace Isolation with Custom Keys","text":"<pre><code>from clientele import api, cache\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n@cache.memoize(\n    ttl=300,\n    key=lambda pokemon_id, version_id: f\"pokemon:{pokemon_id}:version:{version_id}\"\n)\n@client.get(\"/pokemon/{pokemon_id}\")\ndef get_pokemon_version(pokemon_id: int, version_id: int, result: dict) -&gt; dict:\n    # Custom key ensures different versions are cached separately\n    return result\n</code></pre> <pre><code># Each pokemon/version combination has its own cache entry\nred_pikachu = get_pokemon_version(pokemon_id=25, version_id=1)\nblue_pikachu = get_pokemon_version(pokemon_id=25, version_id=2)\n</code></pre>"},{"location":"api-examples/#short-lived-cache-for-rate-limiting","title":"Short-Lived Cache for Rate Limiting","text":"<pre><code>from clientele import api, cache\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\n# Cache for just 10 seconds to reduce burst traffic\n@cache.memoize(ttl=10)\n@client.get(\"/pokemon/{pokemon_id}\")\ndef get_pokemon_burst(pokemon_id: int, result: dict) -&gt; dict:\n    return result\n</code></pre> <pre><code># Multiple rapid calls within 10 seconds use cache\nfor _ in range(100):\n    get_pokemon_burst(pokemon_id=25)  # Only makes 1 HTTP request\n</code></pre>"},{"location":"api-examples/#streaming","title":"Streaming","text":""},{"location":"api-examples/#basic-server-sent-events-example","title":"Basic Server Sent Events example","text":"<pre><code>from typing import AsyncIterator\n\nfrom clientele import api\nfrom pydantic import BaseModel\n\n\nclient = api.APIClient(base_url=\"https://httpbin.org\")\n\n\nclass Event(BaseModel):\n    id: int\n    url: str\n\n\n@client.get(\"/stream/{n}\", streaming_response=True)\nasync def stream_events(n: int, result: AsyncIterator[Event]) -&gt; AsyncIterator[Event]:\n    return result\n</code></pre> <pre><code>async for event in await stream_events(n=4):\n    print(event)\n</code></pre> <p>See Streaming for more.</p>"},{"location":"api-examples/#direct-requests","title":"Direct requests","text":"<pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://pokeapi.co/api/v2\")\n\nclass Pokemon(BaseModel):\n    name: str\n    height: int\n    weight: int\n\n# Direct GET request\nresult = client.request(\n    \"GET\",\n    \"/pokemon/{pokemon_id}\",\n    response_map={200: Pokemon},\n    pokemon_id=1\n)\n</code></pre> <p>See direct requests for more.</p>"},{"location":"api-exceptions/","title":"\ud83d\udea8 Exception Handling","text":"<p>Clientele will handle unexpected API responses by raising an <code>APIException</code>.</p>"},{"location":"api-exceptions/#when-apiexception-is-raised","title":"When APIException is Raised","text":"<p>The <code>APIException</code> is raised when the API returns a response code that doesn't match any of the expected response codes defined in the OpenAPI schema for that endpoint.</p> <p>Each API function has a mapping of expected response codes to response types. If the actual response code isn't in this mapping, Clientele raises an <code>APIException</code> instead of trying to parse the response.</p>"},{"location":"api-exceptions/#catching-apiexception","title":"Catching APIException","text":"<p>Import <code>APIException</code> from your client's <code>http</code> module:</p> <pre><code>from my_client import client, http\n\ntry:\n    user = client.get_user(user_id=999)\nexcept http.APIException as e:\n    # Handle unexpected response\n    print(f\"Unexpected status: {e.response.status_code}\")\n    print(f\"Response body: {e.response.text}\")\n</code></pre>"},{"location":"api-exceptions/#exception-attributes","title":"Exception Attributes","text":"<p>The <code>APIException</code> provides access to:</p> <ul> <li><code>response</code>: The raw <code>httpx.Response</code> object for debugging</li> <li><code>reason</code>: A string explaining why the exception was raised</li> </ul> <pre><code>try:\n    user = client.get_user(user_id=999)\nexcept http.APIException as e:\n    print(f\"Reason: {e.reason}\")\n    print(f\"Status: {e.response.status_code}\")\n    print(f\"Headers: {e.response.headers}\")\n    print(f\"Body: {e.response.text}\")\n</code></pre>"},{"location":"api-exceptions/#common-scenarios","title":"Common Scenarios","text":""},{"location":"api-exceptions/#server-error-500","title":"Server Error (500)","text":"<p>If the API returns a 500 error and it's not defined in the schema:</p> <pre><code>try:\n    result = client.create_user(data=user_data)\nexcept http.APIException as e:\n    if e.response.status_code &gt;= 500:\n        # Server error - retry logic\n        logger.error(f\"Server error: {e.response.status_code}\")\n</code></pre>"},{"location":"api-exceptions/#unexpected-client-error","title":"Unexpected Client Error","text":"<p>If the API returns an error code you didn't expect:</p> <pre><code>try:\n    result = client.delete_user(user_id=123)\nexcept http.APIException as e:\n    if e.response.status_code == 403:\n        # Not defined in schema, but API returned it\n        logger.warning(\"Permission denied\")\n    elif e.response.status_code == 404:\n        logger.info(\"User not found\")\n</code></pre>"},{"location":"api-exceptions/#best-practices","title":"Best Practices","text":"<ol> <li>Always catch APIException when calling API functions that might return unexpected responses</li> <li>Log the full response for debugging - it contains valuable information</li> <li>Check the OpenAPI schema if you consistently get <code>APIException</code> for a specific endpoint - the schema might be incomplete</li> <li>Use pattern matching (Python 3.10+) for clean error handling:</li> </ol> <pre><code>try:\n    result = client.get_user(user_id=999)\nexcept http.APIException as e:\n    match e.response.status_code:\n        case 404:\n            print(\"User not found\")\n        case 500:\n            print(\"Server error\")\n        case _:\n            print(f\"Unexpected error: {e.response.status_code}\")\n</code></pre>"},{"location":"api-graphql/","title":"\ud83e\uddec GraphQL Client","text":"<p>Clientele provides a specialized <code>GraphQLClient</code> for building GraphQL integrations following the same decorator pattern as the standard <code>APIClient</code>.</p>"},{"location":"api-graphql/#basic-query","title":"Basic Query","text":"<pre><code>from pydantic import BaseModel\nfrom clientele.graphql import GraphQLClient\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\nclass Repository(BaseModel):\n    name: str\n    stargazerCount: int\n\nclass RepositoryQueryData(BaseModel):\n    repository: Repository\n\nclass RepositoryQueryResponse(BaseModel):\n    data: RepositoryQueryData\n\n@client.query(\"\"\"\n    query($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n            name\n            stargazerCount\n        }\n    }\n\"\"\")\ndef get_repo(owner: str, name: str, result: RepositoryQueryResponse) -&gt; Repository:\n    return result.data.repository\n\nrepo = get_repo(owner=\"phalt\", name=\"clientele\")\nprint(repo.name)  # \"clientele\"\nprint(repo.stargazerCount)  # 100\n</code></pre> <p>How it works:</p> <ul> <li>The GraphQL query string is passed to the <code>@client.query()</code> decorator.</li> <li>Function parameters (excluding <code>result</code> and <code>response</code>) become GraphQL variables.</li> <li>The <code>result</code> parameter is auto-hydrated to the specified Pydantic model matching GraphQL's response structure.</li> <li>GraphQL wraps all responses in <code>{\"data\": {...}}</code>, so your models should reflect this nested structure.</li> </ul>"},{"location":"api-graphql/#basic-mutation","title":"Basic Mutation","text":"<pre><code>from pydantic import BaseModel\nfrom clientele.graphql import GraphQLClient\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\nclass Issue(BaseModel):\n    id: str\n    title: str\n\nclass CreateIssueData(BaseModel):\n    issue: Issue\n\nclass CreateIssueMutationData(BaseModel):\n    createIssue: CreateIssueData\n\nclass CreateIssueMutationResponse(BaseModel):\n    data: CreateIssueMutationData\n\n@client.mutation(\"\"\"\n    mutation($title: String!, $body: String!) {\n        createIssue(input: {title: $title, body: $body}) {\n            issue {\n                id\n                title\n            }\n        }\n    }\n\"\"\")\ndef create_issue(title: str, body: str, result: CreateIssueMutationResponse) -&gt; Issue:\n    return result.data.createIssue.issue\n\nissue = create_issue(title=\"Bug report\", body=\"Something is broken\")\nprint(issue.id)  # \"123\"\nprint(issue.title)  # \"Bug report\"\n</code></pre>"},{"location":"api-graphql/#optional-parameters","title":"Optional Parameters","text":"<p>GraphQL variables that are optional (nullable) should use Python's <code>| None</code> type annotation. When a parameter is <code>None</code>, it will be omitted from the variables object following GraphQL best practices.</p> <pre><code>from pydantic import BaseModel\nfrom clientele.graphql import GraphQLClient\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\nclass Repository(BaseModel):\n    name: str\n    language: str | None = None\n\nclass RepositoriesQueryData(BaseModel):\n    repositories: list[Repository]\n\nclass RepositoriesQueryResponse(BaseModel):\n    data: RepositoriesQueryData\n\n@client.query(\"\"\"\n    query($owner: String!, $language: String) {\n        repositories(owner: $owner, language: $language) {\n            name\n            language\n        }\n    }\n\"\"\")\ndef search_repos(owner: str, language: str | None, result: RepositoriesQueryResponse) -&gt; list[Repository]:\n    return result.data.repositories\n\n# Call without optional parameter - language is omitted from variables\nrepos = search_repos(owner=\"phalt\")\n\n# Call with optional parameter - language is included\npython_repos = search_repos(owner=\"phalt\", language=\"Python\")\n</code></pre> <p>Note: Passing <code>None</code> omits the variable entirely rather than sending <code>null</code>, which is the recommended GraphQL pattern for optional variables.</p>"},{"location":"api-graphql/#async-support","title":"Async Support","text":"<p>Both queries and mutations support async operations. Simply define your decorated function as <code>async def</code>:</p> <pre><code>from pydantic import BaseModel\nfrom clientele.graphql import GraphQLClient\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\nclass Repository(BaseModel):\n    name: str\n    stargazerCount: int\n\nclass RepositoryQueryData(BaseModel):\n    repository: Repository\n\nclass RepositoryQueryResponse(BaseModel):\n    data: RepositoryQueryData\n\n@client.query(\"\"\"\n    query($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n            name\n            stargazerCount\n        }\n    }\n\"\"\")\nasync def get_repo(owner: str, name: str, result: RepositoryQueryResponse) -&gt; Repository:\n    return result.data.repository\n\n# Use with await\nrepo = await get_repo(owner=\"phalt\", name=\"clientele\")\n</code></pre>"},{"location":"api-graphql/#async-mutations","title":"Async Mutations","text":"<pre><code>from pydantic import BaseModel\nfrom clientele.graphql import GraphQLClient\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\nclass Issue(BaseModel):\n    id: str\n    title: str\n\nclass CreateIssueData(BaseModel):\n    issue: Issue\n\nclass CreateIssueMutationData(BaseModel):\n    createIssue: CreateIssueData\n\nclass CreateIssueMutationResponse(BaseModel):\n    data: CreateIssueMutationData\n\n@client.mutation(\"\"\"\n    mutation($title: String!, $body: String) {\n        createIssue(input: {title: $title, body: $body}) {\n            issue {\n                id\n                title\n            }\n        }\n    }\n\"\"\")\nasync def create_issue(title: str, body: str | None, result: CreateIssueMutationResponse) -&gt; Issue:\n    return result.data.createIssue.issue\n\n# Use with await\nissue = await create_issue(title=\"Bug report\", body=None)\n</code></pre>"},{"location":"api-graphql/#inspecting-the-response","title":"Inspecting the Response","text":"<p>You can access the raw HTTP response by adding a <code>response</code> parameter:</p> <pre><code>from pydantic import BaseModel\nfrom clientele.graphql import GraphQLClient\nfrom clientele.http import Response\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\nclass Repository(BaseModel):\n    name: str\n\nclass RepositoryQueryData(BaseModel):\n    repository: Repository\n\nclass RepositoryQueryResponse(BaseModel):\n    data: RepositoryQueryData\n\n@client.query(\"\"\"\n    query($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n            name\n        }\n    }\n\"\"\")\ndef get_repo(owner: str, name: str, result: RepositoryQueryResponse, response: Response) -&gt; Repository:\n    print(f\"Status: {response.status_code}\")\n    print(f\"Headers: {response.headers}\")\n    return result.data.repository\n\nrepo = get_repo(owner=\"phalt\", name=\"clientele\")\n</code></pre>"},{"location":"api-graphql/#working-with-raw-dicts","title":"Working with Raw Dicts","text":"<p>If you prefer not to use Pydantic models for the response structure, you can still use <code>result: dict</code> and work with raw dictionaries:</p> <pre><code>from clientele.graphql import GraphQLClient\n\nclient = GraphQLClient(base_url=\"https://api.github.com/graphql\")\n\n@client.query(\"\"\"\n    query($owner: String!, $name: String!) {\n        repository(owner: $owner, name: $name) {\n            name\n            stargazerCount\n        }\n    }\n\"\"\")\ndef get_repo(owner: str, name: str, result: dict) -&gt; dict:\n    return result[\"data\"][\"repository\"]\n\nrepo = get_repo(owner=\"phalt\", name=\"clientele\")\nprint(repo[\"name\"])  # \"clientele\"\nprint(repo[\"stargazerCount\"])  # 100\n</code></pre> <p>However, using Pydantic models for the <code>result</code> parameter provides type safety and auto-hydration, which is the recommended approach.</p>"},{"location":"api-graphql/#configuration","title":"Configuration","text":"<p>The <code>GraphQLClient</code> inherits from <code>APIClient</code> and supports all the same configuration options:</p> <pre><code>from clientele.graphql import GraphQLClient\nfrom clientele.api import BaseConfig\n\nconfig = BaseConfig(\n    base_url=\"https://api.github.com/graphql\",\n    headers={\"Authorization\": \"Bearer YOUR_TOKEN\"},\n)\n\nclient = GraphQLClient(config=config)\n</code></pre> <p>You can also close clients when done:</p> <pre><code># Sync\nclient.close()\n\n# Async\nawait client.aclose()\n</code></pre>"},{"location":"api-http-backends/","title":"HTTP Backends","text":""},{"location":"api-http-backends/#overview","title":"Overview","text":"<p>Clientele supports pluggable HTTP backends.</p>"},{"location":"api-http-backends/#architecture","title":"Architecture","text":""},{"location":"api-http-backends/#core-components","title":"Core Components","text":"<ol> <li><code>clientele.http.response.Response</code> - Generic HTTP response abstraction</li> <li><code>clientele.http.backends.HTTPBackend</code> - Abstract base class for backends</li> <li><code>clientele.http.httpx.HttpxHTTPBackend</code> - Default httpx implementation</li> <li><code>clientele.http.fake.FakeHTTPBackend</code> - Testing/mocking backend</li> </ol>"},{"location":"api-http-backends/#design-principles","title":"Design Principles","text":"<p>The backend abstraction follows these key principles:</p> <ol> <li>Library Agnostic: The core APIClient doesn't depend on any library-specific implementation.</li> <li>Generic Response: All backends return <code>clientele.http.Response</code>, not library-specific responses.</li> <li>Simple Interface: Backends only need to implement 6 methods.</li> <li>Conversion Layer: Each backend converts its native response to the generic format.</li> </ol>"},{"location":"api-http-backends/#generic-response","title":"Generic Response","text":"<p>The <code>clientele.http.response.Response</code> class provides a library-agnostic interface:</p> <pre><code>class Response:\n    status_code: int\n    headers: dict[str, str]\n    content: bytes\n    text: str\n\n    def json(self) -&gt; Any: ...\n    def raise_for_status(self) -&gt; None: ...\n    def iter_lines(self) -&gt; Iterator[str]: ...\n    def aiter_lines(self) -&gt; AsyncIterator[str]: ...\n</code></pre>"},{"location":"api-http-backends/#httpbackend-interface","title":"HTTPBackend Interface","text":"<p>All backends must implement:</p> <pre><code>class HTTPBackend(abc.ABC):\n    @abc.abstractmethod\n    def build_client(self) -&gt; Any:\n        \"\"\"Build synchronous HTTP client\"\"\"\n\n    @abc.abstractmethod\n    def build_async_client(self) -&gt; Any:\n        \"\"\"Build asynchronous HTTP client\"\"\"\n\n    @abc.abstractmethod\n    def send_sync_request(self, method: str, url: str, **kwargs) -&gt; typing.Any:\n        \"\"\"Send sync request\"\"\"\n\n    @abc.abstractmethod\n    async def send_async_request(self, method: str, url: str, **kwargs) -&gt; typing.Any:\n        \"\"\"Send async request\"\"\"\n\n    @abc.abstractmethod\n    def handle_sync_stream(\n        self,\n        method: str,\n        url: str,\n        inner_type: typing.Any,\n        response_parser: typing.Callable[[str], typing.Any] | None = None,\n        **kwargs: typing.Any,\n    ) -&gt; typing.Generator[typing.Any, None, None]:\n        \"\"\" Handle streaming responses \"\"\"\n\n    @abc.abstractmethod\n    async def handle_async_stream(\n        self,\n        method: str,\n        url: str,\n        inner_type: typing.Any,\n        response_parser: typing.Callable[[str], typing.Any] | None = None,\n        **kwargs: typing.Any,\n    ) -&gt; typing.AsyncGenerator[typing.Any, None]:\n        \"\"\" Handle async streaming responses \"\"\"\n\n    @staticmethod\n    @abc.abstractmethod\n    def convert_to_response(native_response: typing.Any) -&gt; Response:\n        \"\"\"Convert a native HTTP response to a generic clientele Response.\"\"\"\n\n    @abc.abstractmethod\n    def close(self) -&gt; None:\n        \"\"\"Close sync resources\"\"\"\n\n    @abc.abstractmethod\n    async def aclose(self) -&gt; None:\n        \"\"\"Close async resources\"\"\"\n</code></pre>"},{"location":"api-http-backends/#built-in-backends","title":"Built-in Backends","text":""},{"location":"api-http-backends/#httpxhttpbackend-default","title":"HttpxHTTPBackend (Default)","text":"<p>The default backend using httpx:</p> <pre><code>from clientele.http import httpx_backend\nfrom clientele.api import config\n\n# Note: this will be configured by default,\n# this example is just a demonstration.\nhttp_backend = httpx_backend.HttpxHTTPBackend(\n    client_options={\n        \"timeout\": 30.0,\n        \"http2\": True,\n    }\n)\n\ncfg = config.BaseConfig(\n    base_url=\"https://api.example.com\",\n    http_backend=http_backend,\n)\n</code></pre>"},{"location":"api-http-backends/#fakehttpbackend","title":"FakeHTTPBackend","text":"<p>A testing backend that captures requests and returns fake responses:</p> <pre><code>from clientele.http import fake\n\nbackend = fake.FakeHTTPBackend(\n    default_status=200,\n    default_content={\"message\": \"success\"},\n)\n\n# Queue specific responses\nbackend.queue_response(\n    status=201,\n    content={\"id\": 123, \"created\": True},\n)\n\n# All requests are captured\nprint(backend.requests)  # [{\"method\": \"POST\", \"url\": \"...\", \"kwargs\": {...}}]\n\n# Reset for next test\nbackend.reset()\n</code></pre> <p>Use cases:</p> <ul> <li>Unit testing without network calls</li> <li>Integration tests with predictable responses</li> <li>Demonstrations and examples</li> <li>Development mode with fake data</li> </ul>"},{"location":"api-http-backends/#creating-custom-backends","title":"Creating Custom Backends","text":"<p>Example: psuedocode <code>aiohttp</code> async HTTP backend</p> <pre><code>from clientele.http import backends, response\nimport aiohttp\n\nclass AiohttpHTTPBackend(backends.HTTPBackend):\n    def __init__(self):\n        self._session: aiohttp.ClientSession | None = None\n\n    def build_client(self):\n        # For sync, return a placeholder or raise NotImplementedError\n        raise NotImplementedError(\"Use async_client for aiohttp\")\n\n    def build_async_client(self) -&gt; aiohttp.ClientSession:\n        if self._session is None:\n            self._session = aiohttp.ClientSession()\n        return self._session\n\n    @staticmethod\n    def convert_to_response(native_response: aiohttp.ClientResponse) -&gt; response.Response:\n        \"\"\"Convert aiohttp.ClientResponse to generic Response\"\"\"\n        return response.Response(\n            status_code=native_response.status,\n            headers=dict(native_response.headers),\n            content=native_response._body,\n            text=native_response._body.decode('utf-8'),\n            request_method=native_response.method,\n            request_url=str(native_response.url),\n        )\n\n    def send_sync_request(self, method, url, **kwargs):\n        raise NotImplementedError(\"Use async backend\")\n\n    async def send_async_request(self, method, url, **kwargs):\n        async with self._session.request(method, url, **kwargs) as resp:\n            await resp.read()\n            return self.convert_to_response(resp)\n\n    def close(self):\n        pass  # aiohttp doesn't need sync close\n\n    async def aclose(self):\n        if self._session:\n            await self._session.close()\n</code></pre>"},{"location":"api-http-backends/#default-behavior","title":"Default Behavior","text":"<p>If no backend is provided, clientele uses httpx as the backend:</p> <pre><code># This still works and uses httpx internally\ncfg = config.BaseConfig(base_url=\"https://api.example.com\")\napi_client = client.APIClient(config=cfg)\n</code></pre>"},{"location":"api-logging/","title":"\ud83e\udeb5 Logging","text":"<p>Clientele supports debug logging.</p>"},{"location":"api-logging/#example","title":"Example","text":"<pre><code>import logging\n\nfrom clientele import api\nfrom pydantic import BaseModel\n\nlogging.basicConfig(level=logging.DEBUG)\n\nconfig = api.BaseConfig(base_url=\"https://httpbin.org\", logger=logging.getLogger(\"my_pokeapi_client\"))\n\nclient = api.APIClient(config=config)\n\n\nclass InputData(BaseModel):\n    name: str\n\n\n@client.post(\"/anything\")\ndef send_post_data(data: InputData, result: dict) -&gt; str:\n    return result[\"json\"]\n</code></pre> <ul> <li>With the logger set you will see debug information about the prepared request and the response.</li> <li>The time it took for a request to return will also be printed.</li> </ul> <pre><code>&gt;&gt;&gt; send_post_data(data={\"name\": \"hello!\"})\nDEBUG:my_pokeapi_client:HTTP Request: POST /anything\nDEBUG:my_pokeapi_client:Request Query Params: {}\nDEBUG:my_pokeapi_client:Request Payload: {'name': 'hello!'}\nDEBUG:my_pokeapi_client:Request Headers: {}\nDEBUG:my_pokeapi_client:HTTP Response: POST /anything -&gt; 200 (0.567s)\nDEBUG:my_pokeapi_client:Response Content: {\n  ...,\n  \"json\": {\n    \"name\": \"hello!\"\n  }, \n}\nDEBUG:my_pokeapi_client:Response Headers: {...}\n&gt;&gt;&gt; {'name': 'hello!'}\n</code></pre>"},{"location":"api-overview/","title":"\ud83d\udcd5 Documentation","text":""},{"location":"api-overview/#http-get-example","title":"HTTP GET example","text":"<pre><code>from pydantic import BaseModel\nfrom clientele import api as clientele_api\nimport httpx\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@client.get(\"/users/{user_id}\")\ndef get_user(user_id: int, result: User, include_details: bool = True) -&gt; User:\n    return result\n\nuser = get_user(42)\n</code></pre> <p>How Clientele works:</p> <ul> <li>Path parameters inside <code>{}</code> are filled from the function arguments (e.g. <code>user_id</code>).</li> <li>Any remaining keyword arguments (like <code>include_details</code> above) become query parameters, but you can also provide a dict function parameter <code>query={...}</code> instead.</li> <li>The <code>result</code> parameter is mandatory and its type annotation (<code>User</code>) drives response parsing.</li> <li>Your function is injected with the <code>result</code> parameter - this is the response payload hydrated into your <code>result</code> parameter's type.</li> <li>The function's return value is independent - you can return the result directly, transform it, or return something completely different.</li> </ul>"},{"location":"api-overview/#http-post-example","title":"HTTP POST example","text":"<pre><code>from typing import TypedDict\nfrom pydantic import BaseModel\nfrom clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\n# Using Pydantic models\nclass CreateUserRequest(BaseModel):\n    name: str\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n@client.post(\"/users\")\ndef create_user(*, data: CreateUserRequest, result: User) -&gt; User:\n    return result\n\nuser = create_user(data=CreateUserRequest(name=\"Ada\"))\n\n# Or use TypedDict for the `data` and `result` parameters\nclass CreateUserRequestDict(TypedDict):\n    name: str\n\nclass UserDict(TypedDict):\n    id: int\n    name: str\n\n@client.post(\"/users\")\ndef create_user_with_dict(*, data: CreateUserRequestDict, result: UserDict) -&gt; UserDict:\n    return result\n\n# Pass dict directly - no instantiation needed\nuser = create_user_with_dict(data={\"name\": \"Ada\"})\n</code></pre> <p>How body-based methods (POST, PUT, PATCH, DELETE) work with Clientele:</p> <ul> <li>The request body must be supplied via the <code>data</code> keyword argument.</li> <li>The <code>data</code> parameter can be a Pydantic model or a TypedDict.</li> <li>For Pydantic models, the data is validated and serialized to JSON automatically.</li> <li>For TypedDict, the data is sent as-is (because TypedDict provides type hints without runtime validation).</li> <li>The <code>result</code> parameter is mandatory and determines how the response is parsed.</li> </ul>"},{"location":"api-overview/#put-patch-and-delete-examples","title":"PUT, PATCH, and DELETE examples","text":"<pre><code>from pydantic import BaseModel\nfrom clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\nclass UpdateUser(BaseModel):\n    name: str\n    email: str\n\nclass PatchNameUser(BaseModel):\n    name: str\n\nclass User(BaseModel):\n    id: int\n    name: str\n\n# PUT with a full body\n@client.put(\"/users/{user_id}\")\ndef update_user(user_id: int, *, data: UpdateUser, result: User) -&gt; User:\n    return result\n\nupdated = update_user(1, data=UpdateUser(name=\"New Name\", email=\"test@foo.com\"))\n\n# PATCH with partial data\n@client.patch(\"/users/{user_id}\")\ndef patch_user_name(user_id: int, *, data: PatchNameUser, result: User) -&gt; User:\n    return result\n\npatched = patch_user_name(1, data=PatchUserName(name=\"New Name\"))\n\n# DELETE that returns an empty response body\n@client.delete(\"/users/{user_id}\")\ndef delete_user(user_id: int, *, result: None) -&gt; None:\n    return result\n\ndelete_user(1)\n</code></pre>"},{"location":"api-overview/#return-value-independence","title":"Return value independence","text":"<p>The <code>result</code> parameter defines what response you get from the API, but your function's return value is independent. This gives you flexibility:</p> <pre><code># Return the result directly (most common)\n@client.get(\"/users/{user_id}\")\ndef get_user(user_id: int, result: User) -&gt; User:\n    return result\n\n# Return a derived value\n@client.get(\"/users/{user_id}\")\ndef get_user_email(user_id: int, result: User) -&gt; str:\n    return result.email\n\n# Return multiple values as a tuple\n@client.post(\"/events\")\ndef create_event(data: EventIn, result: EventOut) -&gt; tuple[EventOut, str]:\n    log.info(\"Created event %s\", result.id)\n    return result, \"success\"\n</code></pre>"},{"location":"api-overview/#injected-parameters","title":"Injected parameters","text":"<p>Clientele will inject the following parameters into your function once an http response is returned:</p> <ul> <li><code>result</code>: an instance of the type specified in the <code>result</code> parameter annotation. This parameter is mandatory and its type annotation determines how the response is parsed. Can be a Pydantic model or a TypedDict.</li> <li><code>response</code>: the <code>httpx.Response</code> - useful for logging, debugging etc. (optional)</li> </ul>"},{"location":"api-overview/#response-parsing-rules","title":"Response parsing rules","text":"<ul> <li>If the response has a JSON content type, the payload is decoded from JSON.</li> <li>If the response type is not JSON then a <code>str</code> is returned.</li> <li>Empty body responses return <code>None</code>.</li> <li>The <code>result</code> parameter's type annotation drives response data validation. Pydantic models use <code>model_validate</code> for runtime validation, while TypedDict provides type hints without runtime validation.</li> </ul>"},{"location":"api-overview/#custom-response-parsing","title":"Custom response parsing","text":"<ul> <li>You can provide a callable <code>response_parser</code> to the decorator to handle your own response parsing.</li> <li><code>response_parser</code> will receive the <code>httpx.Response</code> object.</li> <li>The return type of the <code>response_parser</code> must match the type of the <code>result</code> parameter.</li> <li>You cannot provide <code>response_parser</code> and <code>response_mapping</code> (see below) at the same time.</li> </ul> <p>Example:</p> <pre><code>from clientele import api as clientele_api\nimport httpx\nfrom pydantic import BaseModel\n\nclient = clientele_api.APIClient(base_url=\"http://localhost:8000\")\n\nclass CustomResponseParserResponse(BaseModel):\n    name: str\n    other_value: str\n\n# A custom handler for parsing the response\ndef custom_parser(response: httpx.Response) -&gt; CustomResponseParserResponse:\n    data = response.json()\n    return CustomResponseParserResponse(name=data[\"name\"], other_value=\"other value\")\n\n# Annotate the decorate to use, `result` type must match\n@client.get(\"/users/{user_id}\", response_parser=custom_parser)\ndef get_user_custom_response(user_id: int, result: CustomResponseParserResponse) -&gt; str:\n    return result.other_value\n</code></pre>"},{"location":"api-overview/#handling-multiple-response-bodies-and-status-codes","title":"Handling multiple response bodies and status codes","text":"<p>Real APIs often return different response models based on the HTTP status code. This is also a common feature of OpenAPI schemas.</p> <p>The <code>response_map</code> parameter allows you to map status codes to specific Pydantic models or TypedDict classes, enabling proper type handling for success and error responses.</p> <pre><code>from pydantic import BaseModel\nfrom clientele import api as clientele_api\n\nclient = clientele_api.APIClient(base_url=\"https://api.example.com\")\n\nclass User(BaseModel):\n    id: int\n    name: str\n\nclass NotFoundError(BaseModel):\n    error: str\n    code: int\n\n@client.get(\n    \"/users/{user_id}\",\n    response_map={\n        200: User,\n        404: NotFoundError,\n    }\n)\ndef get_user(user_id: int, result: User | NotFoundError) -&gt; User | NotFoundError:\n    return result\n\n# Returns User for 200 responses\nuser = get_user(1)\nmatch user:\n    case User():\n        print(f\"Found user: {user.name}\")\n    case NotFoundError() :\n        print(f\"Error: {user.error}\")\n\n# For unexpected status codes, clientele.api.APIException is raised\ntry:\n    get_user(-999)  # imagine the server returns 500\nexcept clientele_api.APIException as e:\n    print(f\"Unexpected status: {e.response.status_code}\")\n    print(f\"Reason: {e.reason}\")\n</code></pre>"},{"location":"api-overview/#response_map-requirements","title":"<code>response_map</code> requirements","text":"<ol> <li>Keys must be valid HTTP status codes: Use the <code>codes</code> enum from <code>clientele.api</code> for reference, or any standard HTTP status code integers (100-599).</li> <li>Values must be Pydantic models or TypedDict: Each value must be a <code>BaseModel</code> subclass or a <code>TypedDict</code> class.</li> <li>Result parameter type must include all models: The <code>result</code> parameter's type annotation must be a Union containing all the Pydantic models or TypedDict classes used in <code>response_map</code>.</li> <li>Unexpected status codes raise <code>APIException</code>: If the server returns a status code not in the <code>response_map</code>, an <code>APIException</code> is raised with details about the unexpected status.</li> <li>Precedence: If <code>response_map</code> provides a model for the actual HTTP status code, that model is used. Otherwise, the <code>result</code> parameter annotation is used as the default for 2xx responses.</li> </ol>"},{"location":"api-overview/#multi-status-example-with-post","title":"Multi-status example with POST","text":"<p>If multiple statuses return the same response it is easy enough to extend the map:</p> <pre><code>@client.post(\n    \"/users\",\n    response_map={\n        201: User,\n        400: ValidationError,\n        422: ValidationError,\n    }\n)\ndef create_user(\n    data: User, result: User | ValidationError\n) -&gt; User | ValidationError:\n    return result\n\n# Handle different responses\nresponse = create_user(data=User(name=\"Alice\"))\nmatch response:\n    case User():\n        print(f\"Created user {response.id}\")\n    case ValidationError():\n        print(f\"Validation failed: {response.errors}\")\n</code></pre>"},{"location":"api-overview/#connection-persistence","title":"Connection persistence","text":"<p>Clientele API will generate a singleton instance for the async and sync http clients. When you import the module and issue multiple function calls it will use the same http connection.</p>"},{"location":"api-retries/","title":"\ud83d\udd04 Retries","text":"<p>Clientele provides a built-in decorator for handling HTTP request retries.</p>"},{"location":"api-retries/#example","title":"Example","text":"<pre><code>from clientele import api, retries\n\nclient = api.APIClient(api.BaseConfig(base_url=\"https://httpbin.org/\"))\n\n@retries.retry(attempts=3)\n@client.get(\"/status/{status_code}\")\ndef get_status(status_code: int, result: dict) -&gt; dict:\n    return result\n</code></pre>"},{"location":"api-retries/#declare-status-codes-to-retry","title":"Declare status codes to retry","text":"<pre><code>from clientele import api, retries\n\nclient = api.APIClient(api.BaseConfig(base_url=\"https://httpbin.org/\"))\n\n@retries.retry(attempts=3, on_status=[400, 403, 500])\n@client.get(\"/status/{status_code}\")\ndef get_status(status_code: int, result: dict) -&gt; dict:\n    return result\n</code></pre>"},{"location":"api-retries/#how-it-works","title":"How it works","text":"<ul> <li>Clientele's decorator is a small wrapper for stamina, a popular and versatile retry logic decorator.</li> <li>We have configured the <code>retries.retry</code> decorator to work with Clientele specific exception behaviour.</li> <li>A default status that is 500 or higher will be retried using Stamina's backoff and jitter approach.</li> <li>If you supply <code>on_status</code> then it will only retry for those specific statuses.</li> <li>If you want more granular control then you can swap to <code>stamina.retry</code> and configure yourself.</li> </ul>"},{"location":"api-stream/","title":"\ud83c\udf0a Streaming","text":"<p>Clientele supports HTTP streaming responses through the <code>streaming_response=True</code> parameter.</p>"},{"location":"api-stream/#basic-stream-example","title":"Basic stream Example","text":"<pre><code>from typing import AsyncIterator\n\nfrom clientele import api\nfrom pydantic import BaseModel\n\n\nclient = api.APIClient(base_url=\"https://httpbin.org\")\n\n\nclass Event(BaseModel):\n    id: int\n    url: str\n\n\n@client.get(\"/stream/{n}\", streaming_response=True)\nasync def stream_events(n: int, result: AsyncIterator[Event]) -&gt; AsyncIterator[Event]:\n    return result\n</code></pre> <pre><code>async for event in await stream_events(n=4):\n    print(event)\n</code></pre>"},{"location":"api-stream/#type-based-hydration","title":"Type-Based Hydration","text":"<p>The type inside <code>AsyncIterator[T]</code> determines how responses are parsed:</p> <p>String (no parsing):</p> <pre><code>@client.get(\"/events\", streaming_response=True)\nasync def stream_text(*, result: AsyncIterator[str]) -&gt; AsyncIterator[str]:\n    return result\n</code></pre> <pre><code>async for line in await stream_text():\n    print(line)  # Raw string\n</code></pre> <p>Dictionary (JSON parsing):</p> <pre><code>@client.get(\"/events\", streaming_response=True)\nasync def stream_json(*, result: AsyncIterator[dict]) -&gt; AsyncIterator[dict]:\n    return result\n</code></pre> <pre><code>async for data in await stream_json():\n    print(data[\"field\"])  # Parsed JSON as dict\n</code></pre> <p>Pydantic Model (JSON + validation):</p> <pre><code>class Token(BaseModel):\n    text: str\n    id: int\n\n@client.get(\"/stream\", streaming_response=True)\nasync def stream_tokens(*, result: AsyncIterator[Token]) -&gt; AsyncIterator[Token]:\n    return result\n</code></pre> <pre><code>async for token in await stream_tokens():\n    print(token.text, token.id)  # Validated Pydantic model\n</code></pre>"},{"location":"api-stream/#support-methods","title":"Support methods","text":"<p>Clientele streams support:</p> <ul> <li><code>HTTP GET</code></li> <li><code>HTTP POST</code></li> <li><code>HTTP PUT</code></li> <li><code>HTTP PATCH</code></li> <li><code>HTTP DELETE</code></li> </ul>"},{"location":"api-stream/#synchronous-streaming","title":"Synchronous Streaming","text":"<p>You can also use synchronous iterators for blocking streams:</p> <pre><code>from typing import Iterator\n\n@client.get(\"/events\", streaming_response=True)\ndef stream_events_sync(*, result: Iterator[Event]) -&gt; Iterator[Event]:\n    return result\n</code></pre> <pre><code>for event in stream_events_sync():\n    print(event.text)\n</code></pre>"},{"location":"api-stream/#parsing-server-sent-events-sse","title":"Parsing Server-Sent Events (SSE)","text":"<p>For Server-Sent Events format (with <code>data:</code>, <code>event:</code>, <code>id:</code> fields), use a custom <code>response_parser</code> to extract the data:</p> <pre><code>from typing import AsyncIterator\nimport json\n\ndef parse_sse(line: str) -&gt; dict | None:\n    \"\"\"Parse SSE format: extracts data from 'data: {json}' lines.\"\"\"\n    if line.startswith('data: '):\n        json_str = line[6:]  # Remove 'data: ' prefix\n        return json.loads(json_str)\n    # Skip other SSE fields (event:, id:, retry:, comments)\n    return None\n\nclass ChatMessage(BaseModel):\n    role: str\n    content: str\n\n@client.post(\"/chat/stream\", streaming_response=True, response_parser=parse_sse)\nasync def stream_chat(*, data: dict, result: AsyncIterator[ChatMessage]) -&gt; AsyncIterator[ChatMessage]:\n    return result\n</code></pre> <pre><code># Server sends SSE format:\n# data: {\"role\": \"assistant\", \"content\": \"Hello\"}\n#\n# data: {\"role\": \"assistant\", \"content\": \"How can I help?\"}\n#\n\nasync for message in await stream_chat(data={\"prompt\": \"Hi\"}):\n    if message:  # Skip None values from non-data lines\n        print(f\"{message.role}: {message.content}\")\n</code></pre> <p>Note: The <code>response_parser</code> receives each line as a string and should return the parsed value. Return <code>None</code> to skip lines (e.g., SSE comments or event type declarations).</p>"},{"location":"api-stream/#custom-parsing-with-response_parser","title":"Custom Parsing with response_parser","text":"<p>You can provide a custom <code>response_parser</code> callback to control how each streamed line is parsed:</p> <pre><code>from typing import AsyncIterator\n\ndef parse_csv_log(line: str) -&gt; dict:\n    \"\"\"Custom parser for CSV-formatted log lines.\"\"\"\n    parts = line.split(\",\")\n    return {\n        \"timestamp\": parts[0],\n        \"message\": parts[1],\n        \"level\": parts[2] if len(parts) &gt; 2 else \"info\"\n    }\n\n@client.get(\"/logs\", streaming_response=True, response_parser=parse_csv_log)\nasync def stream_logs(*, result: AsyncIterator[dict]) -&gt; AsyncIterator[dict]:\n    return result\n</code></pre> <pre><code>async for log_entry in await stream_logs():\n    print(f\"{log_entry['timestamp']}: {log_entry['message']}\")\n</code></pre> <p>The <code>response_parser</code> is called for each non-empty line received from the stream, giving you full control over how the data is transformed before being yielded to your code.</p>"},{"location":"api-testing/","title":"\ud83e\uddea Testing","text":"<p>Clientele comes with everything you need for testing api integrations.</p>"},{"location":"api-testing/#fakehttpbackend","title":"FakeHTTPBackend","text":"<p>The <code>FakeHTTPBackend</code> allows you to test your API client without making real HTTP requests.</p> <p>Instead of making real network calls, the fake backend captures all requests and returns configurable responses.</p>"},{"location":"api-testing/#basic-example","title":"Basic Example","text":"<p>Assuming you have a pre-written client:</p> <pre><code>from my_api_client import client, get_user\nfrom clientele.http import FakeHTTPBackend\nfrom clientele.testing import ResponseFactory, configure_client_for_testing\n\n\ndef test_my_api():\n    # Configure a fake backend with default response\n    fake_backend: FakeHTTPBackend = configure_client_for_testing(client)\n\n    # Configure the HTTP response itself\n    fake_backend.queue_response(\n        path=\"/users/1\",\n        response_obj=ResponseFactory.ok(\n            data={\"id\": 1, \"name\": \"Bob\"},\n        ),\n    )\n\n    # Call your API method\n    user = get_user(user_id=123)\n\n    # Verify the response\n    assert user.id == 1\n    assert user.name == \"Bob\"\n\n    # Verify what was requested\n    assert len(fake_backend.requests) == 1\n    assert fake_backend.requests[0][\"method\"] == \"GET\"\n    assert \"/users/1\" in fake_backend.requests[0][\"url\"]\n</code></pre>"},{"location":"api-testing/#queuing-different-responses","title":"Queuing Different Responses","text":"<p>You can queue different responses for specific request paths:</p> <pre><code>from my_api_client import client, create_user, get_user\nfrom clientele.http import FakeHTTPBackend\nfrom clientele.testing import ResponseFactory, configure_client_for_testing\n\n# Replace the HTTP backend\nfake_backend: FakeHTTPBackend = configure_client_for_testing(client)\n\n# Queue responses for a specific path\nfake_backend.queue_response(\n    path=\"/users\",\n    response_obj=ResponseFactory.created(\n            data={\"id\": 10, \"name\": \"Bob\"},\n        ),\n)\nfake_backend.queue_response(\n    path=\"/users/10\",\n    response_obj=ResponseFactory.ok(\n            data={\"id\": 10, \"name\": \"Bob\"},\n        ),\n)\n\n# First request gets the /users response\ncreated = create_user(data={\"name\": \"Bob\", \"email\": \"bob@example.com\"})\nassert created.id == 11\n\n# Second request gets the /users/10 response\nfetched = get_user(user_id=10)\nassert fetched.name == \"Bob\"\n</code></pre>"},{"location":"api-testing/#error-responses","title":"Error Responses","text":"<p>You can also simulate error responses:</p> <pre><code>from my_api_client import client, get_user\nfrom clientele.http import FakeHTTPBackend\nfrom clientele.testing import ResponseFactory, configure_client_for_testing\n\n# Replace the HTTP backend\nfake_backend: FakeHTTPBackend = configure_client_for_testing(client)\n\n# Queue a 404 error response\nfake_backend.queue_response(\n    path=\"/users/999\",\n    reponse_obj=ResponseFactory.not_found(\n        data={\"error\": \"User not found\"},\n    ),\n)\n\nerror = get_user(user_id=999)\nassert error.error == \"User not found\"\n</code></pre>"},{"location":"api-testing/#responsefactory","title":"ResponseFactory","text":"<p>Use <code>clientele.testing.ResponseFactory</code> to build common HTTP Responses quickly:</p> <pre><code>from clientele.testing import ResponseFactory\n\nbackend.queue_response(\"/users\", ResponseFactory.ok([{\"id\": 1}]))\nbackend.queue_response(\"/users/99\", ResponseFactory.not_found())\n</code></pre>"},{"location":"api-testing/#networkerrorfactory","title":"NetworkErrorFactory","text":"<p>Use <code>clientele.testing.NetworkErrorFactory</code> to build common Network errors quickly:</p> <pre><code>from clientele.testing import NetworkErrorFactory\nbackend.queue_error(\"/users\", NetworkErrorFactory.timeout())\n</code></pre>"},{"location":"install/","title":"\ud83d\ude80 Install","text":""},{"location":"install/#uv","title":"uv","text":"<pre><code>uv add clientele\n</code></pre>"},{"location":"install/#pip","title":"pip","text":"<pre><code>pip install clientele\n</code></pre> <p>Once installed, you can run <code>clientele version</code> to make sure you have the latest version:</p> <pre><code>&gt; clientele version\nclientele 1.11.0\n</code></pre>"},{"location":"install/#next-steps","title":"Next steps","text":"<ul> <li>Clientele API guide to write your own API client</li> <li>Client creator to quick start an API client</li> <li>API server integration to learn how to integrate with popular Python API servers</li> </ul>"},{"location":"mypy/","title":"\ud83e\udd67 Mypy support","text":"<p>Clientele includes a mypy plugin that provides proper type checking for decorated API functions.</p>"},{"location":"mypy/#what-it-does","title":"What it does","text":"<p>The mypy plugin:</p> <ul> <li>Removes injected parameters (<code>result</code> and <code>response</code>) from function signatures during type checking</li> <li>Allows <code>dict</code> types to be passed to Pydantic model parameters</li> <li>Prevents false positives when calling your decorated API functions</li> </ul>"},{"location":"mypy/#installation","title":"Installation","text":"<p>The plugin is automatically installed when you install Clientele.</p>"},{"location":"mypy/#configuration","title":"Configuration","text":"<p>Add the plugin to your mypy configuration file.</p>"},{"location":"mypy/#using-mypyini-or-setupcfg","title":"Using <code>mypy.ini</code> or <code>setup.cfg</code>","text":"<pre><code>[mypy]\nplugins = clientele.mypy\n</code></pre>"},{"location":"mypy/#using-pyprojecttoml","title":"Using <code>pyproject.toml</code>","text":"<pre><code>[tool.mypy]\nplugins = [\"clientele.mypy\"]\n</code></pre>"},{"location":"mypy/#example","title":"Example","text":"<p>Without the plugin, mypy would complain about the <code>result</code> parameter:</p> <pre><code>from clientele import api\nfrom pydantic import BaseModel\n\nclient = api.APIClient(base_url=\"https://api.example.com\")\n\nclass User(BaseModel):\n    name: str\n    email: str\n\n@client.get(\"/users/{user_id}\")\ndef get_user(user_id: int, result: User) -&gt; User:\n    return result\n\n# With the plugin: \u2705 This works correctly\nuser = get_user(user_id=1)\n\n# Without the plugin: \u274c mypy would require get_user(user_id=1, result=...)\n</code></pre> <p>The plugin ensures mypy understands that <code>result</code> and <code>response</code> are injected by Clientele and should not be provided by callers.</p>"},{"location":"mypy/#credits","title":"Credits","text":"<p>Big thanks to Christian Assing for contributing this plugin!</p>"},{"location":"openapi-cli/","title":"\ud83c\udfd7\ufe0f Client creator","text":"<p>Clientele can build a project template for an API Client.</p> <p>It can also generate functions and models from an OpenAPI schema.</p>"},{"location":"openapi-cli/#basic-project-template","title":"Basic project template","text":"<p>To create a new clientele API client project just use the <code>start-api</code> command:</p> <pre><code>uv run clientele start-api -o path/to/my_client\n</code></pre> <p>This will create a new directory with the following file stucture:</p> <pre><code>my_client/\n    config.py.  # Client configuration\n    client.py   # API client functions\n    schemas.py  # API models\n    MANIFEST.md # Information about the project\n</code></pre> <p>The only code within these files will be a simple configuration set up and some basic imports.</p>"},{"location":"openapi-cli/#openapi-project-template","title":"OpenAPI project template","text":"<p>The <code>start-api</code> command can also be used to scaffold an entire API client integration using an OpenAPI schema.</p> <p>If you provide a schema then the <code>start-api</code> command will generate the same project structure and it will also include:</p> <ul> <li>All available operations in the <code>operations</code> of the OpenAPI spec as fully typed, decorated functions.</li> <li>All available models in the <code>schemas</code> of the OpenAPI spec as Pyantic models.</li> </ul> <pre><code>clientele start-api -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre>"},{"location":"openapi-cli/#from-a-url","title":"From a URL","text":"<p>Use the <code>-u</code> or <code>--url</code> argument.</p> <p><code>-o</code> or <code>--output</code> is the target directory for the generated client.</p> <pre><code>clientele start-api -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/\n</code></pre>"},{"location":"openapi-cli/#from-a-file","title":"From a file","text":"<p>Alternatively you can provide a local file using the <code>-f</code> or <code>--file</code> argument.</p> <pre><code>clientele start-api -f path/to/file.json -o my_client/\n</code></pre>"},{"location":"openapi-cli/#asyncio","title":"Async.io","text":"<p>If you prefer an asyncio client, just pass <code>--asyncio</code> to your command.</p> <pre><code>clientele start-api -f path/to/file.json -o my_client/ --asyncio\n</code></pre>"},{"location":"server-django-ninja/","title":"\ud83e\udd77 Using Clientele with Django Ninja","text":"<p>This guide shows you how to scaffold a Python client for a Django Ninja API using Clientele.</p> <p>\ud83d\udca1 Working Example: See a real Django Ninja application with code examples from this guide in <code>server_examples/django_ninja/</code></p>"},{"location":"server-django-ninja/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Django application with Django Ninja installed</li> <li>Django Ninja automatically generates OpenAPI schemas (enabled by default)</li> </ul>"},{"location":"server-django-ninja/#step-1-get-your-openapi-schema","title":"Step 1: Get Your OpenAPI Schema","text":"<p>Django Ninja automatically generates an OpenAPI schema for your API. By default, it's available at:</p> <pre><code>http://your-api-domain/api/openapi.json\n</code></pre> <p>For local development:</p> <pre><code>http://localhost:8000/api/openapi.json\n</code></pre> <p>The exact path depends on how you've mounted your Django Ninja API in your URLs.</p>"},{"location":"server-django-ninja/#example-django-ninja-setup","title":"Example Django Ninja Setup","text":"<pre><code># urls.py\nfrom django.urls import path\nfrom ninja import NinjaAPI\n\napi = NinjaAPI()\n\n# Your endpoints here...\n\nurlpatterns = [\n    path(\"api/\", api.urls),\n]\n</code></pre> <p>With this setup, the OpenAPI schema is at: <code>http://localhost:8000/api/openapi.json</code></p>"},{"location":"server-django-ninja/#downloading-the-schema","title":"Downloading the Schema","text":"<p>You can either:</p> <p>Option A: Use the URL directly (if the API is accessible):</p> <pre><code>clientele start-api -u http://localhost:8000/api/openapi.json -o my_client/\n</code></pre> <p>Option B: Download the schema file first:</p> <pre><code>curl http://localhost:8000/api/openapi.json &gt; openapi.json\nclientele start-api -f openapi.json -o my_client/\n</code></pre>"},{"location":"server-django-ninja/#step-2-scaffold-the-client","title":"Step 2: Scaffold the Client","text":"<pre><code>clientele start-api -u http://localhost:8000/api/openapi.json -o my_client/\n</code></pre>"},{"location":"server-django-ninja/#async-client","title":"Async Client","text":"<p>Django Ninja supports both sync and async views. If you want an async client:</p> <pre><code>clientele start-api -u http://localhost:8000/api/openapi.json -o my_client/ --asyncio\n</code></pre>"},{"location":"server-django-ninja/#step-3-use-the-scaffolded-client","title":"Step 3: Use the scaffolded Client","text":""},{"location":"server-django-ninja/#usage-example","title":"Usage Example","text":"<pre><code>from my_client import client, schemas\n\n# Call a GET endpoint\nresponse = client.list_users_api_users_get()\n\n# Call a POST endpoint with data\nuser_data = schemas.UserIn(\n    username=\"alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_api_users_post(data=user_data)\n\n# Handle responses\nmatch response:\n    case schemas.UserOut():\n        print(f\"User created: {response.username}\")\n    case schemas.Error():\n        print(f\"Error: {response.message}\")\n</code></pre>"},{"location":"server-django-ninja/#async-usage-example","title":"Async usage Example","text":"<p>If your Django Ninja views are async:</p> <pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.UserIn(\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_api_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"server-django-ninja/#working-with-operation_id","title":"Working with operation_id","text":"<p>Django Ninja generates <code>operation_id</code> values for each endpoint, which Clientele uses to create function names.</p>"},{"location":"server-django-ninja/#default-operation-id","title":"Default Operation ID","text":"<p>By default, Django Ninja generates operation IDs from the function name and path:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n\n@api.get(\"/users\")\ndef list_users(request):\n    return []\n</code></pre> <p>This might generate: <code>list_users_api_users_get</code></p>"},{"location":"server-django-ninja/#custom-operation_id","title":"Custom operation_id","text":"<p>You can customize the operation ID in Django Ninja to get cleaner function names:</p> <pre><code>from ninja import NinjaAPI\n\napi = NinjaAPI()\n\n@api.get(\"/users\", operation_id=\"list_users\")\ndef get_users(request):\n    return []\n\n@api.post(\"/users\", operation_id=\"create_user\")\ndef create_user(request, user: UserIn):\n    return user\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of <code>client.list_users_api_users_get()</code></li> <li><code>client.create_user()</code> instead of <code>client.create_user_api_users_post()</code></li> </ul>"},{"location":"server-django-ninja/#authentication","title":"Authentication","text":"<p>See api authentication.</p>"},{"location":"server-django-ninja/#schemas-and-pydantic","title":"Schemas and Pydantic","text":"<p>Django Ninja uses Pydantic for schemas, which aligns perfectly with Clientele!</p>"},{"location":"server-django-ninja/#django-ninja-schema","title":"Django Ninja Schema","text":"<pre><code>from ninja import Schema\n\nclass UserIn(Schema):\n    username: str\n    email: str\n    age: int\n\nclass UserOut(Schema):\n    id: int\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n</code></pre>"},{"location":"server-django-ninja/#generated-client-schemas","title":"Generated Client Schemas","text":"<p>Clientele converts these to Pydantic models in the client:</p> <pre><code># In my_client/schemas.py\nimport pydantic\nfrom datetime import datetime\n\nclass UserIn(pydantic.BaseModel):\n    username: str\n    email: str\n    age: int\n\nclass UserOut(pydantic.BaseModel):\n    id: int\n    username: str\n    email: str\n    age: int\n    created_at: datetime\n</code></pre>"},{"location":"server-django-ninja/#usage","title":"Usage","text":"<pre><code># Create request data\nuser_data = schemas.UserIn(\n    username=\"alice\",\n    email=\"alice@example.com\",\n    age=30\n)\n\n# Get typed response\nresponse = client.create_user(data=user_data)\n# response is typed as schemas.UserOut\nprint(response.id)\n</code></pre>"},{"location":"server-django-ninja/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>Django Ninja's path and query parameters are automatically converted to function arguments:</p> <p>Django Ninja Endpoint</p> <pre><code>from ninja import Query\n\n@api.get(\"/users/{user_id}\")\ndef get_user(request, user_id: int, include_posts: bool = Query(False)):\n    return {\n        \"user_id\": user_id,\n        \"include_posts\": include_posts\n    }\n</code></pre> <p>Client Usage</p> <pre><code># Required path parameter, optional query parameter\nresponse = client.get_user_api_users_user_id_get(\n    user_id=123,\n    include_posts=True\n)\n</code></pre>"},{"location":"server-django-ninja/#response-models","title":"Response Models","text":"<p>Django Ninja's response models become Pydantic schemas in the client:</p> <p>Django Ninja Endpoint</p> <pre><code>class UserOut(Schema):\n    id: int\n    username: str\n    email: str\n\n@api.get(\"/users/{user_id}\", response=UserOut)\ndef get_user(request, user_id: int):\n    return UserOut(\n        id=user_id,\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n</code></pre> <p>Generated Client Usage</p> <pre><code>response = client.get_user_api_users_user_id_get(user_id=123)\n# response is typed as schemas.UserOut\nprint(response.username)\n</code></pre>"},{"location":"server-django-ninja/#best-practices","title":"Best Practices","text":"<ol> <li>Use custom <code>operation_id</code> values for cleaner function names</li> <li>Keep schemas in sync by regenerating after API changes</li> <li>Version your generated client in git to track changes</li> <li>Test thoroughly after regenerating</li> <li>Document your endpoints - Django Ninja includes docstrings in the schema</li> </ol>"},{"location":"server-django-ninja/#next-steps","title":"Next Steps","text":"<ul> <li>Configure authentication</li> <li>Set up testing</li> </ul>"},{"location":"server-drf/","title":"\ud83e\udd84 Using Clientele with Django REST Framework","text":"<p>This guide shows you how to scaffold a Python client for a Django REST Framework (DRF) API using Clientele and drf-spectacular.</p> <p>\ud83d\udca1 Working Example: See a real Django REST Framework application with code examples from this guide in <code>server_examples/django_rest_framework/</code></p>"},{"location":"server-drf/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Django REST Framework application</li> <li>drf-spectacular installed and configured</li> </ul>"},{"location":"server-drf/#why-drf-spectacular","title":"Why drf-spectacular?","text":"<p>Django REST Framework doesn't include built-in OpenAPI schema generation. drf-spectacular is the recommended solution for generating OpenAPI 3.0 schemas from DRF applications. It's actively maintained and provides excellent OpenAPI support.</p>"},{"location":"server-drf/#step-1-install-and-configure-drf-spectacular","title":"Step 1: Install and Configure drf-spectacular","text":"<p>If you haven't already set up drf-spectacular, follow these steps:</p>"},{"location":"server-drf/#install-drf-spectacular","title":"Install drf-spectacular","text":"<pre><code>pip install drf-spectacular\n</code></pre>"},{"location":"server-drf/#configure-django-settings","title":"Configure Django Settings","text":"<p>Add to your <code>settings.py</code>:</p> <pre><code>INSTALLED_APPS = [\n    # ...\n    'rest_framework',\n    'drf_spectacular',\n    # ...\n]\n\nREST_FRAMEWORK = {\n    # ...\n    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',\n}\n\nSPECTACULAR_SETTINGS = {\n    'TITLE': 'Your API',\n    'DESCRIPTION': 'Your API description',\n    'VERSION': '1.0.0',\n    'SERVE_INCLUDE_SCHEMA': False,\n}\n</code></pre>"},{"location":"server-drf/#add-url-patterns","title":"Add URL Patterns","text":"<p>In your <code>urls.py</code>:</p> <pre><code>from drf_spectacular.views import SpectacularAPIView\nfrom django.urls import path\n\nurlpatterns = [\n    # ...\n    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),\n]\n</code></pre>"},{"location":"server-drf/#step-2-get-your-openapi-schema","title":"Step 2: Get Your OpenAPI Schema","text":"<p>After configuring drf-spectacular, your OpenAPI schema is available at:</p> <pre><code>http://your-api-domain/api/schema/\n</code></pre> <p>For local development:</p> <pre><code>http://localhost:8000/api/schema/\n</code></pre>"},{"location":"server-drf/#downloading-the-schema","title":"Downloading the Schema","text":"<p>You can either:</p> <p>Option A: Use the URL directly (if the API is accessible):</p> <pre><code>clientele start-api -u http://localhost:8000/api/schema/ -o my_client/\n</code></pre> <p>Option B: Download the schema file first:</p> <pre><code>curl http://localhost:8000/api/schema/ &gt; openapi.json\nclientele start-api -f openapi.json -o my_client/\n</code></pre> <p>Option C: Generate schema file with Django management command:</p> <pre><code>python manage.py spectacular --file openapi.json\nclientele start-api -f openapi.json -o my_client/\n</code></pre>"},{"location":"server-drf/#step-3-scaffold-the-client","title":"Step 3: Scaffold the Client","text":"<pre><code>clientele start-api -u http://localhost:8000/api/schema/ -o my_client/\n</code></pre>"},{"location":"server-drf/#async-client","title":"Async Client","text":"<p>If you want an async client (note: DRF itself is synchronous, but the client can be async):</p> <pre><code>clientele start-api -u http://localhost:8000/api/schema/ -o my_client/ --asyncio\n</code></pre>"},{"location":"server-drf/#step-4-use-the-scaffolded-client","title":"Step 4: Use the scaffolded Client","text":""},{"location":"server-drf/#usage-example","title":"Usage Example","text":"<pre><code>from my_client import client, schemas\n\n# List resources\nresponse = client.list_users_api_users_get()\n\n# Create a resource\nuser_data = schemas.UserRequest(\n    username=\"alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_api_users_post(data=user_data)\n\n# Handle responses\nmatch response:\n    case schemas.User():\n        print(f\"User created: {response.username}\")\n    case schemas.ValidationError():\n        print(f\"Validation failed: {response.detail}\")\n</code></pre>"},{"location":"server-drf/#async-usage-example","title":"Async usage Example","text":"<pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.UserRequest(\n        username=\"alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_api_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"server-drf/#improving-operationid-in-drf","title":"Improving operationId in DRF","text":"<p>By default, drf-spectacular generates operation IDs from view names and paths. You can customize them for cleaner function names.</p>"},{"location":"server-drf/#using-extend_schema-decorator","title":"Using extend_schema Decorator","text":"<pre><code>from drf_spectacular.utils import extend_schema\nfrom rest_framework import viewsets\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n    @extend_schema(operation_id=\"list_users\")\n    def list(self, request):\n        return super().list(request)\n\n    @extend_schema(operation_id=\"create_user\")\n    def create(self, request):\n        return super().create(request)\n\n    @extend_schema(operation_id=\"get_user\")\n    def retrieve(self, request, pk=None):\n        return super().retrieve(request, pk)\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of a generic operation ID</li> <li><code>client.create_user()</code> instead of verbose auto-generated names</li> <li><code>client.get_user()</code> for clean, readable function names</li> </ul>"},{"location":"server-drf/#for-function-based-views","title":"For Function-Based Views","text":"<pre><code>from drf_spectacular.utils import extend_schema\nfrom rest_framework.decorators import api_view\n\n@extend_schema(\n    operation_id=\"get_user_stats\",\n    responses={200: UserStatsSerializer}\n)\n@api_view(['GET'])\ndef user_stats(request, user_id):\n    # ...\n    return Response(data)\n</code></pre>"},{"location":"server-drf/#authentication","title":"Authentication","text":"<p>See api authentication.</p>"},{"location":"server-drf/#serializers-and-schemas","title":"Serializers and Schemas","text":"<p>DRF serializers become Pydantic models in the generated client:</p>"},{"location":"server-drf/#drf-serializer","title":"DRF Serializer","text":"<pre><code>from rest_framework import serializers\n\nclass UserSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = User\n        fields = ['id', 'username', 'email', 'is_active']\n</code></pre>"},{"location":"server-drf/#generated-pydantic-schema","title":"Generated Pydantic Schema","text":"<pre><code># In my_client/schemas.py\nimport pydantic\n\nclass User(pydantic.BaseModel):\n    id: int\n    username: str\n    email: str\n    is_active: bool\n</code></pre>"},{"location":"server-drf/#usage","title":"Usage","text":"<pre><code># The client returns properly typed responses\nresponse = client.get_user_api_users_id_get(id=123)\n# response is typed as schemas.User\nprint(response.username)\n</code></pre>"},{"location":"server-drf/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>Query parameters are automatically converted to function arguments:</p> <p>DRF View with Filtering</p> <pre><code>class UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n    filterset_fields = ['is_active', 'username']\n</code></pre> <p>Client Usage</p> <pre><code># Query parameters become function arguments\nresponse = client.list_users_api_users_get(\n    is_active=True,\n    username=\"alice\"\n)\n</code></pre>"},{"location":"server-drf/#response-models","title":"Response Models","text":"<p>DRF's serializers become response models in the client:</p> <p>DRF ViewSet</p> <pre><code>from rest_framework import serializers, viewsets\n\nclass User(serializers.ModelSerializer):\n    class Meta:\n        model = UserModel\n        fields = ['id', 'username', 'email']\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = UserModel.objects.all()\n    serializer_class = User\n</code></pre> <p>Generated Client Usage</p> <pre><code>response = client.get_user_api_users_id_get(id=123)\n# response is typed as schemas.User\nprint(response.username)\n</code></pre>"},{"location":"server-drf/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>@extend_schema</code> to provide clear operation IDs and response types</li> <li>Keep schemas in sync by regenerating after API changes</li> <li>Version your generated client in git to track changes</li> <li>Test thoroughly after regenerating</li> <li>Document your serializers - drf-spectacular uses docstrings in schema generation</li> </ol>"},{"location":"server-drf/#next-steps","title":"Next Steps","text":"<ul> <li>Configure authentication</li> <li>Set up testing</li> </ul>"},{"location":"server-fastapi/","title":"\u26a1\ufe0f Using Clientele with FastAPI","text":"<p>This guide shows you how to scaffold a Python client for a FastAPI application using Clientele.</p> <p>\ud83d\udca1 Working Example: See a real FastAPI application with code examples from this guide in <code>server_examples/fastapi/</code></p>"},{"location":"server-fastapi/#prerequisites","title":"Prerequisites","text":"<ul> <li>A FastAPI application with API endpoints</li> <li>FastAPI's automatic OpenAPI schema generation enabled (enabled by default)</li> </ul>"},{"location":"server-fastapi/#step-1-get-your-openapi-schema","title":"Step 1: Get Your OpenAPI Schema","text":"<p>FastAPI automatically generates an OpenAPI schema for your API. You can access it at:</p> <pre><code>http://your-api-domain/openapi.json\n</code></pre> <p>For example, if your FastAPI app is running locally on port 8000:</p> <pre><code>http://localhost:8000/openapi.json\n</code></pre>"},{"location":"server-fastapi/#downloading-the-schema","title":"Downloading the Schema","text":"<p>You can either:</p> <p>Option A: Use the URL directly (if the API is accessible):</p> <pre><code>clientele start-api -u http://localhost:8000/openapi.json -o my_client/\n</code></pre> <p>Option B: Download the schema file first:</p> <pre><code>curl http://localhost:8000/openapi.json &gt; openapi.json\nclientele start-api -f openapi.json -o my_client/\n</code></pre>"},{"location":"server-fastapi/#step-2-scaffold-the-client","title":"Step 2: Scaffold the Client","text":"<pre><code>clientele start-api -u http://localhost:8000/openapi.json -o my_client/\n</code></pre>"},{"location":"server-fastapi/#async-client","title":"Async Client","text":"<p>If your FastAPI app uses async endpoints and you want an async client:</p> <pre><code>clientele start-api -u http://localhost:8000/openapi.json -o my_client/ --asyncio\n</code></pre>"},{"location":"server-fastapi/#step-3-use-the-scaffolded-client","title":"Step 3: Use the scaffolded Client","text":""},{"location":"server-fastapi/#usage-example","title":"Usage Example","text":"<pre><code>from my_client import client, schemas\n\n# Call a simple GET endpoint\nresponse = client.get_users_users_get()\n\n# Call a POST endpoint with data\nuser_data = schemas.CreateUserRequest(\n    name=\"Alice\",\n    email=\"alice@example.com\"\n)\nresponse = client.create_user_users_post(data=user_data)\n\n# Handle different response types\nmatch response:\n    case schemas.UserResponse():\n        print(f\"User created: {response.name}\")\n    case schemas.HTTPValidationError():\n        print(f\"Validation error: {response.detail}\")\n</code></pre>"},{"location":"server-fastapi/#async-usage-example","title":"Async usage Example","text":"<pre><code>from my_async_client import client, schemas\n\nasync def create_user():\n    user_data = schemas.CreateUserRequest(\n        name=\"Alice\",\n        email=\"alice@example.com\"\n    )\n    response = await client.create_user_users_post(data=user_data)\n    return response\n</code></pre>"},{"location":"server-fastapi/#working-with-operationid","title":"Working with operationId","text":"<p>FastAPI generates <code>operationId</code> values for each endpoint, which Clientele uses to create function names.</p>"},{"location":"server-fastapi/#default-operationid-generation","title":"Default operationId Generation","text":"<p>By default, FastAPI creates operation IDs like: <code>{function_name}_{path}_{method}</code></p> <p>For example:</p> <ul> <li>Function <code>get_users()</code> at path <code>/users</code> with GET \u2192 <code>get_users_users_get</code></li> <li>Function <code>create_user()</code> at path <code>/users</code> with POST \u2192 <code>create_user_users_post</code></li> </ul>"},{"location":"server-fastapi/#custom-operationid","title":"Custom operationId","text":"<p>You can customize the operation ID in FastAPI to get cleaner function names:</p> <pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/users\", operation_id=\"list_users\")\ndef get_users():\n    return []\n\n@app.post(\"/users\", operation_id=\"create_user\")\ndef create_user(user: UserCreate):\n    return user\n</code></pre> <p>This generates:</p> <ul> <li><code>client.list_users()</code> instead of <code>client.get_users_users_get()</code></li> <li><code>client.create_user()</code> instead of <code>client.create_user_users_post()</code></li> </ul>"},{"location":"server-fastapi/#authentication","title":"Authentication","text":"<p>See api authentication.</p>"},{"location":"server-fastapi/#path-and-query-parameters","title":"Path and Query Parameters","text":"<p>FastAPI's path and query parameters are automatically converted to function arguments:</p> <p>FastAPI Endpoint</p> <pre><code>@app.get(\"/users/{user_id}\")\ndef get_user(user_id: int, include_posts: bool = False):\n    return {\"user_id\": user_id, \"include_posts\": include_posts}\n</code></pre> <p>Client Usage</p> <pre><code># Required path parameter, optional query parameter\nresponse = client.get_user_users_user_id_get(\n    user_id=123,\n    include_posts=True\n)\n</code></pre>"},{"location":"server-fastapi/#response-models","title":"Response Models","text":"<p>FastAPI's response models become Pydantic schemas in the client:</p> <p>FastAPI Endpoint</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: str\n\n@app.get(\"/users/{user_id}\", response_model=User)\ndef get_user(user_id: int):\n    return User(id=user_id, name=\"Alice\", email=\"alice@example.com\")\n</code></pre> <p>Generated Client Usage</p> <pre><code>response = client.get_user_users_user_id_get(user_id=123)\n# response is typed as schemas.User\nprint(response.name)\n</code></pre>"},{"location":"server-fastapi/#best-practices","title":"Best Practices","text":"<ol> <li>Use custom operationId values for cleaner function names</li> <li>Keep schemas in sync by regenerating after API changes</li> <li>Version your generated client in git to track changes</li> <li>Test thoroughly after regenerating</li> <li>Use the same Python version for both API and client when possible</li> </ol>"},{"location":"server-fastapi/#next-steps","title":"Next Steps","text":"<ul> <li>Configure authentication</li> <li>Set up testing</li> </ul>"}]}