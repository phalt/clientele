
class HTTPClient:
    """HTTP client wrapper that manages the httpx client with configuration."""
    
    def __init__(self, config: c.Config):
        self.config = config
        self._client: typing.Optional[httpx.{{client_type}}] = None
    
    def _get_client(self) -> httpx.{{client_type}}:
        """Get or create the httpx client with current configuration."""
        if self._client is None:
            client_headers = self.config.additional_headers.copy()
            client_kwargs = dict(
                headers=client_headers,
                timeout=self.config.timeout,
                follow_redirects=self.config.follow_redirects,
                verify=self.config.verify_ssl,
                http2=self.config.http2,
                max_redirects=self.config.max_redirects,
            )
            if self.config.limits is not None:
                client_kwargs['limits'] = self.config.limits
            self._client = httpx.{{client_type}}(**client_kwargs)
        return self._client
    
    def _get_headers(self, additional_headers: typing.Optional[dict] = None) -> dict:
        """Get headers for a request, merging config and request-specific headers."""
        headers = self.config.additional_headers.copy()
        if additional_headers:
            headers.update(additional_headers)
        return headers

{% if client_type == 'AsyncClient' %}
    @contextlib.asynccontextmanager
    async def _client_context(self):
        """Async context manager for the HTTP client."""
        yield self._get_client()
{% endif %}
