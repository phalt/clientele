

class HTTPClient:
    """HTTP client wrapper that manages the httpx client with configuration."""
    
    def __init__(self, config: c.Config):
        self.config = config
        self._client: typing.Optional[httpx.{{client_type}}] = None
    
    def _get_client(self) -> httpx.{{client_type}}:
        """Get or create the httpx client with current configuration."""
        if self._client is None:
            client_headers = self.config.additional_headers.copy()
            client_headers.update(Authorization=f'Bearer {self.config.bearer_token}')
            client_kwargs: dict[str, typing.Any] = {
                'headers': client_headers,
                'timeout': self.config.timeout,
                'follow_redirects': self.config.follow_redirects,
                'verify': self.config.verify_ssl,
                'http2': self.config.http2,
                'max_redirects': self.config.max_redirects,
            }
            if _limits := self.config.limits:
                client_kwargs['limits'] = _limits
            if _transport := self.config.transport:
                client_kwargs['transport'] = _transport
            self._client = httpx.{{client_type}}(**client_kwargs)
        return self._client
    
    def _get_headers(self, additional_headers: typing.Optional[dict] = None) -> dict:
        """Get headers for a request, merging config and request-specific headers."""
        headers = self.config.additional_headers.copy()
        headers.update(Authorization=f'Bearer {self.config.bearer_token}')
        if additional_headers:
            headers.update(additional_headers)
        return headers

{% if client_type == 'AsyncClient' %}
    @contextlib.asynccontextmanager
    async def _client_context(self):
        """Async context manager for the HTTP client."""
        yield self._get_client()
{% endif %}
