# ðŸª„ Client example

Let's build an API Client using clientele.

Our [GitHub](https://github.com/phalt/clientele/tree/main/example_openapi_specs) has a bunch of schemas that are proven to work with clientele, so let's use one of those!

## Generate the client

In your project's root directory:

```sh
clientele generate -u https://raw.githubusercontent.com/phalt/clientele/main/example_openapi_specs/best.json -o my_client/
```

!!! note

    The example above uses one of our test schemas, and will work if you copy/paste it!

The `-u` parameter expects a URL, you can provide a path to a file with `-f` instead if you download the file.

The `-o` parameter is the output directory of the generated client.

Run it now and you will see this output:

```sh
my_client/
    __init__.py
    client.py
    config.py
    http.py
    MANIFEST
    schemas.py
```

Let's go over each file and talk about what it does.

## Client

### GET functions

The `client.py` file provides all the API functions from the OpenAPI schema. Functions are a combination of the path and the HTTP method for those paths. So, a path with two HTTP methods will be turned into two python functions.

```py title="my_client/client.py" linenums="1"
from my_client import http, schemas


def simple_request_simple_request_get() -> schemas.SimpleResponse:
    """Simple Request"""

    response = http.get(url="/simple-request")
    return http.handle_response(simple_request_simple_request_get, response)

...
```

We can see one of the functions here, `simple_request_simple_request_get`, is for a straight-forward HTTP GET request without any input arguments, and it returns a schema object.

Here is how you might use it:

```py
from my_client import client

client.simple_request_simple_request_get()
>>> SimpleResponse(name='Hello, clientele')
```

### POST and PUT functions

Here's a more complex example for an HTTP POST method. It requires an input property called `data` that is an instance of a schema, and returns one of many potential responses. If the endpoint has URL or query parameters, they'll appear as input arguments to the function alongside the `data` argument.

```py
def request_data_request_data_post(
    data: schemas.RequestDataRequest
) -> schemas.RequestDataResponse | schemas.HTTPValidationError:
    """Request Data"""

    response = http.post(url="/request-data", data=data.model_dump())
    return http.handle_response(request_data_request_data_post, response)
```

Here is how you might use it:

```py
from my_client import client, schemas

data = schemas.RequestDataRequest(my_input="Hello, world")
response = client.request_data_request_data_post(data=data)
>>> RequestDataResponse(your_input='Hello, world')
```

Clientele also supports the major HTTP methods PUT and DELETE in the same way.

### URL and Query parameters

If your endpoint takes [path parameters](https://learn.openapis.org/specification/parameters.html#parameter-location) (aka URL parameters) then clientele will turn them into parameters in the function:

```py
from my_client import client

client.parameter_request_simple_request(your_input="gibberish")
>>> ParameterResponse(your_input='gibberish')
```

Query parameters will also be generated the same way. See [this example](https://github.com/phalt/clientele/blob/0.4.4/tests/test_client/client.py#L71) for a function that takes a required query parameter.

Note that, optional parameters that are not passed will be omitted when the URL is generated by Clientele.

### Handling responses

Because we're using Pydantic to manage the input data, we get a strongly-typed response object.
This works beautifully with the new [structural pattern matching](https://peps.python.org/pep-0636/) feature in Python 3.10 and up:

```py

response = client.request_data_request_data_post(data=data)

# Handle responses elegantly
match response:
    case schemas.RequestDataResponse():
        # Handle valid response
        ...
    case schemas.ValidationError():
        # Handle validation error
        ...
```

### API Exceptions

Clientele keeps a mapping of the paths and their potential response codes. When it gets a response code that fits into the map, it generates the Pydantic object associated with it.

If the HTTP response code is unexpected, it won't match a return type. In this case, the function will raise an `http.APIException`.

```py
from my_client import client, http
try:
    good_response = my_client.get_my_thing()
except http.APIException as e:
    # The API got a response code we didn't expect
    print(e.response.status_code)
```

The `response` object is attached to this exception class for debugging.

## Schemas

The `schemas.py` file has all the possible schemas - request, response, and even Enums - for the API. These are taken from OpenAPI's schema objects and turned into Python classes. They all subclass from Pydantic's `BaseModel`.

Here are a few examples:

```py title="my_client/schemas.py" linenums="1"
import pydantic
from enum import Enum


class ParameterResponse(pydantic.BaseModel):
    your_input: str

class RequestDataRequest(pydantic.BaseModel):
    my_input: str

class RequestDataResponse(pydantic.BaseModel):
    my_input: str

# Enums subclass str so they serialize to JSON nicely
class ExampleEnum(str, Enum):
    ONE = "ONE"
    TWO = "TWO"
```

## Configuration

See [configuration](configuration.md).
